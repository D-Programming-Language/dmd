// Automatically generated by Digital Mars D Compiler

#pragma once

#include <stddef.h>
#include <stdint.h>

#if !defined(_d_real)
# define _d_real long double
#endif
#if !defined(BEGIN_ENUM)
# define BEGIN_ENUM(name, upper, lower) enum class name {
# define ENUM_KEY(type, name, value, enumName, upper, lower, abbrev) name = value,
# define END_ENUM(name, upper, lower) };
#endif
#if !defined(BEGIN_ENUM_NUMERIC)
# define BEGIN_ENUM_NUMERIC(type, name, upper, lower) enum class name : type {
# define ENUM_KEY_NUMERIC(type, name, value, enumName, upper, lower, abbrev) name = value,
# define END_ENUM_NUMERIC(type, name, upper, lower) };
#endif
#if !defined(BEGIN_ENUM_TYPE)
# define BEGIN_ENUM_TYPE(type, name, upper, lower) namespace name {
# define ENUM_KEY_TYPE(type, name, value, enumName, upper, lower, abbrev) static type const name = value;
# define END_ENUM_TYPE(type, name, upper, lower) };
#endif
#if !defined(BEGIN_ANON_ENUM)
# define BEGIN_ANON_ENUM() enum {
# define ANON_ENUM_KEY(type, name, value) name = value,
# define END_ANON_ENUM() };
#endif
#if !defined(BEGIN_ANON_ENUM_NUMERIC)
# define BEGIN_ANON_ENUM_NUMERIC(type) enum : type {
# define ANON_ENUM_KEY_NUMERIC(type, name, value) name = value,
# define END_ANON_ENUM_NUMERIC(type) };
#endif
#if !defined(ENUM_CONSTANT_NUMERIC)
# define ENUM_CONSTANT_NUMERIC(type, name, value) enum : type { name = value };
#endif
#if !defined(ENUM_CONSTANT)
# define ENUM_CONSTANT(type, name, value) static type const name = value;
#endif

class RootObject;
BEGIN_ENUM(DYNCAST, DYNCAST, dyncast)
ENUM_KEY(int32_t, object, 0, DYNCAST, DYNCAST, dyncast, DYNCAST)
ENUM_KEY(int32_t, expression, 1, DYNCAST, DYNCAST, dyncast, DYNCAST)
ENUM_KEY(int32_t, dsymbol, 2, DYNCAST, DYNCAST, dyncast, DYNCAST)
ENUM_KEY(int32_t, type, 3, DYNCAST, DYNCAST, dyncast, DYNCAST)
ENUM_KEY(int32_t, identifier, 4, DYNCAST, DYNCAST, dyncast, DYNCAST)
ENUM_KEY(int32_t, tuple, 5, DYNCAST, DYNCAST, dyncast, DYNCAST)
ENUM_KEY(int32_t, parameter, 6, DYNCAST, DYNCAST, dyncast, DYNCAST)
ENUM_KEY(int32_t, statement, 7, DYNCAST, DYNCAST, dyncast, DYNCAST)
ENUM_KEY(int32_t, condition, 8, DYNCAST, DYNCAST, dyncast, DYNCAST)
ENUM_KEY(int32_t, templateparameter, 9, DYNCAST, DYNCAST, dyncast, DYNCAST)
END_ENUM(DYNCAST, DYNCAST, dyncast)

class Visitor;
class Identifier;
class Dsymbol;
class CPPNamespaceDeclaration;
struct Symbol;
struct Loc;
struct Scope;
BEGIN_ENUM(PASS, PASS, pass)
ENUM_KEY(int32_t, init, 0, PASS, PASS, pass, PASS)
ENUM_KEY(int32_t, semantic, 1, PASS, PASS, pass, PASS)
ENUM_KEY(int32_t, semanticdone, 2, PASS, PASS, pass, PASS)
ENUM_KEY(int32_t, semantic2, 3, PASS, PASS, pass, PASS)
ENUM_KEY(int32_t, semantic2done, 4, PASS, PASS, pass, PASS)
ENUM_KEY(int32_t, semantic3, 5, PASS, PASS, pass, PASS)
ENUM_KEY(int32_t, semantic3done, 6, PASS, PASS, pass, PASS)
ENUM_KEY(int32_t, inline, 7, PASS, PASS, pass, PASS)
ENUM_KEY(int32_t, inlinedone, 8, PASS, PASS, pass, PASS)
ENUM_KEY(int32_t, obj, 9, PASS, PASS, pass, PASS)
END_ENUM(PASS, PASS, pass)

class DeprecatedDeclaration;
class UserAttributeDeclaration;
class UnitTestDeclaration;
class Module;
class TemplateInstance;
struct Ungag;
class ScopeDsymbol;
class AggregateDeclaration;
class LabelDsymbol;
class ClassDeclaration;
class Type;
struct Prot;
class Package;
class EnumMember;
class TemplateDeclaration;
class TemplateMixin;
class ForwardingAttribDeclaration;
class Nspace;
class Declaration;
class StorageClassDeclaration;
class ExpressionDsymbol;
class ThisDeclaration;
class TypeInfoDeclaration;
class TupleDeclaration;
class AliasDeclaration;
class FuncDeclaration;
class FuncAliasDeclaration;
class OverDeclaration;
class FuncLiteralDeclaration;
class CtorDeclaration;
class PostBlitDeclaration;
class DtorDeclaration;
class StaticCtorDeclaration;
class StaticDtorDeclaration;
class SharedStaticCtorDeclaration;
class SharedStaticDtorDeclaration;
class InvariantDeclaration;
class NewDeclaration;
class VarDeclaration;
class VersionSymbol;
class DebugSymbol;
class StructDeclaration;
class UnionDeclaration;
class InterfaceDeclaration;
class ForwardingScopeDsymbol;
class WithScopeSymbol;
class ArrayScopeSymbol;
class Import;
class EnumDeclaration;
class SymbolDeclaration;
class AttribDeclaration;
class AnonDeclaration;
class ProtDeclaration;
class OverloadSet;
class CompileDeclaration;
class DsymbolTable;
BEGIN_ENUM(Kind, KIND, kind)
ENUM_KEY(int32_t, undefined, 0, Kind, KIND, kind, K)
ENUM_KEY(int32_t, none, 1, Kind, KIND, kind, K)
ENUM_KEY(int32_t, private_, 2, Kind, KIND, kind, K)
ENUM_KEY(int32_t, package_, 3, Kind, KIND, kind, K)
ENUM_KEY(int32_t, protected_, 4, Kind, KIND, kind, K)
ENUM_KEY(int32_t, public_, 5, Kind, KIND, kind, K)
ENUM_KEY(int32_t, export_, 6, Kind, KIND, kind, K)
END_ENUM(Kind, KIND, kind)

struct BitArray;
BEGIN_ENUM(CPPMANGLE, CPPMANGLE, cppmangle)
ENUM_KEY(int32_t, def, 0, CPPMANGLE, CPPMANGLE, cppmangle, CPPMANGLE)
ENUM_KEY(int32_t, asStruct, 1, CPPMANGLE, CPPMANGLE, cppmangle, CPPMANGLE)
ENUM_KEY(int32_t, asClass, 2, CPPMANGLE, CPPMANGLE, cppmangle, CPPMANGLE)
END_ENUM(CPPMANGLE, CPPMANGLE, cppmangle)

class AliasThis;
class Expression;
class TypeTuple;
class TemplateParameter;
class Statement;
struct BaseClass;
class Parameter;
class Initializer;
class Catch;
class CaseStatement;
class ScopeStatement;
class GotoCaseStatement;
class ReturnStatement;
class GotoStatement;
struct Ensure;
BEGIN_ENUM(LINK, LINK, link)
ENUM_KEY(int32_t, default_, 0, LINK, LINK, link, LINK)
ENUM_KEY(int32_t, d, 1, LINK, LINK, link, LINK)
ENUM_KEY(int32_t, c, 2, LINK, LINK, link, LINK)
ENUM_KEY(int32_t, cpp, 3, LINK, LINK, link, LINK)
ENUM_KEY(int32_t, windows, 4, LINK, LINK, link, LINK)
ENUM_KEY(int32_t, pascal, 5, LINK, LINK, link, LINK)
ENUM_KEY(int32_t, objc, 6, LINK, LINK, link, LINK)
ENUM_KEY(int32_t, system, 7, LINK, LINK, link, LINK)
END_ENUM(LINK, LINK, link)

class LinkDeclaration;
class Condition;
class StaticForeach;
BEGIN_ENUM_NUMERIC(int8_t, BUILTIN, BUILTIN, builtin)
ENUM_KEY_NUMERIC(int8_t, unknown, -1, BUILTIN, BUILTIN, builtin, BUILTIN)
ENUM_KEY_NUMERIC(int8_t, unimp, 0, BUILTIN, BUILTIN, builtin, BUILTIN)
ENUM_KEY_NUMERIC(int8_t, gcc, 1, BUILTIN, BUILTIN, builtin, BUILTIN)
ENUM_KEY_NUMERIC(int8_t, llvm, 2, BUILTIN, BUILTIN, builtin, BUILTIN)
ENUM_KEY_NUMERIC(int8_t, sin, 3, BUILTIN, BUILTIN, builtin, BUILTIN)
ENUM_KEY_NUMERIC(int8_t, cos, 4, BUILTIN, BUILTIN, builtin, BUILTIN)
ENUM_KEY_NUMERIC(int8_t, tan, 5, BUILTIN, BUILTIN, builtin, BUILTIN)
ENUM_KEY_NUMERIC(int8_t, sqrt, 6, BUILTIN, BUILTIN, builtin, BUILTIN)
ENUM_KEY_NUMERIC(int8_t, fabs, 7, BUILTIN, BUILTIN, builtin, BUILTIN)
ENUM_KEY_NUMERIC(int8_t, ldexp, 8, BUILTIN, BUILTIN, builtin, BUILTIN)
ENUM_KEY_NUMERIC(int8_t, log, 9, BUILTIN, BUILTIN, builtin, BUILTIN)
ENUM_KEY_NUMERIC(int8_t, log2, 10, BUILTIN, BUILTIN, builtin, BUILTIN)
ENUM_KEY_NUMERIC(int8_t, log10, 11, BUILTIN, BUILTIN, builtin, BUILTIN)
ENUM_KEY_NUMERIC(int8_t, exp, 12, BUILTIN, BUILTIN, builtin, BUILTIN)
ENUM_KEY_NUMERIC(int8_t, expm1, 13, BUILTIN, BUILTIN, builtin, BUILTIN)
ENUM_KEY_NUMERIC(int8_t, exp2, 14, BUILTIN, BUILTIN, builtin, BUILTIN)
ENUM_KEY_NUMERIC(int8_t, round, 15, BUILTIN, BUILTIN, builtin, BUILTIN)
ENUM_KEY_NUMERIC(int8_t, floor, 16, BUILTIN, BUILTIN, builtin, BUILTIN)
ENUM_KEY_NUMERIC(int8_t, ceil, 17, BUILTIN, BUILTIN, builtin, BUILTIN)
ENUM_KEY_NUMERIC(int8_t, trunc, 18, BUILTIN, BUILTIN, builtin, BUILTIN)
ENUM_KEY_NUMERIC(int8_t, copysign, 19, BUILTIN, BUILTIN, builtin, BUILTIN)
ENUM_KEY_NUMERIC(int8_t, pow, 20, BUILTIN, BUILTIN, builtin, BUILTIN)
ENUM_KEY_NUMERIC(int8_t, fmin, 21, BUILTIN, BUILTIN, builtin, BUILTIN)
ENUM_KEY_NUMERIC(int8_t, fmax, 22, BUILTIN, BUILTIN, builtin, BUILTIN)
ENUM_KEY_NUMERIC(int8_t, fma, 23, BUILTIN, BUILTIN, builtin, BUILTIN)
ENUM_KEY_NUMERIC(int8_t, isnan, 24, BUILTIN, BUILTIN, builtin, BUILTIN)
ENUM_KEY_NUMERIC(int8_t, isinfinity, 25, BUILTIN, BUILTIN, builtin, BUILTIN)
ENUM_KEY_NUMERIC(int8_t, isfinite, 26, BUILTIN, BUILTIN, builtin, BUILTIN)
ENUM_KEY_NUMERIC(int8_t, bsf, 27, BUILTIN, BUILTIN, builtin, BUILTIN)
ENUM_KEY_NUMERIC(int8_t, bsr, 28, BUILTIN, BUILTIN, builtin, BUILTIN)
ENUM_KEY_NUMERIC(int8_t, bswap, 29, BUILTIN, BUILTIN, builtin, BUILTIN)
ENUM_KEY_NUMERIC(int8_t, popcnt, 30, BUILTIN, BUILTIN, builtin, BUILTIN)
ENUM_KEY_NUMERIC(int8_t, yl2x, 31, BUILTIN, BUILTIN, builtin, BUILTIN)
ENUM_KEY_NUMERIC(int8_t, yl2xp1, 32, BUILTIN, BUILTIN, builtin, BUILTIN)
ENUM_KEY_NUMERIC(int8_t, toPrecFloat, 33, BUILTIN, BUILTIN, builtin, BUILTIN)
ENUM_KEY_NUMERIC(int8_t, toPrecDouble, 34, BUILTIN, BUILTIN, builtin, BUILTIN)
ENUM_KEY_NUMERIC(int8_t, toPrecReal, 35, BUILTIN, BUILTIN, builtin, BUILTIN)
END_ENUM_NUMERIC(int8_t, BUILTIN, BUILTIN, builtin)

struct UnionExp;
struct complex_t;
class DebugCondition;
class VersionCondition;
class ForeachStatement;
class ForeachRangeStatement;
BEGIN_ENUM_NUMERIC(uint8_t, TOK, TOK, tok)
ENUM_KEY_NUMERIC(uint8_t, reserved, 0u, TOK, TOK, tok, TOK)
ENUM_KEY_NUMERIC(uint8_t, leftParentheses, 1u, TOK, TOK, tok, TOK)
ENUM_KEY_NUMERIC(uint8_t, rightParentheses, 2u, TOK, TOK, tok, TOK)
ENUM_KEY_NUMERIC(uint8_t, leftBracket, 3u, TOK, TOK, tok, TOK)
ENUM_KEY_NUMERIC(uint8_t, rightBracket, 4u, TOK, TOK, tok, TOK)
ENUM_KEY_NUMERIC(uint8_t, leftCurly, 5u, TOK, TOK, tok, TOK)
ENUM_KEY_NUMERIC(uint8_t, rightCurly, 6u, TOK, TOK, tok, TOK)
ENUM_KEY_NUMERIC(uint8_t, colon, 7u, TOK, TOK, tok, TOK)
ENUM_KEY_NUMERIC(uint8_t, negate, 8u, TOK, TOK, tok, TOK)
ENUM_KEY_NUMERIC(uint8_t, semicolon, 9u, TOK, TOK, tok, TOK)
ENUM_KEY_NUMERIC(uint8_t, dotDotDot, 10u, TOK, TOK, tok, TOK)
ENUM_KEY_NUMERIC(uint8_t, endOfFile, 11u, TOK, TOK, tok, TOK)
ENUM_KEY_NUMERIC(uint8_t, cast_, 12u, TOK, TOK, tok, TOK)
ENUM_KEY_NUMERIC(uint8_t, null_, 13u, TOK, TOK, tok, TOK)
ENUM_KEY_NUMERIC(uint8_t, assert_, 14u, TOK, TOK, tok, TOK)
ENUM_KEY_NUMERIC(uint8_t, true_, 15u, TOK, TOK, tok, TOK)
ENUM_KEY_NUMERIC(uint8_t, false_, 16u, TOK, TOK, tok, TOK)
ENUM_KEY_NUMERIC(uint8_t, array, 17u, TOK, TOK, tok, TOK)
ENUM_KEY_NUMERIC(uint8_t, call, 18u, TOK, TOK, tok, TOK)
ENUM_KEY_NUMERIC(uint8_t, address, 19u, TOK, TOK, tok, TOK)
ENUM_KEY_NUMERIC(uint8_t, type, 20u, TOK, TOK, tok, TOK)
ENUM_KEY_NUMERIC(uint8_t, throw_, 21u, TOK, TOK, tok, TOK)
ENUM_KEY_NUMERIC(uint8_t, new_, 22u, TOK, TOK, tok, TOK)
ENUM_KEY_NUMERIC(uint8_t, delete_, 23u, TOK, TOK, tok, TOK)
ENUM_KEY_NUMERIC(uint8_t, star, 24u, TOK, TOK, tok, TOK)
ENUM_KEY_NUMERIC(uint8_t, symbolOffset, 25u, TOK, TOK, tok, TOK)
ENUM_KEY_NUMERIC(uint8_t, variable, 26u, TOK, TOK, tok, TOK)
ENUM_KEY_NUMERIC(uint8_t, dotVariable, 27u, TOK, TOK, tok, TOK)
ENUM_KEY_NUMERIC(uint8_t, dotIdentifier, 28u, TOK, TOK, tok, TOK)
ENUM_KEY_NUMERIC(uint8_t, dotTemplateInstance, 29u, TOK, TOK, tok, TOK)
ENUM_KEY_NUMERIC(uint8_t, dotType, 30u, TOK, TOK, tok, TOK)
ENUM_KEY_NUMERIC(uint8_t, slice, 31u, TOK, TOK, tok, TOK)
ENUM_KEY_NUMERIC(uint8_t, arrayLength, 32u, TOK, TOK, tok, TOK)
ENUM_KEY_NUMERIC(uint8_t, version_, 33u, TOK, TOK, tok, TOK)
ENUM_KEY_NUMERIC(uint8_t, module_, 34u, TOK, TOK, tok, TOK)
ENUM_KEY_NUMERIC(uint8_t, dollar, 35u, TOK, TOK, tok, TOK)
ENUM_KEY_NUMERIC(uint8_t, template_, 36u, TOK, TOK, tok, TOK)
ENUM_KEY_NUMERIC(uint8_t, dotTemplateDeclaration, 37u, TOK, TOK, tok, TOK)
ENUM_KEY_NUMERIC(uint8_t, declaration, 38u, TOK, TOK, tok, TOK)
ENUM_KEY_NUMERIC(uint8_t, typeof_, 39u, TOK, TOK, tok, TOK)
ENUM_KEY_NUMERIC(uint8_t, pragma_, 40u, TOK, TOK, tok, TOK)
ENUM_KEY_NUMERIC(uint8_t, dSymbol, 41u, TOK, TOK, tok, TOK)
ENUM_KEY_NUMERIC(uint8_t, typeid_, 42u, TOK, TOK, tok, TOK)
ENUM_KEY_NUMERIC(uint8_t, uadd, 43u, TOK, TOK, tok, TOK)
ENUM_KEY_NUMERIC(uint8_t, remove, 44u, TOK, TOK, tok, TOK)
ENUM_KEY_NUMERIC(uint8_t, newAnonymousClass, 45u, TOK, TOK, tok, TOK)
ENUM_KEY_NUMERIC(uint8_t, comment, 46u, TOK, TOK, tok, TOK)
ENUM_KEY_NUMERIC(uint8_t, arrayLiteral, 47u, TOK, TOK, tok, TOK)
ENUM_KEY_NUMERIC(uint8_t, assocArrayLiteral, 48u, TOK, TOK, tok, TOK)
ENUM_KEY_NUMERIC(uint8_t, structLiteral, 49u, TOK, TOK, tok, TOK)
ENUM_KEY_NUMERIC(uint8_t, classReference, 50u, TOK, TOK, tok, TOK)
ENUM_KEY_NUMERIC(uint8_t, thrownException, 51u, TOK, TOK, tok, TOK)
ENUM_KEY_NUMERIC(uint8_t, delegatePointer, 52u, TOK, TOK, tok, TOK)
ENUM_KEY_NUMERIC(uint8_t, delegateFunctionPointer, 53u, TOK, TOK, tok, TOK)
ENUM_KEY_NUMERIC(uint8_t, lessThan, 54u, TOK, TOK, tok, TOK)
ENUM_KEY_NUMERIC(uint8_t, greaterThan, 55u, TOK, TOK, tok, TOK)
ENUM_KEY_NUMERIC(uint8_t, lessOrEqual, 56u, TOK, TOK, tok, TOK)
ENUM_KEY_NUMERIC(uint8_t, greaterOrEqual, 57u, TOK, TOK, tok, TOK)
ENUM_KEY_NUMERIC(uint8_t, equal, 58u, TOK, TOK, tok, TOK)
ENUM_KEY_NUMERIC(uint8_t, notEqual, 59u, TOK, TOK, tok, TOK)
ENUM_KEY_NUMERIC(uint8_t, identity, 60u, TOK, TOK, tok, TOK)
ENUM_KEY_NUMERIC(uint8_t, notIdentity, 61u, TOK, TOK, tok, TOK)
ENUM_KEY_NUMERIC(uint8_t, index, 62u, TOK, TOK, tok, TOK)
ENUM_KEY_NUMERIC(uint8_t, is_, 63u, TOK, TOK, tok, TOK)
ENUM_KEY_NUMERIC(uint8_t, leftShift, 64u, TOK, TOK, tok, TOK)
ENUM_KEY_NUMERIC(uint8_t, rightShift, 65u, TOK, TOK, tok, TOK)
ENUM_KEY_NUMERIC(uint8_t, leftShiftAssign, 66u, TOK, TOK, tok, TOK)
ENUM_KEY_NUMERIC(uint8_t, rightShiftAssign, 67u, TOK, TOK, tok, TOK)
ENUM_KEY_NUMERIC(uint8_t, unsignedRightShift, 68u, TOK, TOK, tok, TOK)
ENUM_KEY_NUMERIC(uint8_t, unsignedRightShiftAssign, 69u, TOK, TOK, tok, TOK)
ENUM_KEY_NUMERIC(uint8_t, concatenate, 70u, TOK, TOK, tok, TOK)
ENUM_KEY_NUMERIC(uint8_t, concatenateAssign, 71u, TOK, TOK, tok, TOK)
ENUM_KEY_NUMERIC(uint8_t, concatenateElemAssign, 72u, TOK, TOK, tok, TOK)
ENUM_KEY_NUMERIC(uint8_t, concatenateDcharAssign, 73u, TOK, TOK, tok, TOK)
ENUM_KEY_NUMERIC(uint8_t, add, 74u, TOK, TOK, tok, TOK)
ENUM_KEY_NUMERIC(uint8_t, min, 75u, TOK, TOK, tok, TOK)
ENUM_KEY_NUMERIC(uint8_t, addAssign, 76u, TOK, TOK, tok, TOK)
ENUM_KEY_NUMERIC(uint8_t, minAssign, 77u, TOK, TOK, tok, TOK)
ENUM_KEY_NUMERIC(uint8_t, mul, 78u, TOK, TOK, tok, TOK)
ENUM_KEY_NUMERIC(uint8_t, div, 79u, TOK, TOK, tok, TOK)
ENUM_KEY_NUMERIC(uint8_t, mod, 80u, TOK, TOK, tok, TOK)
ENUM_KEY_NUMERIC(uint8_t, mulAssign, 81u, TOK, TOK, tok, TOK)
ENUM_KEY_NUMERIC(uint8_t, divAssign, 82u, TOK, TOK, tok, TOK)
ENUM_KEY_NUMERIC(uint8_t, modAssign, 83u, TOK, TOK, tok, TOK)
ENUM_KEY_NUMERIC(uint8_t, and, 84u, TOK, TOK, tok, TOK)
ENUM_KEY_NUMERIC(uint8_t, or, 85u, TOK, TOK, tok, TOK)
ENUM_KEY_NUMERIC(uint8_t, xor, 86u, TOK, TOK, tok, TOK)
ENUM_KEY_NUMERIC(uint8_t, andAssign, 87u, TOK, TOK, tok, TOK)
ENUM_KEY_NUMERIC(uint8_t, orAssign, 88u, TOK, TOK, tok, TOK)
ENUM_KEY_NUMERIC(uint8_t, xorAssign, 89u, TOK, TOK, tok, TOK)
ENUM_KEY_NUMERIC(uint8_t, assign, 90u, TOK, TOK, tok, TOK)
ENUM_KEY_NUMERIC(uint8_t, not, 91u, TOK, TOK, tok, TOK)
ENUM_KEY_NUMERIC(uint8_t, tilde, 92u, TOK, TOK, tok, TOK)
ENUM_KEY_NUMERIC(uint8_t, plusPlus, 93u, TOK, TOK, tok, TOK)
ENUM_KEY_NUMERIC(uint8_t, minusMinus, 94u, TOK, TOK, tok, TOK)
ENUM_KEY_NUMERIC(uint8_t, construct, 95u, TOK, TOK, tok, TOK)
ENUM_KEY_NUMERIC(uint8_t, blit, 96u, TOK, TOK, tok, TOK)
ENUM_KEY_NUMERIC(uint8_t, dot, 97u, TOK, TOK, tok, TOK)
ENUM_KEY_NUMERIC(uint8_t, arrow, 98u, TOK, TOK, tok, TOK)
ENUM_KEY_NUMERIC(uint8_t, comma, 99u, TOK, TOK, tok, TOK)
ENUM_KEY_NUMERIC(uint8_t, question, 100u, TOK, TOK, tok, TOK)
ENUM_KEY_NUMERIC(uint8_t, andAnd, 101u, TOK, TOK, tok, TOK)
ENUM_KEY_NUMERIC(uint8_t, orOr, 102u, TOK, TOK, tok, TOK)
ENUM_KEY_NUMERIC(uint8_t, prePlusPlus, 103u, TOK, TOK, tok, TOK)
ENUM_KEY_NUMERIC(uint8_t, preMinusMinus, 104u, TOK, TOK, tok, TOK)
ENUM_KEY_NUMERIC(uint8_t, int32Literal, 105u, TOK, TOK, tok, TOK)
ENUM_KEY_NUMERIC(uint8_t, uns32Literal, 106u, TOK, TOK, tok, TOK)
ENUM_KEY_NUMERIC(uint8_t, int64Literal, 107u, TOK, TOK, tok, TOK)
ENUM_KEY_NUMERIC(uint8_t, uns64Literal, 108u, TOK, TOK, tok, TOK)
ENUM_KEY_NUMERIC(uint8_t, int128Literal, 109u, TOK, TOK, tok, TOK)
ENUM_KEY_NUMERIC(uint8_t, uns128Literal, 110u, TOK, TOK, tok, TOK)
ENUM_KEY_NUMERIC(uint8_t, float32Literal, 111u, TOK, TOK, tok, TOK)
ENUM_KEY_NUMERIC(uint8_t, float64Literal, 112u, TOK, TOK, tok, TOK)
ENUM_KEY_NUMERIC(uint8_t, float80Literal, 113u, TOK, TOK, tok, TOK)
ENUM_KEY_NUMERIC(uint8_t, imaginary32Literal, 114u, TOK, TOK, tok, TOK)
ENUM_KEY_NUMERIC(uint8_t, imaginary64Literal, 115u, TOK, TOK, tok, TOK)
ENUM_KEY_NUMERIC(uint8_t, imaginary80Literal, 116u, TOK, TOK, tok, TOK)
ENUM_KEY_NUMERIC(uint8_t, charLiteral, 117u, TOK, TOK, tok, TOK)
ENUM_KEY_NUMERIC(uint8_t, wcharLiteral, 118u, TOK, TOK, tok, TOK)
ENUM_KEY_NUMERIC(uint8_t, dcharLiteral, 119u, TOK, TOK, tok, TOK)
ENUM_KEY_NUMERIC(uint8_t, identifier, 120u, TOK, TOK, tok, TOK)
ENUM_KEY_NUMERIC(uint8_t, string_, 121u, TOK, TOK, tok, TOK)
ENUM_KEY_NUMERIC(uint8_t, hexadecimalString, 122u, TOK, TOK, tok, TOK)
ENUM_KEY_NUMERIC(uint8_t, this_, 123u, TOK, TOK, tok, TOK)
ENUM_KEY_NUMERIC(uint8_t, super_, 124u, TOK, TOK, tok, TOK)
ENUM_KEY_NUMERIC(uint8_t, halt, 125u, TOK, TOK, tok, TOK)
ENUM_KEY_NUMERIC(uint8_t, tuple, 126u, TOK, TOK, tok, TOK)
ENUM_KEY_NUMERIC(uint8_t, error, 127u, TOK, TOK, tok, TOK)
ENUM_KEY_NUMERIC(uint8_t, void_, 128u, TOK, TOK, tok, TOK)
ENUM_KEY_NUMERIC(uint8_t, int8, 129u, TOK, TOK, tok, TOK)
ENUM_KEY_NUMERIC(uint8_t, uns8, 130u, TOK, TOK, tok, TOK)
ENUM_KEY_NUMERIC(uint8_t, int16, 131u, TOK, TOK, tok, TOK)
ENUM_KEY_NUMERIC(uint8_t, uns16, 132u, TOK, TOK, tok, TOK)
ENUM_KEY_NUMERIC(uint8_t, int32, 133u, TOK, TOK, tok, TOK)
ENUM_KEY_NUMERIC(uint8_t, uns32, 134u, TOK, TOK, tok, TOK)
ENUM_KEY_NUMERIC(uint8_t, int64, 135u, TOK, TOK, tok, TOK)
ENUM_KEY_NUMERIC(uint8_t, uns64, 136u, TOK, TOK, tok, TOK)
ENUM_KEY_NUMERIC(uint8_t, int128, 137u, TOK, TOK, tok, TOK)
ENUM_KEY_NUMERIC(uint8_t, uns128, 138u, TOK, TOK, tok, TOK)
ENUM_KEY_NUMERIC(uint8_t, float32, 139u, TOK, TOK, tok, TOK)
ENUM_KEY_NUMERIC(uint8_t, float64, 140u, TOK, TOK, tok, TOK)
ENUM_KEY_NUMERIC(uint8_t, float80, 141u, TOK, TOK, tok, TOK)
ENUM_KEY_NUMERIC(uint8_t, imaginary32, 142u, TOK, TOK, tok, TOK)
ENUM_KEY_NUMERIC(uint8_t, imaginary64, 143u, TOK, TOK, tok, TOK)
ENUM_KEY_NUMERIC(uint8_t, imaginary80, 144u, TOK, TOK, tok, TOK)
ENUM_KEY_NUMERIC(uint8_t, complex32, 145u, TOK, TOK, tok, TOK)
ENUM_KEY_NUMERIC(uint8_t, complex64, 146u, TOK, TOK, tok, TOK)
ENUM_KEY_NUMERIC(uint8_t, complex80, 147u, TOK, TOK, tok, TOK)
ENUM_KEY_NUMERIC(uint8_t, char_, 148u, TOK, TOK, tok, TOK)
ENUM_KEY_NUMERIC(uint8_t, wchar_, 149u, TOK, TOK, tok, TOK)
ENUM_KEY_NUMERIC(uint8_t, dchar_, 150u, TOK, TOK, tok, TOK)
ENUM_KEY_NUMERIC(uint8_t, bool_, 151u, TOK, TOK, tok, TOK)
ENUM_KEY_NUMERIC(uint8_t, struct_, 152u, TOK, TOK, tok, TOK)
ENUM_KEY_NUMERIC(uint8_t, class_, 153u, TOK, TOK, tok, TOK)
ENUM_KEY_NUMERIC(uint8_t, interface_, 154u, TOK, TOK, tok, TOK)
ENUM_KEY_NUMERIC(uint8_t, union_, 155u, TOK, TOK, tok, TOK)
ENUM_KEY_NUMERIC(uint8_t, enum_, 156u, TOK, TOK, tok, TOK)
ENUM_KEY_NUMERIC(uint8_t, import_, 157u, TOK, TOK, tok, TOK)
ENUM_KEY_NUMERIC(uint8_t, alias_, 158u, TOK, TOK, tok, TOK)
ENUM_KEY_NUMERIC(uint8_t, override_, 159u, TOK, TOK, tok, TOK)
ENUM_KEY_NUMERIC(uint8_t, delegate_, 160u, TOK, TOK, tok, TOK)
ENUM_KEY_NUMERIC(uint8_t, function_, 161u, TOK, TOK, tok, TOK)
ENUM_KEY_NUMERIC(uint8_t, mixin_, 162u, TOK, TOK, tok, TOK)
ENUM_KEY_NUMERIC(uint8_t, align_, 163u, TOK, TOK, tok, TOK)
ENUM_KEY_NUMERIC(uint8_t, extern_, 164u, TOK, TOK, tok, TOK)
ENUM_KEY_NUMERIC(uint8_t, private_, 165u, TOK, TOK, tok, TOK)
ENUM_KEY_NUMERIC(uint8_t, protected_, 166u, TOK, TOK, tok, TOK)
ENUM_KEY_NUMERIC(uint8_t, public_, 167u, TOK, TOK, tok, TOK)
ENUM_KEY_NUMERIC(uint8_t, export_, 168u, TOK, TOK, tok, TOK)
ENUM_KEY_NUMERIC(uint8_t, static_, 169u, TOK, TOK, tok, TOK)
ENUM_KEY_NUMERIC(uint8_t, final_, 170u, TOK, TOK, tok, TOK)
ENUM_KEY_NUMERIC(uint8_t, const_, 171u, TOK, TOK, tok, TOK)
ENUM_KEY_NUMERIC(uint8_t, abstract_, 172u, TOK, TOK, tok, TOK)
ENUM_KEY_NUMERIC(uint8_t, debug_, 173u, TOK, TOK, tok, TOK)
ENUM_KEY_NUMERIC(uint8_t, deprecated_, 174u, TOK, TOK, tok, TOK)
ENUM_KEY_NUMERIC(uint8_t, in_, 175u, TOK, TOK, tok, TOK)
ENUM_KEY_NUMERIC(uint8_t, out_, 176u, TOK, TOK, tok, TOK)
ENUM_KEY_NUMERIC(uint8_t, inout_, 177u, TOK, TOK, tok, TOK)
ENUM_KEY_NUMERIC(uint8_t, lazy_, 178u, TOK, TOK, tok, TOK)
ENUM_KEY_NUMERIC(uint8_t, auto_, 179u, TOK, TOK, tok, TOK)
ENUM_KEY_NUMERIC(uint8_t, package_, 180u, TOK, TOK, tok, TOK)
ENUM_KEY_NUMERIC(uint8_t, immutable_, 181u, TOK, TOK, tok, TOK)
ENUM_KEY_NUMERIC(uint8_t, if_, 182u, TOK, TOK, tok, TOK)
ENUM_KEY_NUMERIC(uint8_t, else_, 183u, TOK, TOK, tok, TOK)
ENUM_KEY_NUMERIC(uint8_t, while_, 184u, TOK, TOK, tok, TOK)
ENUM_KEY_NUMERIC(uint8_t, for_, 185u, TOK, TOK, tok, TOK)
ENUM_KEY_NUMERIC(uint8_t, do_, 186u, TOK, TOK, tok, TOK)
ENUM_KEY_NUMERIC(uint8_t, switch_, 187u, TOK, TOK, tok, TOK)
ENUM_KEY_NUMERIC(uint8_t, case_, 188u, TOK, TOK, tok, TOK)
ENUM_KEY_NUMERIC(uint8_t, default_, 189u, TOK, TOK, tok, TOK)
ENUM_KEY_NUMERIC(uint8_t, break_, 190u, TOK, TOK, tok, TOK)
ENUM_KEY_NUMERIC(uint8_t, continue_, 191u, TOK, TOK, tok, TOK)
ENUM_KEY_NUMERIC(uint8_t, with_, 192u, TOK, TOK, tok, TOK)
ENUM_KEY_NUMERIC(uint8_t, synchronized_, 193u, TOK, TOK, tok, TOK)
ENUM_KEY_NUMERIC(uint8_t, return_, 194u, TOK, TOK, tok, TOK)
ENUM_KEY_NUMERIC(uint8_t, goto_, 195u, TOK, TOK, tok, TOK)
ENUM_KEY_NUMERIC(uint8_t, try_, 196u, TOK, TOK, tok, TOK)
ENUM_KEY_NUMERIC(uint8_t, catch_, 197u, TOK, TOK, tok, TOK)
ENUM_KEY_NUMERIC(uint8_t, finally_, 198u, TOK, TOK, tok, TOK)
ENUM_KEY_NUMERIC(uint8_t, asm_, 199u, TOK, TOK, tok, TOK)
ENUM_KEY_NUMERIC(uint8_t, foreach_, 200u, TOK, TOK, tok, TOK)
ENUM_KEY_NUMERIC(uint8_t, foreach_reverse_, 201u, TOK, TOK, tok, TOK)
ENUM_KEY_NUMERIC(uint8_t, scope_, 202u, TOK, TOK, tok, TOK)
ENUM_KEY_NUMERIC(uint8_t, onScopeExit, 203u, TOK, TOK, tok, TOK)
ENUM_KEY_NUMERIC(uint8_t, onScopeFailure, 204u, TOK, TOK, tok, TOK)
ENUM_KEY_NUMERIC(uint8_t, onScopeSuccess, 205u, TOK, TOK, tok, TOK)
ENUM_KEY_NUMERIC(uint8_t, invariant_, 206u, TOK, TOK, tok, TOK)
ENUM_KEY_NUMERIC(uint8_t, unittest_, 207u, TOK, TOK, tok, TOK)
ENUM_KEY_NUMERIC(uint8_t, argumentTypes, 208u, TOK, TOK, tok, TOK)
ENUM_KEY_NUMERIC(uint8_t, ref_, 209u, TOK, TOK, tok, TOK)
ENUM_KEY_NUMERIC(uint8_t, macro_, 210u, TOK, TOK, tok, TOK)
ENUM_KEY_NUMERIC(uint8_t, parameters, 211u, TOK, TOK, tok, TOK)
ENUM_KEY_NUMERIC(uint8_t, traits, 212u, TOK, TOK, tok, TOK)
ENUM_KEY_NUMERIC(uint8_t, overloadSet, 213u, TOK, TOK, tok, TOK)
ENUM_KEY_NUMERIC(uint8_t, pure_, 214u, TOK, TOK, tok, TOK)
ENUM_KEY_NUMERIC(uint8_t, nothrow_, 215u, TOK, TOK, tok, TOK)
ENUM_KEY_NUMERIC(uint8_t, gshared, 216u, TOK, TOK, tok, TOK)
ENUM_KEY_NUMERIC(uint8_t, line, 217u, TOK, TOK, tok, TOK)
ENUM_KEY_NUMERIC(uint8_t, file, 218u, TOK, TOK, tok, TOK)
ENUM_KEY_NUMERIC(uint8_t, fileFullPath, 219u, TOK, TOK, tok, TOK)
ENUM_KEY_NUMERIC(uint8_t, moduleString, 220u, TOK, TOK, tok, TOK)
ENUM_KEY_NUMERIC(uint8_t, functionString, 221u, TOK, TOK, tok, TOK)
ENUM_KEY_NUMERIC(uint8_t, prettyFunction, 222u, TOK, TOK, tok, TOK)
ENUM_KEY_NUMERIC(uint8_t, shared_, 223u, TOK, TOK, tok, TOK)
ENUM_KEY_NUMERIC(uint8_t, at, 224u, TOK, TOK, tok, TOK)
ENUM_KEY_NUMERIC(uint8_t, pow, 225u, TOK, TOK, tok, TOK)
ENUM_KEY_NUMERIC(uint8_t, powAssign, 226u, TOK, TOK, tok, TOK)
ENUM_KEY_NUMERIC(uint8_t, goesTo, 227u, TOK, TOK, tok, TOK)
ENUM_KEY_NUMERIC(uint8_t, vector, 228u, TOK, TOK, tok, TOK)
ENUM_KEY_NUMERIC(uint8_t, pound, 229u, TOK, TOK, tok, TOK)
ENUM_KEY_NUMERIC(uint8_t, interval, 230u, TOK, TOK, tok, TOK)
ENUM_KEY_NUMERIC(uint8_t, voidExpression, 231u, TOK, TOK, tok, TOK)
ENUM_KEY_NUMERIC(uint8_t, cantExpression, 232u, TOK, TOK, tok, TOK)
ENUM_KEY_NUMERIC(uint8_t, showCtfeContext, 233u, TOK, TOK, tok, TOK)
ENUM_KEY_NUMERIC(uint8_t, objcClassReference, 234u, TOK, TOK, tok, TOK)
ENUM_KEY_NUMERIC(uint8_t, vectorArray, 235u, TOK, TOK, tok, TOK)
ENUM_KEY_NUMERIC(uint8_t, max_, 236u, TOK, TOK, tok, TOK)
END_ENUM_NUMERIC(uint8_t, TOK, TOK, tok)

class StringExp;
class TupleExp;
BEGIN_ENUM(MATCH, MATCH, match)
ENUM_KEY(int32_t, nomatch, 0, MATCH, MATCH, match, MATCH)
ENUM_KEY(int32_t, convert, 1, MATCH, MATCH, match, MATCH)
ENUM_KEY(int32_t, constant, 2, MATCH, MATCH, match, MATCH)
ENUM_KEY(int32_t, exact, 3, MATCH, MATCH, match, MATCH)
END_ENUM(MATCH, MATCH, match)

BEGIN_ENUM(Modifiable, MODIFIABLE, modifiable)
ENUM_KEY(int32_t, no, 0, Modifiable, MODIFIABLE, modifiable, M)
ENUM_KEY(int32_t, yes, 1, Modifiable, MODIFIABLE, modifiable, M)
ENUM_KEY(int32_t, initialization, 2, Modifiable, MODIFIABLE, modifiable, M)
END_ENUM(Modifiable, MODIFIABLE, modifiable)

class IntegerExp;
class ErrorExp;
class VoidInitExp;
class RealExp;
class ComplexExp;
class IdentifierExp;
class DollarExp;
class DsymbolExp;
class ThisExp;
class SuperExp;
class NullExp;
class ArrayLiteralExp;
class AssocArrayLiteralExp;
class StructLiteralExp;
class TypeExp;
class ScopeExp;
class TemplateExp;
class NewExp;
class NewAnonClassExp;
class SymOffExp;
class VarExp;
class OverExp;
class FuncExp;
class DeclarationExp;
class TypeidExp;
class TraitsExp;
class HaltExp;
class IsExp;
class CompileExp;
class ImportExp;
class AssertExp;
class DotIdExp;
class DotTemplateExp;
class DotVarExp;
class DotTemplateInstanceExp;
class DelegateExp;
class DotTypeExp;
class CallExp;
class AddrExp;
class PtrExp;
class NegExp;
class UAddExp;
class ComExp;
class NotExp;
class DeleteExp;
class CastExp;
class VectorExp;
class VectorArrayExp;
class SliceExp;
class ArrayLengthExp;
class ArrayExp;
class DotExp;
class CommaExp;
class IntervalExp;
class DelegatePtrExp;
class DelegateFuncptrExp;
class IndexExp;
class PostExp;
class PreExp;
class AssignExp;
class ConstructExp;
class BlitExp;
class AddAssignExp;
class MinAssignExp;
class MulAssignExp;
class DivAssignExp;
class ModAssignExp;
class AndAssignExp;
class OrAssignExp;
class XorAssignExp;
class PowAssignExp;
class ShlAssignExp;
class ShrAssignExp;
class UshrAssignExp;
class CatAssignExp;
class CatElemAssignExp;
class CatDcharAssignExp;
class AddExp;
class MinExp;
class CatExp;
class MulExp;
class DivExp;
class ModExp;
class PowExp;
class ShlExp;
class ShrExp;
class UshrExp;
class AndExp;
class OrExp;
class XorExp;
class LogicalExp;
class InExp;
class RemoveExp;
class EqualExp;
class IdentityExp;
class CondExp;
class DefaultInitExp;
class FileInitExp;
class LineInitExp;
class ModuleInitExp;
class FuncInitExp;
class PrettyFuncInitExp;
class ClassReferenceExp;
class TypeInfoClassDeclaration;
struct ObjcClassDeclaration;
class TypeFunction;
struct IntRange;
class TypeInfoStructDeclaration;
class TypeInfoInterfaceDeclaration;
class TypeInfoPointerDeclaration;
class TypeInfoArrayDeclaration;
class TypeInfoStaticArrayDeclaration;
class TypeInfoAssociativeArrayDeclaration;
class TypeInfoEnumDeclaration;
class TypeInfoFunctionDeclaration;
class TypeInfoDelegateDeclaration;
class TypeInfoTupleDeclaration;
class TypeInfoConstDeclaration;
class TypeInfoInvariantDeclaration;
class TypeInfoSharedDeclaration;
class TypeInfoWildDeclaration;
class TypeInfoVectorDeclaration;
struct Macro;
struct OutBuffer;
struct ModuleDeclaration;
struct FileName;
struct FileBuffer;
struct MacroTable;
struct Escape;
struct ReadResult;
class WithStatement;
class Tuple;
struct TemplatePrevious;
class TemplateTupleParameter;
struct Mcache;
struct TYPE;
class TypeBasic;
class TypeError;
class TypeVector;
class TypeSArray;
class TypeDArray;
class TypeAArray;
class TypePointer;
class TypeReference;
class TypeDelegate;
class TypeIdentifier;
class TypeInstance;
class TypeTypeof;
class TypeReturn;
class TypeStruct;
class TypeEnum;
class TypeClass;
class TypeSlice;
class TypeNull;
class TypeMixin;
class TypeTraits;
class TemplateTypeParameter;
class TemplateValueParameter;
class TemplateAliasParameter;
class TemplateThisParameter;
class TypeQualified;
class StaticAssert;
class AlignDeclaration;
class CPPMangleDeclaration;
class PragmaDeclaration;
class ConditionalDeclaration;
class StaticForeachDeclaration;
class StaticIfDeclaration;
class ImportStatement;
class LabelStatement;
class StaticAssertStatement;
class CompileStatement;
class WhileStatement;
class ForStatement;
class DoStatement;
class IfStatement;
class ScopeGuardStatement;
class ConditionalStatement;
class StaticForeachStatement;
class PragmaStatement;
class SwitchStatement;
class CaseRangeStatement;
class DefaultStatement;
class BreakStatement;
class ContinueStatement;
class GotoDefaultStatement;
class SynchronizedStatement;
class TryCatchStatement;
class TryFinallyStatement;
class ThrowStatement;
class AsmStatement;
class ExpStatement;
class CompoundStatement;
class CompoundDeclarationStatement;
class CompoundAsmStatement;
class InlineAsmStatement;
class GccAsmStatement;
class TypeNext;
class TypeArray;
class UnaExp;
class BinExp;
class SymbolExp;
class CmpExp;
class BinAssignExp;
class StaticIfCondition;
class DVCondition;
class ExpInitializer;
class StructInitializer;
class ArrayInitializer;
class VoidInitializer;
class ErrorStatement;
class PeelStatement;
class UnrolledLoopStatement;
class SwitchErrorStatement;
class DebugStatement;
class DtorExpStatement;
class ForwardingStatement;
class ErrorInitializer;
class ObjcClassReferenceExp;
class ThrownExceptionExp;
struct ASTCodegen;
union __AnonStruct__u;
BEGIN_ENUM(PINLINE, PINLINE, pinline)
ENUM_KEY(int32_t, default_, 0, PINLINE, PINLINE, pinline, PINLINE)
ENUM_KEY(int32_t, never, 1, PINLINE, PINLINE, pinline, PINLINE)
ENUM_KEY(int32_t, always, 2, PINLINE, PINLINE, pinline, PINLINE)
END_ENUM(PINLINE, PINLINE, pinline)

struct ObjcFuncDeclaration;
struct ObjcSelector;
BEGIN_ENUM_NUMERIC(uint8_t, PURE, PURE, pure)
ENUM_KEY_NUMERIC(uint8_t, impure, 0u, PURE, PURE, pure, PURE)
ENUM_KEY_NUMERIC(uint8_t, fwdref, 1u, PURE, PURE, pure, PURE)
ENUM_KEY_NUMERIC(uint8_t, weak, 2u, PURE, PURE, pure, PURE)
ENUM_KEY_NUMERIC(uint8_t, const_, 3u, PURE, PURE, pure, PURE)
ENUM_KEY_NUMERIC(uint8_t, strong, 4u, PURE, PURE, pure, PURE)
END_ENUM_NUMERIC(uint8_t, PURE, PURE, pure)

struct ParameterList;
BEGIN_ENUM_NUMERIC(uint8_t, VarArg, VARARG, vararg)
ENUM_KEY_NUMERIC(uint8_t, none, 0u, VarArg, VARARG, vararg, VA)
ENUM_KEY_NUMERIC(uint8_t, variadic, 1u, VarArg, VARARG, vararg, VA)
ENUM_KEY_NUMERIC(uint8_t, typesafe, 2u, VarArg, VARARG, vararg, VA)
END_ENUM_NUMERIC(uint8_t, VarArg, VARARG, vararg)

BEGIN_ENUM_NUMERIC(uint32_t, JsonFieldFlags, JSONFIELDFLAGS, jsonfieldflags)
ENUM_KEY_NUMERIC(uint32_t, none, 0u, JsonFieldFlags, JSONFIELDFLAGS, jsonfieldflags, JFF)
ENUM_KEY_NUMERIC(uint32_t, compilerInfo, 1u, JsonFieldFlags, JSONFIELDFLAGS, jsonfieldflags, JFF)
ENUM_KEY_NUMERIC(uint32_t, buildInfo, 2u, JsonFieldFlags, JSONFIELDFLAGS, jsonfieldflags, JFF)
ENUM_KEY_NUMERIC(uint32_t, modules, 4u, JsonFieldFlags, JSONFIELDFLAGS, jsonfieldflags, JFF)
ENUM_KEY_NUMERIC(uint32_t, semantics, 8u, JsonFieldFlags, JSONFIELDFLAGS, jsonfieldflags, JFF)
END_ENUM_NUMERIC(uint32_t, JsonFieldFlags, JSONFIELDFLAGS, jsonfieldflags)

class Library;
struct _IO_FILE;
struct ObNode;
class StoppableVisitor;
struct Token;
struct code;
struct TargetC;
struct TargetCPP;
struct TargetObjC;
struct Param;
struct Target;
struct elem;
struct IRState;
struct block;
struct Outbuffer;
struct ElemResult;
struct dt_t;
struct DtBuilder;
struct LIST;
struct Config;
struct Srcpos;
struct Pstate;
struct blklst;
struct symtab_t;
struct Cstate;
struct _BS;
struct con_t;
struct cse_t;
struct immed_t;
struct token_t;
struct Thunk;
struct param_t;
struct baseclass_t;
struct mptr_t;
struct enum_t;
struct func_t;
struct struct_t;
struct template_t;
BEGIN_ENUM(EHmethod, EHMETHOD, ehmethod)
ENUM_KEY(int32_t, EH_NONE, 0, EHmethod, EHMETHOD, ehmethod, EH)
ENUM_KEY(int32_t, EH_SEH, 1, EHmethod, EHMETHOD, ehmethod, EH)
ENUM_KEY(int32_t, EH_WIN32, 2, EHmethod, EHMETHOD, ehmethod, EH)
ENUM_KEY(int32_t, EH_WIN64, 3, EHmethod, EHMETHOD, ehmethod, EH)
ENUM_KEY(int32_t, EH_DM, 4, EHmethod, EHMETHOD, ehmethod, EH)
ENUM_KEY(int32_t, EH_DWARF, 5, EHmethod, EHMETHOD, ehmethod, EH)
END_ENUM(EHmethod, EHMETHOD, ehmethod)

struct EEcontext;
struct Declar;
struct Cent;
struct Complex_f;
struct Complex_d;
struct Complex_ld;
struct Cgcv;
struct _Declaration;
struct _LabelDsymbol;
struct CodeBuilder;
struct REGSAVE;
struct LocalSection;
struct linnum_data;
struct LinOff;
struct seg_data;
struct FuncParamRegs;
union eve;
struct Configv;
class Obj;
struct NDP;
struct Globals87;
struct PTRNTAB0;
struct PTRNTAB1;
struct PTRNTAB2;
struct PTRNTAB3;
struct PTRNTAB4;
union PTRNTAB;
struct Global;
struct Mem;
class Object;
class TypeInfo_Class;
class TypeInfo;

class RootObject
{
public:
RootObject();
virtual bool equals(const RootObject* const o) const;
virtual const char* toChars() const;
virtual DYNCAST dyncast() const;
};

class ASTNode : public RootObject
{
public:
virtual void accept(Visitor* v) = 0;
ASTNode();
};

struct Loc
{
const char* filename;
uint32_t linnum;
uint32_t charnum;
const char* toChars(bool showColumns, uint8_t messageStyle) const;
bool equals(const Loc& loc) const;
Loc() : filename(), linnum(), charnum() {}
};

class Dsymbol : public ASTNode
{
public:
Identifier* ident;
Dsymbol* parent;
CPPNamespaceDeclaration* cppnamespace;
Symbol* csym;
Symbol* isym;
char* comment;
Loc loc;
Scope* _scope;
char* prettystring;
bool errors;
PASS semanticRun;
DeprecatedDeclaration* depdecl;
UserAttributeDeclaration* userAttribDecl;
UnitTestDeclaration* ddocUnittest;
static Dsymbol* create(Identifier* ident);
const char* toChars() const;
virtual const char* toPrettyCharsHelper();
const Loc getLoc();
const char* locToChars();
bool equals(const RootObject* const o) const;
bool isAnonymous() const;
void error(const Loc& loc, const char* format, ...);
void error(const char* format, ...);
void deprecation(const Loc& loc, const char* format, ...);
void deprecation(const char* format, ...);
bool checkDeprecated(const Loc& loc, Scope* sc);
Module* getModule();
Module* getAccessModule();
Dsymbol* pastMixin();
Dsymbol* toParent();
Dsymbol* toParent2();
Dsymbol* toParentDecl();
Dsymbol* toParentLocal();
Dsymbol* toParentDeclImpl(bool localOnly);
Dsymbol* toParentP(Dsymbol* p1, Dsymbol* p2);
TemplateInstance* isInstantiated();
bool followInstantiationContext(Dsymbol* p1, Dsymbol* p2);
TemplateInstance* isSpeculative();
Ungag ungagSpeculative() const;
DYNCAST dyncast() const;
virtual Identifier* getIdent();
virtual const char* toPrettyChars(bool QualifyTypes = false);
virtual const char* kind() const;
virtual Dsymbol* toAlias();
virtual Dsymbol* toAlias2();
virtual void addMember(Scope* sc, ScopeDsymbol* sds);
virtual void setScope(Scope* sc);
virtual void importAll(Scope* sc);
virtual Dsymbol* search(const Loc& loc, Identifier* ident, int32_t flags = 0);
virtual bool overloadInsert(Dsymbol* s);
virtual d_uns64 size(const Loc& loc);
virtual bool isforwardRef();
virtual AggregateDeclaration* isThis();
virtual bool isExport() const;
virtual bool isImportedSymbol() const;
virtual bool isDeprecated() const;
virtual bool isOverloadable() const;
virtual LabelDsymbol* isLabel();
AggregateDeclaration* isMember();
AggregateDeclaration* isMember2();
AggregateDeclaration* isMemberDecl();
AggregateDeclaration* isMemberLocal();
ClassDeclaration* isClassMember();
virtual Type* getType();
virtual bool needThis();
virtual Prot prot();
virtual Dsymbol* syntaxCopy(Dsymbol* s);
virtual bool oneMember(Dsymbol** ps, Identifier* ident);
virtual void setFieldOffset(AggregateDeclaration* ad, uint32_t* poffset, bool isunion);
virtual bool hasPointers();
virtual bool hasStaticCtorOrDtor();
virtual void addLocalClass(Array<ClassDeclaration*>* _param_0);
virtual void addObjcSymbols(Array<ClassDeclaration*>* classes, Array<ClassDeclaration*>* categories);
virtual void checkCtorConstInit();
virtual void addComment(const char* comment);
bool inNonRoot();
void accept(Visitor* v);
virtual Package* isPackage();
virtual Module* isModule();
virtual EnumMember* isEnumMember();
virtual TemplateDeclaration* isTemplateDeclaration();
virtual TemplateInstance* isTemplateInstance();
virtual TemplateMixin* isTemplateMixin();
virtual ForwardingAttribDeclaration* isForwardingAttribDeclaration();
virtual Nspace* isNspace();
virtual Declaration* isDeclaration();
virtual StorageClassDeclaration* isStorageClassDeclaration();
virtual ExpressionDsymbol* isExpressionDsymbol();
virtual ThisDeclaration* isThisDeclaration();
virtual TypeInfoDeclaration* isTypeInfoDeclaration();
virtual TupleDeclaration* isTupleDeclaration();
virtual AliasDeclaration* isAliasDeclaration();
virtual AggregateDeclaration* isAggregateDeclaration();
virtual FuncDeclaration* isFuncDeclaration();
virtual FuncAliasDeclaration* isFuncAliasDeclaration();
virtual OverDeclaration* isOverDeclaration();
virtual FuncLiteralDeclaration* isFuncLiteralDeclaration();
virtual CtorDeclaration* isCtorDeclaration();
virtual PostBlitDeclaration* isPostBlitDeclaration();
virtual DtorDeclaration* isDtorDeclaration();
virtual StaticCtorDeclaration* isStaticCtorDeclaration();
virtual StaticDtorDeclaration* isStaticDtorDeclaration();
virtual SharedStaticCtorDeclaration* isSharedStaticCtorDeclaration();
virtual SharedStaticDtorDeclaration* isSharedStaticDtorDeclaration();
virtual InvariantDeclaration* isInvariantDeclaration();
virtual UnitTestDeclaration* isUnitTestDeclaration();
virtual NewDeclaration* isNewDeclaration();
virtual VarDeclaration* isVarDeclaration();
virtual VersionSymbol* isVersionSymbol();
virtual DebugSymbol* isDebugSymbol();
virtual ClassDeclaration* isClassDeclaration();
virtual StructDeclaration* isStructDeclaration();
virtual UnionDeclaration* isUnionDeclaration();
virtual InterfaceDeclaration* isInterfaceDeclaration();
virtual ScopeDsymbol* isScopeDsymbol();
virtual ForwardingScopeDsymbol* isForwardingScopeDsymbol();
virtual WithScopeSymbol* isWithScopeSymbol();
virtual ArrayScopeSymbol* isArrayScopeSymbol();
virtual Import* isImport();
virtual EnumDeclaration* isEnumDeclaration();
virtual SymbolDeclaration* isSymbolDeclaration();
virtual AttribDeclaration* isAttribDeclaration();
virtual AnonDeclaration* isAnonDeclaration();
virtual CPPNamespaceDeclaration* isCPPNamespaceDeclaration();
virtual ProtDeclaration* isProtDeclaration();
virtual OverloadSet* isOverloadSet();
virtual CompileDeclaration* isCompileDeclaration();
};

struct BitArray
{
typedef uint64_t Chunk_t;
ENUM_CONSTANT_NUMERIC(uint64_t, ChunkSize, 8LLU)

ENUM_CONSTANT_NUMERIC(uint64_t, BitsPerChunk, 64LLU)

size_t len;
uint64_t* ptr;
BitArray() {}
};

class ScopeDsymbol : public Dsymbol
{
public:
Array<Dsymbol*>* members;
DsymbolTable* symtab;
uint32_t endlinnum;
Array<Dsymbol*>* importedScopes;
Kind* prots;
BitArray accessiblePackages;
BitArray privateAccessiblePackages;
Dsymbol* syntaxCopy(Dsymbol* s);
Dsymbol* search(const Loc& loc, Identifier* ident, int32_t flags = 8);
virtual void importScope(Dsymbol* s, Prot protection);
virtual bool isPackageAccessible(Package* p, Prot protection, int32_t flags = 0);
bool isforwardRef();
static void multiplyDefined(const Loc& loc, Dsymbol* s1, Dsymbol* s2);
const char* kind() const;
FuncDeclaration* findGetMembers();
virtual Dsymbol* symtabInsert(Dsymbol* s);
virtual Dsymbol* symtabLookup(Dsymbol* s, Identifier* id);
bool hasStaticCtorOrDtor();
ScopeDsymbol* isScopeDsymbol();
void accept(Visitor* v);
~ScopeDsymbol();
};

struct Prot
{
Kind kind;
Package* pkg;
bool isMoreRestrictiveThan(const Prot other) const;
bool opEquals(const Prot& other) const;
bool isSubsetOf(const Prot& parent) const;
Prot() : pkg() {}
};

class Expression : public ASTNode
{
public:
TOK op;
uint8_t size;
uint8_t parens;
Type* type;
Loc loc;
static void _init();
static void deinitialize();
Expression* copy();
virtual Expression* syntaxCopy();
DYNCAST dyncast() const;
const char* toChars() const;
void error(const char* format, ...) const;
void errorSupplemental(const char* format, ...);
void warning(const char* format, ...) const;
void deprecation(const char* format, ...) const;
virtual dinteger_t toInteger();
virtual uinteger_t toUInteger();
virtual _d_real toReal();
virtual _d_real toImaginary();
virtual complex_t toComplex();
virtual StringExp* toStringExp();
virtual TupleExp* toTupleExp();
virtual bool isLvalue();
virtual Expression* toLvalue(Scope* sc, Expression* e);
virtual Expression* modifiableLvalue(Scope* sc, Expression* e);
Expression* implicitCastTo(Scope* sc, Type* t);
MATCH implicitConvTo(Type* t);
Expression* castTo(Scope* sc, Type* t);
virtual Expression* resolveLoc(const Loc& loc, Scope* sc);
virtual bool checkType();
virtual bool checkValue();
bool checkDeprecated(Scope* sc, Dsymbol* s);
static bool checkImpure(Scope* sc);
virtual Modifiable checkModifiable(Scope* sc, int32_t flag = 0);
virtual Expression* toBoolean(Scope* sc);
virtual Expression* addDtorHook(Scope* sc);
Expression* addressOf();
Expression* deref();
Expression* optimize(int32_t result, bool keepLvalue = false);
Expression* ctfeInterpret();
int32_t isConst();
virtual bool isBool(bool result);
virtual bool hasCode();
IntegerExp* isIntegerExp();
ErrorExp* isErrorExp();
VoidInitExp* isVoidInitExp();
RealExp* isRealExp();
ComplexExp* isComplexExp();
IdentifierExp* isIdentifierExp();
DollarExp* isDollarExp();
DsymbolExp* isDsymbolExp();
ThisExp* isThisExp();
SuperExp* isSuperExp();
NullExp* isNullExp();
StringExp* isStringExp();
TupleExp* isTupleExp();
ArrayLiteralExp* isArrayLiteralExp();
AssocArrayLiteralExp* isAssocArrayLiteralExp();
StructLiteralExp* isStructLiteralExp();
TypeExp* isTypeExp();
ScopeExp* isScopeExp();
TemplateExp* isTemplateExp();
NewExp* isNewExp();
NewAnonClassExp* isNewAnonClassExp();
SymOffExp* isSymOffExp();
VarExp* isVarExp();
OverExp* isOverExp();
FuncExp* isFuncExp();
DeclarationExp* isDeclarationExp();
TypeidExp* isTypeidExp();
TraitsExp* isTraitsExp();
HaltExp* isHaltExp();
IsExp* isExp();
CompileExp* isCompileExp();
ImportExp* isImportExp();
AssertExp* isAssertExp();
DotIdExp* isDotIdExp();
DotTemplateExp* isDotTemplateExp();
DotVarExp* isDotVarExp();
DotTemplateInstanceExp* isDotTemplateInstanceExp();
DelegateExp* isDelegateExp();
DotTypeExp* isDotTypeExp();
CallExp* isCallExp();
AddrExp* isAddrExp();
PtrExp* isPtrExp();
NegExp* isNegExp();
UAddExp* isUAddExp();
ComExp* isComExp();
NotExp* isNotExp();
DeleteExp* isDeleteExp();
CastExp* isCastExp();
VectorExp* isVectorExp();
VectorArrayExp* isVectorArrayExp();
SliceExp* isSliceExp();
ArrayLengthExp* isArrayLengthExp();
ArrayExp* isArrayExp();
DotExp* isDotExp();
CommaExp* isCommaExp();
IntervalExp* isIntervalExp();
DelegatePtrExp* isDelegatePtrExp();
DelegateFuncptrExp* isDelegateFuncptrExp();
IndexExp* isIndexExp();
PostExp* isPostExp();
PreExp* isPreExp();
AssignExp* isAssignExp();
ConstructExp* isConstructExp();
BlitExp* isBlitExp();
AddAssignExp* isAddAssignExp();
MinAssignExp* isMinAssignExp();
MulAssignExp* isMulAssignExp();
DivAssignExp* isDivAssignExp();
ModAssignExp* isModAssignExp();
AndAssignExp* isAndAssignExp();
OrAssignExp* isOrAssignExp();
XorAssignExp* isXorAssignExp();
PowAssignExp* isPowAssignExp();
ShlAssignExp* isShlAssignExp();
ShrAssignExp* isShrAssignExp();
UshrAssignExp* isUshrAssignExp();
CatAssignExp* isCatAssignExp();
CatElemAssignExp* isCatElemAssignExp();
CatDcharAssignExp* isCatDcharAssignExp();
AddExp* isAddExp();
MinExp* isMinExp();
CatExp* isCatExp();
MulExp* isMulExp();
DivExp* isDivExp();
ModExp* isModExp();
PowExp* isPowExp();
ShlExp* isShlExp();
ShrExp* isShrExp();
UshrExp* isUshrExp();
AndExp* isAndExp();
OrExp* isOrExp();
XorExp* isXorExp();
LogicalExp* isLogicalExp();
InExp* isInExp();
RemoveExp* isRemoveExp();
EqualExp* isEqualExp();
IdentityExp* isIdentityExp();
CondExp* isCondExp();
DefaultInitExp* isDefaultInitExp();
FileInitExp* isFileInitExp();
LineInitExp* isLineInitExp();
ModuleInitExp* isModuleInitExp();
FuncInitExp* isFuncInitExp();
PrettyFuncInitExp* isPrettyFuncInitExp();
ClassReferenceExp* isClassReferenceExp();
void accept(Visitor* v);
};

struct ObjcClassDeclaration
{
bool isMeta;
bool isExtern;
Identifier* identifier;
ClassDeclaration* classDeclaration;
ClassDeclaration* metaclass;
Array<FuncDeclaration*>* methodList;
bool isRootClass() const;
ObjcClassDeclaration() : isMeta(false), isExtern(false), identifier(), classDeclaration(), metaclass(), methodList() {}
};

struct FileName
{
DArray< const char > str;
static bool equals(const char* name1, const char* name2);
static bool absolute(const char* name);
static const char* toAbsolute(const char* name, const char* base);
static const char* ext(const char* str);
const char* ext() const;
static const char* removeExt(const char* str);
static const char* name(const char* str);
const char* name() const;
static const char* path(const char* str);
static const char* combine(const char* path, const char* name);
static Array<const char*>* splitPath(const char* path);
static const char* defaultExt(const char* name, const char* ext);
static const char* forceExt(const char* name, const char* ext);
static bool equalsExt(const char* name, const char* ext);
bool equalsExt(const char* ext) const;
static const char* searchPath(Array<const char*>* path, const char* name, bool cwd);
static const char* safeSearchPath(Array<const char*>* path, const char* name);
static int32_t exists(const char* name);
static bool ensurePathExists(const char* path);
static const char* canonicalName(const char* name);
static void free(const char* str);
const char* toChars() const;
FileName() {}
};

class Type : public ASTNode
{
public:
uint8_t ty;
uint8_t mod;
char* deco;
struct Mcache
{
Type* cto;
Type* ito;
Type* sto;
Type* scto;
Type* wto;
Type* wcto;
Type* swto;
Type* swcto;
Mcache() : cto(), ito(), sto(), scto(), wto(), wcto(), swto(), swcto() {}
};

Mcache* mcache;
Type* pto;
Type* rto;
Type* arrayof;
TypeInfoDeclaration* vtinfo;
TYPE* ctype;
static Type* tvoid;
static Type* tint8;
static Type* tuns8;
static Type* tint16;
static Type* tuns16;
static Type* tint32;
static Type* tuns32;
static Type* tint64;
static Type* tuns64;
static Type* tint128;
static Type* tuns128;
static Type* tfloat32;
static Type* tfloat64;
static Type* tfloat80;
static Type* timaginary32;
static Type* timaginary64;
static Type* timaginary80;
static Type* tcomplex32;
static Type* tcomplex64;
static Type* tcomplex80;
static Type* tbool;
static Type* tchar;
static Type* twchar;
static Type* tdchar;
static Type* tshiftcnt;
static Type* tvoidptr;
static Type* tstring;
static Type* twstring;
static Type* tdstring;
static Type* terror;
static Type* tnull;
static Type* tsize_t;
static Type* tptrdiff_t;
static Type* thash_t;
static ClassDeclaration* dtypeinfo;
static ClassDeclaration* typeinfoclass;
static ClassDeclaration* typeinfointerface;
static ClassDeclaration* typeinfostruct;
static ClassDeclaration* typeinfopointer;
static ClassDeclaration* typeinfoarray;
static ClassDeclaration* typeinfostaticarray;
static ClassDeclaration* typeinfoassociativearray;
static ClassDeclaration* typeinfovector;
static ClassDeclaration* typeinfoenum;
static ClassDeclaration* typeinfofunction;
static ClassDeclaration* typeinfodelegate;
static ClassDeclaration* typeinfotypelist;
static ClassDeclaration* typeinfoconst;
static ClassDeclaration* typeinfoinvariant;
static ClassDeclaration* typeinfoshared;
static ClassDeclaration* typeinfowild;
static TemplateDeclaration* rtinfo;
static Type* basic[46LLU];
virtual const char* kind() const;
Type* copy() const;
virtual Type* syntaxCopy();
bool equals(const RootObject* const o) const;
bool equivalent(Type* t);
DYNCAST dyncast() const;
int32_t covariant(Type* t, uint64_t* pstc);
const char* toChars() const;
char* toPrettyChars(bool QualifyTypes = false);
static void _init();
static void deinitialize();
d_uns64 size();
virtual d_uns64 size(const Loc& loc);
virtual uint32_t alignsize();
Type* trySemantic(const Loc& loc, Scope* sc);
Type* merge2();
void modToBuffer(OutBuffer* buf) const;
char* modToChars() const;
virtual bool isintegral();
virtual bool isfloating();
virtual bool isreal();
virtual bool isimaginary();
virtual bool iscomplex();
virtual bool isscalar();
virtual bool isunsigned();
virtual bool isscope();
virtual bool isString();
virtual bool isAssignable();
virtual bool isBoolean();
virtual void checkDeprecated(const Loc& loc, Scope* sc);
bool isConst() const;
bool isImmutable() const;
bool isMutable() const;
bool isShared() const;
bool isSharedConst() const;
bool isWild() const;
bool isWildConst() const;
bool isSharedWild() const;
bool isNaked() const;
Type* nullAttributes() const;
Type* constOf();
Type* immutableOf();
Type* mutableOf();
Type* sharedOf();
Type* sharedConstOf();
Type* unSharedOf();
Type* wildOf();
Type* wildConstOf();
Type* sharedWildOf();
Type* sharedWildConstOf();
void fixTo(Type* t);
void check();
Type* addSTC(StorageClass stc);
Type* castMod(uint8_t mod);
Type* addMod(uint8_t mod);
virtual Type* addStorageClass(StorageClass stc);
Type* pointerTo();
Type* referenceTo();
Type* arrayOf();
Type* sarrayOf(dinteger_t dim);
bool hasDeprecatedAliasThis();
Type* aliasthisOf();
virtual Type* makeConst();
virtual Type* makeImmutable();
virtual Type* makeShared();
virtual Type* makeSharedConst();
virtual Type* makeWild();
virtual Type* makeWildConst();
virtual Type* makeSharedWild();
virtual Type* makeSharedWildConst();
virtual Type* makeMutable();
virtual Dsymbol* toDsymbol(Scope* sc);
Type* toBasetype();
virtual bool isBaseOf(Type* t, int32_t* poffset);
virtual MATCH implicitConvTo(Type* to);
virtual MATCH constConv(Type* to);
virtual uint8_t deduceWild(Type* t, bool isRef);
virtual Type* substWildTo(uint32_t mod);
Type* unqualify(uint32_t m);
virtual Type* toHeadMutable();
virtual ClassDeclaration* isClassHandle();
virtual uint32_t alignment();
virtual Expression* defaultInitLiteral(const Loc& loc);
virtual bool isZeroInit(const Loc& loc);
Identifier* getTypeInfoIdent();
virtual int32_t hasWild() const;
virtual bool hasPointers();
virtual bool hasVoidInitPointers();
virtual Type* nextOf();
Type* baseElemOf();
uint32_t numberOfElems(const Loc& loc);
uinteger_t sizemask();
virtual bool needsDestruction();
virtual bool needsCopyOrPostblit();
virtual bool needsNested();
virtual TypeBasic* isTypeBasic();
TypeError* isTypeError();
TypeVector* isTypeVector();
TypeSArray* isTypeSArray();
TypeDArray* isTypeDArray();
TypeAArray* isTypeAArray();
TypePointer* isTypePointer();
TypeReference* isTypeReference();
TypeFunction* isTypeFunction();
TypeDelegate* isTypeDelegate();
TypeIdentifier* isTypeIdentifier();
TypeInstance* isTypeInstance();
TypeTypeof* isTypeTypeof();
TypeReturn* isTypeReturn();
TypeStruct* isTypeStruct();
TypeEnum* isTypeEnum();
TypeClass* isTypeClass();
TypeTuple* isTypeTuple();
TypeSlice* isTypeSlice();
TypeNull* isTypeNull();
TypeMixin* isTypeMixin();
TypeTraits* isTypeTraits();
void accept(Visitor* v);
TypeFunction* toTypeFunction();
};

class ParseTimeVisitor
{
public:
virtual void visit(Dsymbol* _param_0);
virtual void visit(Parameter* _param_0);
virtual void visit(Statement* _param_0);
virtual void visit(Type* _param_0);
virtual void visit(Expression* _param_0);
virtual void visit(TemplateParameter* _param_0);
virtual void visit(Condition* _param_0);
virtual void visit(Initializer* _param_0);
virtual void visit(AliasThis* s);
virtual void visit(Declaration* s);
virtual void visit(ScopeDsymbol* s);
virtual void visit(Import* s);
virtual void visit(AttribDeclaration* s);
virtual void visit(StaticAssert* s);
virtual void visit(DebugSymbol* s);
virtual void visit(VersionSymbol* s);
virtual void visit(Package* s);
virtual void visit(EnumDeclaration* s);
virtual void visit(AggregateDeclaration* s);
virtual void visit(TemplateDeclaration* s);
virtual void visit(TemplateInstance* s);
virtual void visit(Nspace* s);
virtual void visit(VarDeclaration* s);
virtual void visit(FuncDeclaration* s);
virtual void visit(AliasDeclaration* s);
virtual void visit(TupleDeclaration* s);
virtual void visit(FuncLiteralDeclaration* s);
virtual void visit(PostBlitDeclaration* s);
virtual void visit(CtorDeclaration* s);
virtual void visit(DtorDeclaration* s);
virtual void visit(InvariantDeclaration* s);
virtual void visit(UnitTestDeclaration* s);
virtual void visit(NewDeclaration* s);
virtual void visit(StaticCtorDeclaration* s);
virtual void visit(StaticDtorDeclaration* s);
virtual void visit(SharedStaticCtorDeclaration* s);
virtual void visit(SharedStaticDtorDeclaration* s);
virtual void visit(CompileDeclaration* s);
virtual void visit(UserAttributeDeclaration* s);
virtual void visit(LinkDeclaration* s);
virtual void visit(AnonDeclaration* s);
virtual void visit(AlignDeclaration* s);
virtual void visit(CPPMangleDeclaration* s);
virtual void visit(CPPNamespaceDeclaration* s);
virtual void visit(ProtDeclaration* s);
virtual void visit(PragmaDeclaration* s);
virtual void visit(StorageClassDeclaration* s);
virtual void visit(ConditionalDeclaration* s);
virtual void visit(StaticForeachDeclaration* s);
virtual void visit(DeprecatedDeclaration* s);
virtual void visit(StaticIfDeclaration* s);
virtual void visit(EnumMember* s);
virtual void visit(Module* s);
virtual void visit(StructDeclaration* s);
virtual void visit(UnionDeclaration* s);
virtual void visit(ClassDeclaration* s);
virtual void visit(InterfaceDeclaration* s);
virtual void visit(TemplateMixin* s);
virtual void visit(ImportStatement* s);
virtual void visit(ScopeStatement* s);
virtual void visit(ReturnStatement* s);
virtual void visit(LabelStatement* s);
virtual void visit(StaticAssertStatement* s);
virtual void visit(CompileStatement* s);
virtual void visit(WhileStatement* s);
virtual void visit(ForStatement* s);
virtual void visit(DoStatement* s);
virtual void visit(ForeachRangeStatement* s);
virtual void visit(ForeachStatement* s);
virtual void visit(IfStatement* s);
virtual void visit(ScopeGuardStatement* s);
virtual void visit(ConditionalStatement* s);
virtual void visit(StaticForeachStatement* s);
virtual void visit(PragmaStatement* s);
virtual void visit(SwitchStatement* s);
virtual void visit(CaseRangeStatement* s);
virtual void visit(CaseStatement* s);
virtual void visit(DefaultStatement* s);
virtual void visit(BreakStatement* s);
virtual void visit(ContinueStatement* s);
virtual void visit(GotoDefaultStatement* s);
virtual void visit(GotoCaseStatement* s);
virtual void visit(GotoStatement* s);
virtual void visit(SynchronizedStatement* s);
virtual void visit(WithStatement* s);
virtual void visit(TryCatchStatement* s);
virtual void visit(TryFinallyStatement* s);
virtual void visit(ThrowStatement* s);
virtual void visit(AsmStatement* s);
virtual void visit(ExpStatement* s);
virtual void visit(CompoundStatement* s);
virtual void visit(CompoundDeclarationStatement* s);
virtual void visit(CompoundAsmStatement* s);
virtual void visit(InlineAsmStatement* s);
virtual void visit(GccAsmStatement* s);
virtual void visit(TypeBasic* t);
virtual void visit(TypeError* t);
virtual void visit(TypeNull* t);
virtual void visit(TypeVector* t);
virtual void visit(TypeEnum* t);
virtual void visit(TypeTuple* t);
virtual void visit(TypeClass* t);
virtual void visit(TypeStruct* t);
virtual void visit(TypeNext* t);
virtual void visit(TypeQualified* t);
virtual void visit(TypeTraits* t);
virtual void visit(TypeMixin* t);
virtual void visit(TypeReference* t);
virtual void visit(TypeSlice* t);
virtual void visit(TypeDelegate* t);
virtual void visit(TypePointer* t);
virtual void visit(TypeFunction* t);
virtual void visit(TypeArray* t);
virtual void visit(TypeDArray* t);
virtual void visit(TypeAArray* t);
virtual void visit(TypeSArray* t);
virtual void visit(TypeIdentifier* t);
virtual void visit(TypeReturn* t);
virtual void visit(TypeTypeof* t);
virtual void visit(TypeInstance* t);
virtual void visit(DeclarationExp* e);
virtual void visit(IntegerExp* e);
virtual void visit(NewAnonClassExp* e);
virtual void visit(IsExp* e);
virtual void visit(RealExp* e);
virtual void visit(NullExp* e);
virtual void visit(TypeidExp* e);
virtual void visit(TraitsExp* e);
virtual void visit(StringExp* e);
virtual void visit(NewExp* e);
virtual void visit(AssocArrayLiteralExp* e);
virtual void visit(ArrayLiteralExp* e);
virtual void visit(CompileExp* e);
virtual void visit(FuncExp* e);
virtual void visit(IntervalExp* e);
virtual void visit(TypeExp* e);
virtual void visit(ScopeExp* e);
virtual void visit(IdentifierExp* e);
virtual void visit(UnaExp* e);
virtual void visit(DefaultInitExp* e);
virtual void visit(BinExp* e);
virtual void visit(DsymbolExp* e);
virtual void visit(TemplateExp* e);
virtual void visit(SymbolExp* e);
virtual void visit(TupleExp* e);
virtual void visit(ThisExp* e);
virtual void visit(VarExp* e);
virtual void visit(DollarExp* e);
virtual void visit(SuperExp* e);
virtual void visit(AddrExp* e);
virtual void visit(PreExp* e);
virtual void visit(PtrExp* e);
virtual void visit(NegExp* e);
virtual void visit(UAddExp* e);
virtual void visit(NotExp* e);
virtual void visit(ComExp* e);
virtual void visit(DeleteExp* e);
virtual void visit(CastExp* e);
virtual void visit(CallExp* e);
virtual void visit(DotIdExp* e);
virtual void visit(AssertExp* e);
virtual void visit(ImportExp* e);
virtual void visit(DotTemplateInstanceExp* e);
virtual void visit(ArrayExp* e);
virtual void visit(FuncInitExp* e);
virtual void visit(PrettyFuncInitExp* e);
virtual void visit(FileInitExp* e);
virtual void visit(LineInitExp* e);
virtual void visit(ModuleInitExp* e);
virtual void visit(CommaExp* e);
virtual void visit(PostExp* e);
virtual void visit(PowExp* e);
virtual void visit(MulExp* e);
virtual void visit(DivExp* e);
virtual void visit(ModExp* e);
virtual void visit(AddExp* e);
virtual void visit(MinExp* e);
virtual void visit(CatExp* e);
virtual void visit(ShlExp* e);
virtual void visit(ShrExp* e);
virtual void visit(UshrExp* e);
virtual void visit(EqualExp* e);
virtual void visit(InExp* e);
virtual void visit(IdentityExp* e);
virtual void visit(CmpExp* e);
virtual void visit(AndExp* e);
virtual void visit(XorExp* e);
virtual void visit(OrExp* e);
virtual void visit(LogicalExp* e);
virtual void visit(CondExp* e);
virtual void visit(AssignExp* e);
virtual void visit(BinAssignExp* e);
virtual void visit(AddAssignExp* e);
virtual void visit(MinAssignExp* e);
virtual void visit(MulAssignExp* e);
virtual void visit(DivAssignExp* e);
virtual void visit(ModAssignExp* e);
virtual void visit(PowAssignExp* e);
virtual void visit(AndAssignExp* e);
virtual void visit(OrAssignExp* e);
virtual void visit(XorAssignExp* e);
virtual void visit(ShlAssignExp* e);
virtual void visit(ShrAssignExp* e);
virtual void visit(UshrAssignExp* e);
virtual void visit(CatAssignExp* e);
virtual void visit(TemplateAliasParameter* tp);
virtual void visit(TemplateTypeParameter* tp);
virtual void visit(TemplateTupleParameter* tp);
virtual void visit(TemplateValueParameter* tp);
virtual void visit(TemplateThisParameter* tp);
virtual void visit(StaticIfCondition* c);
virtual void visit(DVCondition* c);
virtual void visit(DebugCondition* c);
virtual void visit(VersionCondition* c);
virtual void visit(ExpInitializer* i);
virtual void visit(StructInitializer* i);
virtual void visit(ArrayInitializer* i);
virtual void visit(VoidInitializer* i);
};

class Visitor : public ParseTimeVisitor
{
public:
virtual void visit(ErrorStatement* s);
virtual void visit(PeelStatement* s);
virtual void visit(UnrolledLoopStatement* s);
virtual void visit(SwitchErrorStatement* s);
virtual void visit(DebugStatement* s);
virtual void visit(DtorExpStatement* s);
virtual void visit(ForwardingStatement* s);
virtual void visit(OverloadSet* s);
virtual void visit(LabelDsymbol* s);
virtual void visit(WithScopeSymbol* s);
virtual void visit(ArrayScopeSymbol* s);
virtual void visit(OverDeclaration* s);
virtual void visit(SymbolDeclaration* s);
virtual void visit(ForwardingAttribDeclaration* s);
virtual void visit(ThisDeclaration* s);
virtual void visit(TypeInfoDeclaration* s);
virtual void visit(TypeInfoStructDeclaration* s);
virtual void visit(TypeInfoClassDeclaration* s);
virtual void visit(TypeInfoInterfaceDeclaration* s);
virtual void visit(TypeInfoPointerDeclaration* s);
virtual void visit(TypeInfoArrayDeclaration* s);
virtual void visit(TypeInfoStaticArrayDeclaration* s);
virtual void visit(TypeInfoAssociativeArrayDeclaration* s);
virtual void visit(TypeInfoEnumDeclaration* s);
virtual void visit(TypeInfoFunctionDeclaration* s);
virtual void visit(TypeInfoDelegateDeclaration* s);
virtual void visit(TypeInfoTupleDeclaration* s);
virtual void visit(TypeInfoConstDeclaration* s);
virtual void visit(TypeInfoInvariantDeclaration* s);
virtual void visit(TypeInfoSharedDeclaration* s);
virtual void visit(TypeInfoWildDeclaration* s);
virtual void visit(TypeInfoVectorDeclaration* s);
virtual void visit(FuncAliasDeclaration* s);
virtual void visit(ErrorInitializer* i);
virtual void visit(ErrorExp* e);
virtual void visit(ComplexExp* e);
virtual void visit(StructLiteralExp* e);
virtual void visit(ObjcClassReferenceExp* e);
virtual void visit(SymOffExp* e);
virtual void visit(OverExp* e);
virtual void visit(HaltExp* e);
virtual void visit(DotTemplateExp* e);
virtual void visit(DotVarExp* e);
virtual void visit(DelegateExp* e);
virtual void visit(DotTypeExp* e);
virtual void visit(VectorExp* e);
virtual void visit(VectorArrayExp* e);
virtual void visit(SliceExp* e);
virtual void visit(ArrayLengthExp* e);
virtual void visit(DelegatePtrExp* e);
virtual void visit(DelegateFuncptrExp* e);
virtual void visit(DotExp* e);
virtual void visit(IndexExp* e);
virtual void visit(ConstructExp* e);
virtual void visit(BlitExp* e);
virtual void visit(RemoveExp* e);
virtual void visit(ClassReferenceExp* e);
virtual void visit(VoidInitExp* e);
virtual void visit(ThrownExceptionExp* e);
};

class SemanticTimePermissiveVisitor : public Visitor
{
public:
void visit(Dsymbol* _param_0);
void visit(Parameter* _param_0);
void visit(Statement* _param_0);
void visit(Type* _param_0);
void visit(Expression* _param_0);
void visit(TemplateParameter* _param_0);
void visit(Condition* _param_0);
void visit(Initializer* _param_0);
};

class StatementRewriteWalker : public SemanticTimePermissiveVisitor
{
public:
Statement** ps;
void visitStmt(Statement*& s);
void replaceCurrent(Statement* s);
void visit(PeelStatement* s);
void visit(CompoundStatement* s);
void visit(CompoundDeclarationStatement* s);
void visit(UnrolledLoopStatement* s);
void visit(ScopeStatement* s);
void visit(WhileStatement* s);
void visit(DoStatement* s);
void visit(ForStatement* s);
void visit(ForeachStatement* s);
void visit(ForeachRangeStatement* s);
void visit(IfStatement* s);
void visit(SwitchStatement* s);
void visit(CaseStatement* s);
void visit(CaseRangeStatement* s);
void visit(DefaultStatement* s);
void visit(SynchronizedStatement* s);
void visit(WithStatement* s);
void visit(TryCatchStatement* s);
void visit(TryFinallyStatement* s);
void visit(DebugStatement* s);
void visit(LabelStatement* s);
};

struct ObjcFuncDeclaration
{
ObjcSelector* selector;
VarDeclaration* selectorParameter;
ObjcFuncDeclaration() : selector(), selectorParameter() {}
};

struct ParameterList
{
Array<Parameter*>* parameters;
StorageClass stc;
VarArg varargs;
ParameterList(Array<Parameter*>* parameters, VarArg varargs = cast(VarArg)cast(ubyte)0u, StorageClass stc = 0);
size_t length();
Parameter* opIndex(size_t i);
ParameterList() : parameters(), stc(), varargs((VarArg)0u) {}
};

class StoppableVisitor : public Visitor
{
public:
bool stop;
};

struct TargetC
{
uint32_t longsize;
uint32_t long_doublesize;
uint32_t criticalSectionSize;
TargetC() : longsize(), long_doublesize(), criticalSectionSize() {}
};

struct TargetCPP
{
bool reverseOverloads;
bool exceptions;
bool twoDtorInVtable;
const char* toMangle(Dsymbol* s);
const char* typeInfoMangle(ClassDeclaration* cd);
const char* typeMangle(Type* t);
Type* parameterType(Parameter* p);
bool fundamentalType(const Type* const t, bool& isFundamental);
TargetCPP() : reverseOverloads(), exceptions(), twoDtorInVtable() {}
};

struct TargetObjC
{
bool supported;
TargetObjC() : supported() {}
};

struct cse_t
{
elem* value[29LLU];
uint32_t mval;
uint32_t mops;
cse_t() : mval(), mops() {}
};

struct immed_t
{
uint64_t value[29LLU];
uint32_t mval;
immed_t() : mval() {}
};

struct con_t
{
cse_t cse;
immed_t immed;
uint32_t mvar;
uint32_t mpvar;
uint32_t indexregs;
uint32_t used;
uint32_t params;
con_t() : cse(), immed(), mvar(), mpvar(), indexregs(), used(), params() {}
};

struct Complex_f
{
float re;
float im;
static Complex_f div(Complex_f& x, Complex_f& y);
static Complex_f mul(Complex_f& x, Complex_f& y);
static _d_real abs(Complex_f& z);
static Complex_f sqrtc(Complex_f& z);
Complex_f() {}
};

struct Complex_d
{
double re;
double im;
static Complex_d div(Complex_d& x, Complex_d& y);
static Complex_d mul(Complex_d& x, Complex_d& y);
static _d_real abs(Complex_d& z);
static Complex_d sqrtc(Complex_d& z);
Complex_d() {}
};

struct Complex_ld
{
_d_real re;
_d_real im;
static Complex_ld div(Complex_ld& x, Complex_ld& y);
static Complex_ld mul(Complex_ld& x, Complex_ld& y);
static _d_real abs(Complex_ld& z);
static Complex_ld sqrtc(Complex_ld& z);
Complex_ld() {}
};

BEGIN_ENUM(Sizeok, SIZEOK, sizeok)
    ENUM_KEY(int32_t, none, 0, Sizeok, SIZEOK, sizeok, S)
    ENUM_KEY(int32_t, fwd, 1, Sizeok, SIZEOK, sizeok, S)
    ENUM_KEY(int32_t, inProcess, 2, Sizeok, SIZEOK, sizeok, S)
    ENUM_KEY(int32_t, done, 3, Sizeok, SIZEOK, sizeok, S)
END_ENUM(Sizeok, SIZEOK, sizeok)

BEGIN_ENUM(Baseok, BASEOK, baseok)
    ENUM_KEY(int32_t, none, 0, Baseok, BASEOK, baseok, B)
    ENUM_KEY(int32_t, start, 1, Baseok, BASEOK, baseok, B)
    ENUM_KEY(int32_t, done, 2, Baseok, BASEOK, baseok, B)
    ENUM_KEY(int32_t, semanticdone, 3, Baseok, BASEOK, baseok, B)
END_ENUM(Baseok, BASEOK, baseok)

BEGIN_ENUM(ClassKind, CLASSKIND, classkind)
    ENUM_KEY(int32_t, d, 0, ClassKind, CLASSKIND, classkind, CK)
    ENUM_KEY(int32_t, cpp, 1, ClassKind, CLASSKIND, classkind, CK)
    ENUM_KEY(int32_t, objc, 2, ClassKind, CLASSKIND, classkind, CK)
END_ENUM(ClassKind, CLASSKIND, classkind)

class AggregateDeclaration : public ScopeDsymbol
{
public:
    Type* type;
    StorageClass storage_class;
    uint32_t structsize;
    uint32_t alignsize;
    Array<VarDeclaration*> fields;
    Dsymbol* deferred;
    ClassKind classKind;
    CPPMANGLE cppmangle;
    Dsymbol* enclosing;
    VarDeclaration* vthis;
    VarDeclaration* vthis2;
    Array<FuncDeclaration*> invs;
    FuncDeclaration* inv;
    NewDeclaration* aggNew;
    Dsymbol* ctor;
    CtorDeclaration* defaultCtor;
    AliasThis* aliasthis;
    Array<DtorDeclaration*> dtors;
    DtorDeclaration* dtor;
    DtorDeclaration* primaryDtor;
    DtorDeclaration* tidtor;
    FuncDeclaration* fieldDtor;
    Expression* getRTInfo;
    Prot protection;
    bool noDefaultCtor;
    Sizeok sizeok;
    virtual Scope* newScope(Scope* sc);
    void setScope(Scope* sc);
    bool determineFields();
    size_t nonHiddenFields();
    bool determineSize(Loc loc);
    virtual void finalizeSize() = 0;
    d_uns64 size(const Loc& loc);
    bool fill(Loc loc, Array<Expression*>* elements, bool ctorinit);
    Type* getType();
    bool isDeprecated() const;
    void setDeprecated();
    bool isNested() const;
    bool isExport() const;
    Dsymbol* searchCtor();
    Prot prot();
    Type* handleType();
    Symbol* stag;
    Symbol* sinit;
    AggregateDeclaration* isAggregateDeclaration();
    void accept(Visitor* v);
    ~AggregateDeclaration();
};

class AliasThis : public Dsymbol
{
public:
    Identifier* ident;
    Dsymbol* sym;
    bool isDeprecated_;
    Dsymbol* syntaxCopy(Dsymbol* s);
    const char* kind() const;
    AliasThis* isAliasThis();
    void accept(Visitor* v);
    bool isDeprecated() const;
};

extern TypeTuple* toArgTypes_x86(Type* t);

extern TypeTuple* toArgTypes_sysv_x64(Type* t);

extern TypeTuple* toArgTypes_aarch64(Type* t);

extern bool isHFVA(Type* t, int32_t maxNumElements = 4, Type** rewriteType);

typedef Array<const char*> Strings;

typedef Array<Identifier*> Identifiers;

typedef Array<TemplateParameter*> TemplateParameters;

typedef Array<Expression*> Expressions;

typedef Array<Statement*> Statements;

typedef Array<BaseClass*> BaseClasses;

typedef Array<ClassDeclaration*> ClassDeclarations;

typedef Array<Dsymbol*> Dsymbols;

typedef Array<RootObject*> Objects;

typedef Array<DtorDeclaration*> DtorDeclarations;

typedef Array<FuncDeclaration*> FuncDeclarations;

typedef Array<Parameter*> Parameters;

typedef Array<Initializer*> Initializers;

typedef Array<VarDeclaration*> VarDeclarations;

typedef Array<Type*> Types;

typedef Array<Catch*> Catches;

typedef Array<StaticDtorDeclaration*> StaticDtorDeclarations;

typedef Array<SharedStaticDtorDeclaration*> SharedStaticDtorDeclarations;

typedef Array<AliasDeclaration*> AliasDeclarations;

typedef Array<Module*> Modules;

typedef Array<CaseStatement*> CaseStatements;

typedef Array<ScopeStatement*> ScopeStatements;

typedef Array<GotoCaseStatement*> GotoCaseStatements;

typedef Array<ReturnStatement*> ReturnStatements;

typedef Array<GotoStatement*> GotoStatements;

typedef Array<TemplateInstance*> TemplateInstances;

typedef Array<Ensure> Ensures;

class AttribDeclaration : public Dsymbol
{
public:
    Array<Dsymbol*>* decl;
    virtual Array<Dsymbol*>* include(Scope* sc);
    virtual Scope* newScope(Scope* sc);
    void addMember(Scope* sc, ScopeDsymbol* sds);
    void setScope(Scope* sc);
    void importAll(Scope* sc);
    void addComment(const char* comment);
    const char* kind() const;
    bool oneMember(Dsymbol** ps, Identifier* ident);
    void setFieldOffset(AggregateDeclaration* ad, uint32_t* poffset, bool isunion);
    bool hasPointers();
    bool hasStaticCtorOrDtor();
    void checkCtorConstInit();
    void addLocalClass(Array<ClassDeclaration*>* aclasses);
    void addObjcSymbols(Array<ClassDeclaration*>* classes, Array<ClassDeclaration*>* categories);
    AttribDeclaration* isAttribDeclaration();
    void accept(Visitor* v);
};

class StorageClassDeclaration : public AttribDeclaration
{
public:
    StorageClass stc;
    Dsymbol* syntaxCopy(Dsymbol* s);
    Scope* newScope(Scope* sc);
    bool oneMember(Dsymbol** ps, Identifier* ident);
    void addMember(Scope* sc, ScopeDsymbol* sds);
    StorageClassDeclaration* isStorageClassDeclaration();
    void accept(Visitor* v);
};

class DeprecatedDeclaration : public StorageClassDeclaration
{
public:
    Expression* msg;
    char* msgstr;
    Dsymbol* syntaxCopy(Dsymbol* s);
    Scope* newScope(Scope* sc);
    void setScope(Scope* sc);
    void accept(Visitor* v);
};

class LinkDeclaration : public AttribDeclaration
{
public:
    LINK linkage;
    static LinkDeclaration* create(LINK p, Array<Dsymbol*>* decl);
    Dsymbol* syntaxCopy(Dsymbol* s);
    Scope* newScope(Scope* sc);
    const char* toChars() const;
    void accept(Visitor* v);
};

class CPPMangleDeclaration : public AttribDeclaration
{
public:
    CPPMANGLE cppmangle;
    Dsymbol* syntaxCopy(Dsymbol* s);
    Scope* newScope(Scope* sc);
    void setScope(Scope* sc);
    const char* toChars() const;
    void accept(Visitor* v);
};

class CPPNamespaceDeclaration : public AttribDeclaration
{
public:
    Expression* exp;
    Dsymbol* syntaxCopy(Dsymbol* s);
    Scope* newScope(Scope* sc);
    const char* toChars() const;
    void accept(Visitor* v);
    CPPNamespaceDeclaration* isCPPNamespaceDeclaration();
};

class ProtDeclaration : public AttribDeclaration
{
public:
    Prot protection;
    Array<Identifier*>* pkg_identifiers;
    Dsymbol* syntaxCopy(Dsymbol* s);
    Scope* newScope(Scope* sc);
    void addMember(Scope* sc, ScopeDsymbol* sds);
    const char* kind() const;
    const char* toPrettyChars(bool _param_0);
    ProtDeclaration* isProtDeclaration();
    void accept(Visitor* v);
};

class AlignDeclaration : public AttribDeclaration
{
public:
    Expression* ealign;
    ENUM_CONSTANT_NUMERIC(uint32_t, UNKNOWN, 0u)

    uint32_t salign;
    Dsymbol* syntaxCopy(Dsymbol* s);
    Scope* newScope(Scope* sc);
    void accept(Visitor* v);
};

class AnonDeclaration : public AttribDeclaration
{
public:
    bool isunion;
    int32_t sem;
    uint32_t anonoffset;
    uint32_t anonstructsize;
    uint32_t anonalignsize;
    Dsymbol* syntaxCopy(Dsymbol* s);
    void setScope(Scope* sc);
    void setFieldOffset(AggregateDeclaration* ad, uint32_t* poffset, bool isunion);
    const char* kind() const;
    AnonDeclaration* isAnonDeclaration();
    void accept(Visitor* v);
};

class PragmaDeclaration : public AttribDeclaration
{
public:
    Array<Expression*>* args;
    Dsymbol* syntaxCopy(Dsymbol* s);
    Scope* newScope(Scope* sc);
    const char* kind() const;
    void accept(Visitor* v);
};

class ConditionalDeclaration : public AttribDeclaration
{
public:
    Condition* condition;
    Array<Dsymbol*>* elsedecl;
    Dsymbol* syntaxCopy(Dsymbol* s);
    bool oneMember(Dsymbol** ps, Identifier* ident);
    Array<Dsymbol*>* include(Scope* sc);
    void addComment(const char* comment);
    void setScope(Scope* sc);
    void accept(Visitor* v);
};

class StaticIfDeclaration : public ConditionalDeclaration
{
public:
    ScopeDsymbol* scopesym;
    bool addisdone;
    bool onStack;
    Dsymbol* syntaxCopy(Dsymbol* s);
    Array<Dsymbol*>* include(Scope* sc);
    void addMember(Scope* sc, ScopeDsymbol* sds);
    void setScope(Scope* sc);
    void importAll(Scope* sc);
    const char* kind() const;
    void accept(Visitor* v);
};

class StaticForeachDeclaration : public AttribDeclaration
{
public:
    StaticForeach* sfe;
    ScopeDsymbol* scopesym;
    bool onStack;
    bool cached;
    Array<Dsymbol*>* cache;
    Dsymbol* syntaxCopy(Dsymbol* s);
    bool oneMember(Dsymbol** ps, Identifier* ident);
    Array<Dsymbol*>* include(Scope* sc);
    void addMember(Scope* sc, ScopeDsymbol* sds);
    void addComment(const char* comment);
    void setScope(Scope* sc);
    void importAll(Scope* sc);
    const char* kind() const;
    void accept(Visitor* v);
};

class ForwardingAttribDeclaration : public AttribDeclaration
{
public:
    ForwardingScopeDsymbol* sym;
    ForwardingAttribDeclaration(Array<Dsymbol*>* decl);
    Scope* newScope(Scope* sc);
    void addMember(Scope* sc, ScopeDsymbol* sds);
    ForwardingAttribDeclaration* isForwardingAttribDeclaration();
    void accept(Visitor* v);
};

class CompileDeclaration : public AttribDeclaration
{
public:
    Array<Expression*>* exps;
    ScopeDsymbol* scopesym;
    bool compiled;
    Dsymbol* syntaxCopy(Dsymbol* s);
    void addMember(Scope* sc, ScopeDsymbol* sds);
    void setScope(Scope* sc);
    const char* kind() const;
    CompileDeclaration* isCompileDeclaration();
    void accept(Visitor* v);
};

class UserAttributeDeclaration : public AttribDeclaration
{
public:
    Array<Expression*>* atts;
    Dsymbol* syntaxCopy(Dsymbol* s);
    Scope* newScope(Scope* sc);
    void setScope(Scope* sc);
    Array<Expression*>* getAttributes();
    const char* kind() const;
    void accept(Visitor* v);
    static bool isGNUABITag(Expression* e);
    static void checkGNUABITag(Dsymbol* sym, LINK linkage);
};

BEGIN_ENUM(BE, BE, be)
    ENUM_KEY(int32_t, none, 0, BE, BE, be, BE)
    ENUM_KEY(int32_t, fallthru, 1, BE, BE, be, BE)
    ENUM_KEY(int32_t, throw_, 2, BE, BE, be, BE)
    ENUM_KEY(int32_t, return_, 4, BE, BE, be, BE)
    ENUM_KEY(int32_t, goto_, 8, BE, BE, be, BE)
    ENUM_KEY(int32_t, halt, 16, BE, BE, be, BE)
    ENUM_KEY(int32_t, break_, 32, BE, BE, be, BE)
    ENUM_KEY(int32_t, continue_, 64, BE, BE, be, BE)
    ENUM_KEY(int32_t, errthrow, 128, BE, BE, be, BE)
    ENUM_KEY(int32_t, any, 31, BE, BE, be, BE)
END_ENUM(BE, BE, be)

extern BUILTIN isBuiltin(FuncDeclaration* fd);

extern Expression* eval_builtin(Loc loc, FuncDeclaration* fd, Array<Expression*>* arguments);

extern bool canThrow(Expression* e, FuncDeclaration* func, bool mustNotThrow);

BEGIN_ENUM(TargetOS, TARGETOS, targetos)
    ENUM_KEY(int32_t, all, 2147483647, TargetOS, TARGETOS, targetos, TOS)
    ENUM_KEY(int32_t, linux, 1, TargetOS, TARGETOS, targetos, TOS)
    ENUM_KEY(int32_t, windows, 2, TargetOS, TARGETOS, targetos, TOS)
    ENUM_KEY(int32_t, macOS, 4, TargetOS, TARGETOS, targetos, TOS)
    ENUM_KEY(int32_t, freeBSD, 8, TargetOS, TARGETOS, targetos, TOS)
    ENUM_KEY(int32_t, solaris, 16, TargetOS, TARGETOS, targetos, TOS)
    ENUM_KEY(int32_t, dragonFlyBSD, 32, TargetOS, TARGETOS, targetos, TOS)
END_ENUM(TargetOS, TARGETOS, targetos)

extern Module* rootHasMain;

extern bool includeImports;

extern Array<const char*> includeModulePatterns;

extern Array<Module*> compiledImports;

struct Compiler
{
    static Expression* paintAsType(UnionExp* pue, Expression* e, Type* type);
    static void onParseModule(Module* m);
    static bool onImport(Module* m);
    Compiler() {}
};

struct complex_t
{
    _d_real re;
    _d_real im;
    private: complex_t();
    public:
    complex_t(_d_real re);
    complex_t(_d_real re, _d_real im);
    int32_t opEquals(complex_t y) const;
};

extern _d_real creall(complex_t x);

extern _d_real cimagl(complex_t x);

BEGIN_ENUM(Include, INCLUDE, include)
    ENUM_KEY(int32_t, notComputed, 0, Include, INCLUDE, include, I)
    ENUM_KEY(int32_t, yes, 1, Include, INCLUDE, include, I)
    ENUM_KEY(int32_t, no, 2, Include, INCLUDE, include, I)
END_ENUM(Include, INCLUDE, include)

class Condition : public ASTNode
{
public:
    Loc loc;
    Include inc;
    DYNCAST dyncast() const;
    virtual Condition* syntaxCopy() = 0;
    virtual int32_t include(Scope* sc) = 0;
    virtual DebugCondition* isDebugCondition();
    virtual VersionCondition* isVersionCondition();
    void accept(Visitor* v);
};

class StaticForeach : public RootObject
{
public:
    Loc loc;
    ForeachStatement* aggrfe;
    ForeachRangeStatement* rangefe;
    bool needExpansion;
    StaticForeach* syntaxCopy();
    void lowerNonArrayAggregate(Scope* sc);
};

class DVCondition : public Condition
{
public:
    uint32_t level;
    Identifier* ident;
    Module* mod;
    Condition* syntaxCopy();
    void accept(Visitor* v);
};

class DebugCondition : public DVCondition
{
public:
    static void addGlobalIdent(const char* ident);
    int32_t include(Scope* sc);
    DebugCondition* isDebugCondition();
    void accept(Visitor* v);
    const char* toChars() const;
};

class VersionCondition : public DVCondition
{
public:
    static void addGlobalIdent(const char* ident);
    static void addPredefinedGlobalIdent(const char* ident);
    int32_t include(Scope* sc);
    VersionCondition* isVersionCondition();
    void accept(Visitor* v);
    const char* toChars() const;
};

class StaticIfCondition : public Condition
{
public:
    Expression* exp;
    Condition* syntaxCopy();
    int32_t include(Scope* sc);
    void accept(Visitor* v);
    const char* toChars() const;
};

BEGIN_ENUM(CppOperator, CPPOPERATOR, cppoperator)
    ENUM_KEY(int32_t, Cast, 0, CppOperator, CPPOPERATOR, cppoperator, CO)
    ENUM_KEY(int32_t, Assign, 1, CppOperator, CPPOPERATOR, cppoperator, CO)
    ENUM_KEY(int32_t, Eq, 2, CppOperator, CPPOPERATOR, cppoperator, CO)
    ENUM_KEY(int32_t, Index, 3, CppOperator, CPPOPERATOR, cppoperator, CO)
    ENUM_KEY(int32_t, Call, 4, CppOperator, CPPOPERATOR, cppoperator, CO)
    ENUM_KEY(int32_t, Unary, 5, CppOperator, CPPOPERATOR, cppoperator, CO)
    ENUM_KEY(int32_t, Binary, 6, CppOperator, CPPOPERATOR, cppoperator, CO)
    ENUM_KEY(int32_t, OpAssign, 7, CppOperator, CPPOPERATOR, cppoperator, CO)
    ENUM_KEY(int32_t, Unknown, 8, CppOperator, CPPOPERATOR, cppoperator, CO)
END_ENUM(CppOperator, CPPOPERATOR, cppoperator)

extern const char* toCppMangleItanium(Dsymbol* s);

extern const char* cppTypeInfoMangleItanium(Dsymbol* s);

extern const char* toCppMangleMSVC(Dsymbol* s);

extern const char* cppTypeInfoMangleMSVC(Dsymbol* s);

class ClassReferenceExp : public Expression
{
public:
    StructLiteralExp* value;
    ClassDeclaration* originalClass();
    int32_t getFieldIndex(Type* fieldtype, uint32_t fieldoffset);
    int32_t findFieldIndexByName(VarDeclaration* v);
    void accept(Visitor* v);
};

class ThrownExceptionExp : public Expression
{
public:
    ClassReferenceExp* thrown;
    const char* toChars() const;
    void accept(Visitor* v);
};

class CTFEExp : public Expression
{
public:
    const char* toChars() const;
};

BEGIN_ENUM_NUMERIC(uint16_t, CSX, CSX, csx)
    ENUM_KEY_NUMERIC(uint16_t, none, 0u, CSX, CSX, csx, CSX)
    ENUM_KEY_NUMERIC(uint16_t, this_ctor, 1u, CSX, CSX, csx, CSX)
    ENUM_KEY_NUMERIC(uint16_t, super_ctor, 2u, CSX, CSX, csx, CSX)
    ENUM_KEY_NUMERIC(uint16_t, label, 4u, CSX, CSX, csx, CSX)
    ENUM_KEY_NUMERIC(uint16_t, return_, 8u, CSX, CSX, csx, CSX)
    ENUM_KEY_NUMERIC(uint16_t, any_ctor, 16u, CSX, CSX, csx, CSX)
    ENUM_KEY_NUMERIC(uint16_t, halt, 32u, CSX, CSX, csx, CSX)
END_ENUM_NUMERIC(uint16_t, CSX, CSX, csx)

ENUM_CONSTANT_NUMERIC(bool, LOG, false)

extern bool arrayTypeCompatibleWithoutCasting(Type* t1, Type* t2);

BEGIN_ENUM(Abstract, ABSTRACT, abstract)
    ENUM_KEY(int32_t, fwdref, 0, Abstract, ABSTRACT, abstract, A)
    ENUM_KEY(int32_t, yes, 1, Abstract, ABSTRACT, abstract, A)
    ENUM_KEY(int32_t, no, 2, Abstract, ABSTRACT, abstract, A)
END_ENUM(Abstract, ABSTRACT, abstract)

struct BaseClass
{
    Type* type;
    ClassDeclaration* sym;
    uint32_t offset;
    Array<FuncDeclaration*> vtbl;
    DArray< BaseClass > baseInterfaces;
    bool fillVtbl(ClassDeclaration* cd, Array<FuncDeclaration*>* vtbl, int32_t newinstance);
    ~BaseClass();
    BaseClass() : type(), sym(), offset(), vtbl(), baseInterfaces() {}
};

BEGIN_ENUM(ClassFlags, CLASSFLAGS, classflags)
    ENUM_KEY(int32_t, none, 0, ClassFlags, CLASSFLAGS, classflags, CF)
    ENUM_KEY(int32_t, isCOMclass, 1, ClassFlags, CLASSFLAGS, classflags, CF)
    ENUM_KEY(int32_t, noPointers, 2, ClassFlags, CLASSFLAGS, classflags, CF)
    ENUM_KEY(int32_t, hasOffTi, 4, ClassFlags, CLASSFLAGS, classflags, CF)
    ENUM_KEY(int32_t, hasCtor, 8, ClassFlags, CLASSFLAGS, classflags, CF)
    ENUM_KEY(int32_t, hasGetMembers, 16, ClassFlags, CLASSFLAGS, classflags, CF)
    ENUM_KEY(int32_t, hasTypeInfo, 32, ClassFlags, CLASSFLAGS, classflags, CF)
    ENUM_KEY(int32_t, isAbstract, 64, ClassFlags, CLASSFLAGS, classflags, CF)
    ENUM_KEY(int32_t, isCPPclass, 128, ClassFlags, CLASSFLAGS, classflags, CF)
    ENUM_KEY(int32_t, hasDtor, 256, ClassFlags, CLASSFLAGS, classflags, CF)
END_ENUM(ClassFlags, CLASSFLAGS, classflags)

class ClassDeclaration : public AggregateDeclaration
{
public:
    static ClassDeclaration* object;
    static ClassDeclaration* throwable;
    static ClassDeclaration* exception;
    static ClassDeclaration* errorException;
    static ClassDeclaration* cpp_type_info_ptr;
    ClassDeclaration* baseClass;
    FuncDeclaration* staticCtor;
    FuncDeclaration* staticDtor;
    Array<Dsymbol*> vtbl;
    Array<Dsymbol*> vtblFinal;
    Array<BaseClass*>* baseclasses;
    DArray< BaseClass* > interfaces;
    Array<BaseClass*>* vtblInterfaces;
    TypeInfoClassDeclaration* vclassinfo;
    bool com;
    bool stack;
    int32_t cppDtorVtblIndex;
    bool inuse;
    Abstract isabstract;
    Baseok baseok;
    ObjcClassDeclaration objc;
    Symbol* cpp_type_info_ptr_sym;
    static ClassDeclaration* create(Loc loc, Identifier* id, Array<BaseClass*>* baseclasses, Array<Dsymbol*>* members, bool inObject);
    Dsymbol* syntaxCopy(Dsymbol* s);
    Scope* newScope(Scope* sc);
    bool isBaseOf2(ClassDeclaration* cd);
    ENUM_CONSTANT_NUMERIC(int32_t, OFFSET_RUNTIME, 1985229328)

    ENUM_CONSTANT_NUMERIC(int32_t, OFFSET_FWDREF, 1985229329)

    virtual bool isBaseOf(ClassDeclaration* cd, int32_t* poffset);
    bool isBaseInfoComplete() const;
    Dsymbol* search(const Loc& loc, Identifier* ident, int32_t flags = 8);
    ClassDeclaration* searchBase(Identifier* ident);
    void finalizeSize();
    bool hasMonitor();
    bool isFuncHidden(FuncDeclaration* fd);
    FuncDeclaration* findFunc(Identifier* ident, TypeFunction* tf);
    bool isCOMclass() const;
    virtual bool isCOMinterface() const;
    bool isCPPclass() const;
    virtual bool isCPPinterface() const;
    bool isAbstract();
    virtual int32_t vtblOffset() const;
    const char* kind() const;
    void addLocalClass(Array<ClassDeclaration*>* aclasses);
    void addObjcSymbols(Array<ClassDeclaration*>* classes, Array<ClassDeclaration*>* categories);
    Dsymbol* vtblsym;
    Dsymbol* vtblSymbol();
    ClassDeclaration* isClassDeclaration();
    void accept(Visitor* v);
    ~ClassDeclaration();
};

class InterfaceDeclaration : public ClassDeclaration
{
public:
    Dsymbol* syntaxCopy(Dsymbol* s);
    Scope* newScope(Scope* sc);
    bool isBaseOf(ClassDeclaration* cd, int32_t* poffset);
    bool isBaseOf(BaseClass* bc, int32_t* poffset);
    const char* kind() const;
    int32_t vtblOffset() const;
    bool isCPPinterface() const;
    bool isCOMinterface() const;
    InterfaceDeclaration* isInterfaceDeclaration();
    void accept(Visitor* v);
    ~InterfaceDeclaration();
};

extern void ObjectNotFound(Identifier* id);

BEGIN_ENUM_NUMERIC(uint64_t, STC, STC, stc)
    ENUM_KEY_NUMERIC(uint64_t, undefined_, 0LLU, STC, STC, stc, STC)
    ENUM_KEY_NUMERIC(uint64_t, static_, 1LLU, STC, STC, stc, STC)
    ENUM_KEY_NUMERIC(uint64_t, extern_, 2LLU, STC, STC, stc, STC)
    ENUM_KEY_NUMERIC(uint64_t, const_, 4LLU, STC, STC, stc, STC)
    ENUM_KEY_NUMERIC(uint64_t, final_, 8LLU, STC, STC, stc, STC)
    ENUM_KEY_NUMERIC(uint64_t, abstract_, 16LLU, STC, STC, stc, STC)
    ENUM_KEY_NUMERIC(uint64_t, parameter, 32LLU, STC, STC, stc, STC)
    ENUM_KEY_NUMERIC(uint64_t, field, 64LLU, STC, STC, stc, STC)
    ENUM_KEY_NUMERIC(uint64_t, override_, 128LLU, STC, STC, stc, STC)
    ENUM_KEY_NUMERIC(uint64_t, auto_, 256LLU, STC, STC, stc, STC)
    ENUM_KEY_NUMERIC(uint64_t, synchronized_, 512LLU, STC, STC, stc, STC)
    ENUM_KEY_NUMERIC(uint64_t, deprecated_, 1024LLU, STC, STC, stc, STC)
    ENUM_KEY_NUMERIC(uint64_t, in_, 2048LLU, STC, STC, stc, STC)
    ENUM_KEY_NUMERIC(uint64_t, out_, 4096LLU, STC, STC, stc, STC)
    ENUM_KEY_NUMERIC(uint64_t, lazy_, 8192LLU, STC, STC, stc, STC)
    ENUM_KEY_NUMERIC(uint64_t, foreach_, 16384LLU, STC, STC, stc, STC)
    ENUM_KEY_NUMERIC(uint64_t, variadic, 65536LLU, STC, STC, stc, STC)
    ENUM_KEY_NUMERIC(uint64_t, ctorinit, 131072LLU, STC, STC, stc, STC)
    ENUM_KEY_NUMERIC(uint64_t, templateparameter, 262144LLU, STC, STC, stc, STC)
    ENUM_KEY_NUMERIC(uint64_t, scope_, 524288LLU, STC, STC, stc, STC)
    ENUM_KEY_NUMERIC(uint64_t, immutable_, 1048576LLU, STC, STC, stc, STC)
    ENUM_KEY_NUMERIC(uint64_t, ref_, 2097152LLU, STC, STC, stc, STC)
    ENUM_KEY_NUMERIC(uint64_t, init, 4194304LLU, STC, STC, stc, STC)
    ENUM_KEY_NUMERIC(uint64_t, manifest, 8388608LLU, STC, STC, stc, STC)
    ENUM_KEY_NUMERIC(uint64_t, nodtor, 16777216LLU, STC, STC, stc, STC)
    ENUM_KEY_NUMERIC(uint64_t, nothrow_, 33554432LLU, STC, STC, stc, STC)
    ENUM_KEY_NUMERIC(uint64_t, pure_, 67108864LLU, STC, STC, stc, STC)
    ENUM_KEY_NUMERIC(uint64_t, tls, 134217728LLU, STC, STC, stc, STC)
    ENUM_KEY_NUMERIC(uint64_t, alias_, 268435456LLU, STC, STC, stc, STC)
    ENUM_KEY_NUMERIC(uint64_t, shared_, 536870912LLU, STC, STC, stc, STC)
    ENUM_KEY_NUMERIC(uint64_t, gshared, 1073741824LLU, STC, STC, stc, STC)
    ENUM_KEY_NUMERIC(uint64_t, wild, 2147483648LLU, STC, STC, stc, STC)
    ENUM_KEY_NUMERIC(uint64_t, property, 4294967296LLU, STC, STC, stc, STC)
    ENUM_KEY_NUMERIC(uint64_t, safe, 8589934592LLU, STC, STC, stc, STC)
    ENUM_KEY_NUMERIC(uint64_t, trusted, 17179869184LLU, STC, STC, stc, STC)
    ENUM_KEY_NUMERIC(uint64_t, system, 34359738368LLU, STC, STC, stc, STC)
    ENUM_KEY_NUMERIC(uint64_t, ctfe, 68719476736LLU, STC, STC, stc, STC)
    ENUM_KEY_NUMERIC(uint64_t, disable, 137438953472LLU, STC, STC, stc, STC)
    ENUM_KEY_NUMERIC(uint64_t, result, 274877906944LLU, STC, STC, stc, STC)
    ENUM_KEY_NUMERIC(uint64_t, nodefaultctor, 549755813888LLU, STC, STC, stc, STC)
    ENUM_KEY_NUMERIC(uint64_t, temp, 1099511627776LLU, STC, STC, stc, STC)
    ENUM_KEY_NUMERIC(uint64_t, rvalue, 2199023255552LLU, STC, STC, stc, STC)
    ENUM_KEY_NUMERIC(uint64_t, nogc, 4398046511104LLU, STC, STC, stc, STC)
    ENUM_KEY_NUMERIC(uint64_t, volatile_, 8796093022208LLU, STC, STC, stc, STC)
    ENUM_KEY_NUMERIC(uint64_t, return_, 17592186044416LLU, STC, STC, stc, STC)
    ENUM_KEY_NUMERIC(uint64_t, autoref, 35184372088832LLU, STC, STC, stc, STC)
    ENUM_KEY_NUMERIC(uint64_t, inference, 70368744177664LLU, STC, STC, stc, STC)
    ENUM_KEY_NUMERIC(uint64_t, exptemp, 140737488355328LLU, STC, STC, stc, STC)
    ENUM_KEY_NUMERIC(uint64_t, maybescope, 281474976710656LLU, STC, STC, stc, STC)
    ENUM_KEY_NUMERIC(uint64_t, scopeinferred, 562949953421312LLU, STC, STC, stc, STC)
    ENUM_KEY_NUMERIC(uint64_t, future, 1125899906842624LLU, STC, STC, stc, STC)
    ENUM_KEY_NUMERIC(uint64_t, local, 2251799813685248LLU, STC, STC, stc, STC)
    ENUM_KEY_NUMERIC(uint64_t, returninferred, 4503599627370496LLU, STC, STC, stc, STC)
    ENUM_KEY_NUMERIC(uint64_t, live, 9007199254740992LLU, STC, STC, stc, STC)
    ENUM_KEY_NUMERIC(uint64_t, safeGroup, 60129542144LLU, STC, STC, stc, STC)
    ENUM_KEY_NUMERIC(uint64_t, IOR, 2103296LLU, STC, STC, stc, STC)
    ENUM_KEY_NUMERIC(uint64_t, TYPECTOR, 2685403140LLU, STC, STC, stc, STC)
    ENUM_KEY_NUMERIC(uint64_t, FUNCATTR, 9011661828521984LLU, STC, STC, stc, STC)
END_ENUM_NUMERIC(uint64_t, STC, STC, stc)

ENUM_CONSTANT(STC, STCStorageClass, (STC)12407095344775071LLU)

ENUM_CONSTANT(STC, STCFlowThruAggregate, (STC)60129542144LLU)

ENUM_CONSTANT(STC, STCFlowThruFunction, (STC)18446726413102348896LLU)

class Declaration : public Dsymbol
{
public:
    Type* type;
    Type* originalType;
    StorageClass storage_class;
    Prot protection;
    LINK linkage;
    int32_t inuse;
    DArray< char > mangleOverride;
    const char* kind() const;
    d_uns64 size(const Loc& loc);
    Dsymbol* search(const Loc& loc, Identifier* ident, int32_t flags = 8);
    bool isStatic() const;
    virtual bool isDelete();
    virtual bool isDataseg();
    virtual bool isThreadlocal();
    virtual bool isCodeseg() const;
    bool isCtorinit() const;
    bool isFinal() const;
    virtual bool isAbstract();
    bool isConst() const;
    bool isImmutable() const;
    bool isWild() const;
    bool isAuto() const;
    bool isScope() const;
    bool isSynchronized() const;
    bool isParameter() const;
    bool isDeprecated() const;
    bool isDisabled() const;
    bool isOverride() const;
    bool isResult() const;
    bool isField() const;
    bool isIn() const;
    bool isOut() const;
    bool isRef() const;
    bool isFuture() const;
    Prot prot();
    Declaration* isDeclaration();
    void accept(Visitor* v);
};

class TupleDeclaration : public Declaration
{
public:
    Array<RootObject*>* objects;
    bool isexp;
    TypeTuple* tupletype;
    Dsymbol* syntaxCopy(Dsymbol* s);
    const char* kind() const;
    Type* getType();
    Dsymbol* toAlias2();
    bool needThis();
    TupleDeclaration* isTupleDeclaration();
    void accept(Visitor* v);
};

class AliasDeclaration : public Declaration
{
public:
    Dsymbol* aliassym;
    Dsymbol* overnext;
    Dsymbol* _import;
    static AliasDeclaration* create(Loc loc, Identifier* id, Type* type);
    Dsymbol* syntaxCopy(Dsymbol* s);
    bool overloadInsert(Dsymbol* s);
    const char* kind() const;
    Type* getType();
    Dsymbol* toAlias();
    Dsymbol* toAlias2();
    bool isOverloadable() const;
    AliasDeclaration* isAliasDeclaration();
    void accept(Visitor* v);
};

class OverDeclaration : public Declaration
{
public:
    Dsymbol* overnext;
    Dsymbol* aliassym;
    bool hasOverloads;
    const char* kind() const;
    bool equals(const RootObject* const o) const;
    bool overloadInsert(Dsymbol* s);
    bool isOverloadable() const;
    Dsymbol* isUnique();
    OverDeclaration* isOverDeclaration();
    void accept(Visitor* v);
};

class VarDeclaration : public Declaration
{
public:
    Initializer* _init;
    uint32_t offset;
    uint32_t sequenceNumber;
    static uint32_t nextSequenceNumber;
    Array<FuncDeclaration*> nestedrefs;
    uint32_t alignment;
    bool isargptr;
    bool ctorinit;
    bool iscatchvar;
    bool isowner;
    bool onstack;
    bool mynew;
    int8_t canassign;
    bool overlapped;
    bool overlapUnsafe;
    bool doNotInferScope;
    bool doNotInferReturn;
    uint8_t isdataseg;
    Dsymbol* aliassym;
    VarDeclaration* lastVar;
    uint32_t endlinnum;
    ENUM_CONSTANT_NUMERIC(uint32_t, AdrOnStackNone, 4294967295u)

    uint32_t ctfeAdrOnStack;
    Expression* edtor;
    IntRange* range;
    Array<VarDeclaration*>* maybes;
    static VarDeclaration* create(const Loc& loc, Type* type, Identifier* ident, Initializer* _init, StorageClass storage_class);
    Dsymbol* syntaxCopy(Dsymbol* s);
    void setFieldOffset(AggregateDeclaration* ad, uint32_t* poffset, bool isunion);
    const char* kind() const;
    AggregateDeclaration* isThis();
    bool needThis();
    bool isExport() const;
    bool isImportedSymbol() const;
    bool isDataseg();
    bool isThreadlocal();
    bool isCTFE();
    bool isOverlappedWith(VarDeclaration* v);
    bool hasPointers();
    bool canTakeAddressOf();
    bool needsScopeDtor();
    void checkCtorConstInit();
    Dsymbol* toAlias();
    VarDeclaration* isVarDeclaration();
    void accept(Visitor* v);
    bool enclosesLifetimeOf(VarDeclaration* v) const;
    void addMaybe(VarDeclaration* v);
    ~VarDeclaration();
};

class SymbolDeclaration : public Declaration
{
public:
    StructDeclaration* dsym;
    SymbolDeclaration* isSymbolDeclaration();
    void accept(Visitor* v);
};

class TypeInfoDeclaration : public VarDeclaration
{
public:
    Type* tinfo;
    static TypeInfoDeclaration* create(Type* tinfo);
    Dsymbol* syntaxCopy(Dsymbol* s);
    const char* toChars() const;
    TypeInfoDeclaration* isTypeInfoDeclaration();
    void accept(Visitor* v);
    ~TypeInfoDeclaration();
};

class TypeInfoStructDeclaration : public TypeInfoDeclaration
{
public:
    static TypeInfoStructDeclaration* create(Type* tinfo);
    void accept(Visitor* v);
    ~TypeInfoStructDeclaration();
};

class TypeInfoClassDeclaration : public TypeInfoDeclaration
{
public:
    static TypeInfoClassDeclaration* create(Type* tinfo);
    void accept(Visitor* v);
    ~TypeInfoClassDeclaration();
};

class TypeInfoInterfaceDeclaration : public TypeInfoDeclaration
{
public:
    static TypeInfoInterfaceDeclaration* create(Type* tinfo);
    void accept(Visitor* v);
    ~TypeInfoInterfaceDeclaration();
};

class TypeInfoPointerDeclaration : public TypeInfoDeclaration
{
public:
    static TypeInfoPointerDeclaration* create(Type* tinfo);
    void accept(Visitor* v);
    ~TypeInfoPointerDeclaration();
};

class TypeInfoArrayDeclaration : public TypeInfoDeclaration
{
public:
    static TypeInfoArrayDeclaration* create(Type* tinfo);
    void accept(Visitor* v);
    ~TypeInfoArrayDeclaration();
};

class TypeInfoStaticArrayDeclaration : public TypeInfoDeclaration
{
public:
    static TypeInfoStaticArrayDeclaration* create(Type* tinfo);
    void accept(Visitor* v);
    ~TypeInfoStaticArrayDeclaration();
};

class TypeInfoAssociativeArrayDeclaration : public TypeInfoDeclaration
{
public:
    static TypeInfoAssociativeArrayDeclaration* create(Type* tinfo);
    void accept(Visitor* v);
    ~TypeInfoAssociativeArrayDeclaration();
};

class TypeInfoEnumDeclaration : public TypeInfoDeclaration
{
public:
    static TypeInfoEnumDeclaration* create(Type* tinfo);
    void accept(Visitor* v);
    ~TypeInfoEnumDeclaration();
};

class TypeInfoFunctionDeclaration : public TypeInfoDeclaration
{
public:
    static TypeInfoFunctionDeclaration* create(Type* tinfo);
    void accept(Visitor* v);
    ~TypeInfoFunctionDeclaration();
};

class TypeInfoDelegateDeclaration : public TypeInfoDeclaration
{
public:
    static TypeInfoDelegateDeclaration* create(Type* tinfo);
    void accept(Visitor* v);
    ~TypeInfoDelegateDeclaration();
};

class TypeInfoTupleDeclaration : public TypeInfoDeclaration
{
public:
    static TypeInfoTupleDeclaration* create(Type* tinfo);
    void accept(Visitor* v);
    ~TypeInfoTupleDeclaration();
};

class TypeInfoConstDeclaration : public TypeInfoDeclaration
{
public:
    static TypeInfoConstDeclaration* create(Type* tinfo);
    void accept(Visitor* v);
    ~TypeInfoConstDeclaration();
};

class TypeInfoInvariantDeclaration : public TypeInfoDeclaration
{
public:
    static TypeInfoInvariantDeclaration* create(Type* tinfo);
    void accept(Visitor* v);
    ~TypeInfoInvariantDeclaration();
};

class TypeInfoSharedDeclaration : public TypeInfoDeclaration
{
public:
    static TypeInfoSharedDeclaration* create(Type* tinfo);
    void accept(Visitor* v);
    ~TypeInfoSharedDeclaration();
};

class TypeInfoWildDeclaration : public TypeInfoDeclaration
{
public:
    static TypeInfoWildDeclaration* create(Type* tinfo);
    void accept(Visitor* v);
    ~TypeInfoWildDeclaration();
};

class TypeInfoVectorDeclaration : public TypeInfoDeclaration
{
public:
    static TypeInfoVectorDeclaration* create(Type* tinfo);
    void accept(Visitor* v);
    ~TypeInfoVectorDeclaration();
};

class ThisDeclaration : public VarDeclaration
{
public:
    Dsymbol* syntaxCopy(Dsymbol* s);
    ThisDeclaration* isThisDeclaration();
    void accept(Visitor* v);
    ~ThisDeclaration();
};

class EnumDeclaration : public ScopeDsymbol
{
public:
    Type* type;
    Type* memtype;
    Prot protection;
    Expression* maxval;
    Expression* minval;
    Expression* defaultval;
    bool isdeprecated;
    bool added;
    int32_t inuse;
    Dsymbol* syntaxCopy(Dsymbol* s);
    void addMember(Scope* sc, ScopeDsymbol* sds);
    void setScope(Scope* sc);
    bool oneMember(Dsymbol** ps, Identifier* ident);
    Type* getType();
    const char* kind() const;
    Dsymbol* search(const Loc& loc, Identifier* ident, int32_t flags = 8);
    bool isDeprecated() const;
    Prot prot();
    Expression* getMaxMinValue(const Loc& loc, Identifier* id);
    bool isSpecial() const;
    Expression* getDefaultValue(const Loc& loc);
    Type* getMemtype(const Loc& loc);
    EnumDeclaration* isEnumDeclaration();
    Symbol* sinit;
    void accept(Visitor* v);
    ~EnumDeclaration();
};

class EnumMember : public VarDeclaration
{
public:
    Expression*& value();
    Expression* origValue;
    Type* origType;
    EnumDeclaration* ed;
    Dsymbol* syntaxCopy(Dsymbol* s);
    const char* kind() const;
    Expression* getVarExp(const Loc& loc, Scope* sc);
    EnumMember* isEnumMember();
    void accept(Visitor* v);
    ~EnumMember();
};

class Import : public Dsymbol
{
public:
    Array<Identifier*>* packages;
    Identifier* id;
    Identifier* aliasId;
    int32_t isstatic;
    Prot protection;
    Array<Identifier*> names;
    Array<Identifier*> aliases;
    Module* mod;
    Package* pkg;
    Array<AliasDeclaration*> aliasdecls;
    const char* kind() const;
    Prot prot();
    Dsymbol* syntaxCopy(Dsymbol* s);
    bool load(Scope* sc);
    void importAll(Scope* sc);
    Dsymbol* toAlias();
    void addMember(Scope* sc, ScopeDsymbol* sd);
    void setScope(Scope* sc);
    Dsymbol* search(const Loc& loc, Identifier* ident, int32_t flags = 8);
    bool overloadInsert(Dsymbol* s);
    Import* isImport();
    void accept(Visitor* v);
    ~Import();
};

extern Expression* getValue(VarDeclaration* vd);

extern void printCtfePerformanceStats();

struct MacroTable
{
    Macro* mactab;
    MacroTable() {}
};

extern const char* mangleExact(FuncDeclaration* fd);

extern void mangleToBuffer(Type* t, OutBuffer* buf);

extern void mangleToBuffer(Expression* e, OutBuffer* buf);

extern void mangleToBuffer(Dsymbol* s, OutBuffer* buf);

extern void mangleToBuffer(TemplateInstance* ti, OutBuffer* buf);

BEGIN_ENUM(PKG, PKG, pkg)
    ENUM_KEY(int32_t, unknown, 0, PKG, PKG, pkg, PKG)
    ENUM_KEY(int32_t, module_, 1, PKG, PKG, pkg, PKG)
    ENUM_KEY(int32_t, package_, 2, PKG, PKG, pkg, PKG)
END_ENUM(PKG, PKG, pkg)

class Package : public ScopeDsymbol
{
public:
    PKG isPkgMod;
    uint32_t tag;
    Module* mod;
    const char* kind() const;
    bool equals(const RootObject* const o) const;
    Package* isPackage();
    bool isAncestorPackageOf(const Package* const pkg) const;
    Dsymbol* search(const Loc& loc, Identifier* ident, int32_t flags = 8);
    void accept(Visitor* v);
    Module* isPackageMod();
    void resolvePKGunknown();
    ~Package();
};

class Module : public Package
{
public:
    static Module* rootModule;
    static DsymbolTable* modules;
    static Array<Module*> amodules;
    static Array<Dsymbol*> deferred;
    static Array<Dsymbol*> deferred2;
    static Array<Dsymbol*> deferred3;
    static uint32_t dprogress;
    static void _init();
    static void deinitialize();
    static AggregateDeclaration* moduleinfo;
    DArray< char > arg;
    ModuleDeclaration* md;
    FileName srcfile;
    FileName objfile;
    FileName hdrfile;
    FileName docfile;
    FileBuffer* srcBuffer;
    uint32_t errors;
    uint32_t numlines;
    bool isHdrFile;
    bool isDocFile;
    bool hasAlwaysInlines;
    bool isPackageFile;
    Package* pkg;
    Array<char*> contentImportedFiles;
    int32_t needmoduleinfo;
    int32_t selfimports;
    bool selfImports();
    int32_t rootimports;
    bool rootImports();
    int32_t insearch;
    Identifier* searchCacheIdent;
    Dsymbol* searchCacheSymbol;
    int32_t searchCacheFlags;
    Module* importedFrom;
    Array<Dsymbol*>* decldefs;
    Array<Module*> aimports;
    uint32_t debuglevel;
    Array<Identifier*>* debugids;
    Array<Identifier*>* debugidsNot;
    uint32_t versionlevel;
    Array<Identifier*>* versionids;
    Array<Identifier*>* versionidsNot;
    MacroTable macrotable;
    Escape* escapetable;
    size_t nameoffset;
    size_t namelen;
    static Module* create(const char* filename, Identifier* ident, int32_t doDocComment, int32_t doHdrGen);
    static Module* load(Loc loc, Array<Identifier*>* packages, Identifier* ident);
    const char* kind() const;
    bool loadSourceBuffer(const Loc& loc, ReadResult& readResult);
    bool read(const Loc& loc);
    Module* parse();
    void importAll(Scope* prevsc);
    int32_t needModuleInfo();
    void checkImportDeprecation(const Loc& loc, Scope* sc);
    Dsymbol* search(const Loc& loc, Identifier* ident, int32_t flags = 8);
    bool isPackageAccessible(Package* p, Prot protection, int32_t flags = 0);
    Dsymbol* symtabInsert(Dsymbol* s);
    void deleteObjFile();
    static void runDeferredSemantic();
    static void runDeferredSemantic2();
    static void runDeferredSemantic3();
    int32_t imports(Module* m);
    bool isRoot();
    bool isCoreModule(Identifier* ident);
    int32_t doppelganger;
    Symbol* cov;
    uint32_t* covb;
    Symbol* sictor;
    Symbol* sctor;
    Symbol* sdtor;
    Symbol* ssharedctor;
    Symbol* sshareddtor;
    Symbol* stest;
    Symbol* sfilename;
    void* ctfe_cov;
    Module* isModule();
    void accept(Visitor* v);
    void fullyQualifiedName(OutBuffer& buf);
    ~Module();
};

struct ModuleDeclaration
{
    Loc loc;
    Identifier* id;
    Array<Identifier*>* packages;
    bool isdeprecated;
    Expression* msg;
    const char* toChars() const;
    ModuleDeclaration() : loc(), id(), packages(), isdeprecated(), msg() {}
};

extern void gendocfile(Module* m);

BEGIN_ENUM(SCOPE, SCOPE, scope)
    ENUM_KEY(int32_t, ctor, 1, SCOPE, SCOPE, scope, SCOPE)
    ENUM_KEY(int32_t, noaccesscheck, 2, SCOPE, SCOPE, scope, SCOPE)
    ENUM_KEY(int32_t, condition, 4, SCOPE, SCOPE, scope, SCOPE)
    ENUM_KEY(int32_t, debug_, 8, SCOPE, SCOPE, scope, SCOPE)
    ENUM_KEY(int32_t, constraint, 16, SCOPE, SCOPE, scope, SCOPE)
    ENUM_KEY(int32_t, invariant_, 32, SCOPE, SCOPE, scope, SCOPE)
    ENUM_KEY(int32_t, require, 64, SCOPE, SCOPE, scope, SCOPE)
    ENUM_KEY(int32_t, ensure, 96, SCOPE, SCOPE, scope, SCOPE)
    ENUM_KEY(int32_t, contract, 96, SCOPE, SCOPE, scope, SCOPE)
    ENUM_KEY(int32_t, ctfe, 128, SCOPE, SCOPE, scope, SCOPE)
    ENUM_KEY(int32_t, compile, 256, SCOPE, SCOPE, scope, SCOPE)
    ENUM_KEY(int32_t, ignoresymbolvisibility, 512, SCOPE, SCOPE, scope, SCOPE)
    ENUM_KEY(int32_t, onlysafeaccess, 1024, SCOPE, SCOPE, scope, SCOPE)
    ENUM_KEY(int32_t, free, 32768, SCOPE, SCOPE, scope, SCOPE)
    ENUM_KEY(int32_t, fullinst, 65536, SCOPE, SCOPE, scope, SCOPE)
    ENUM_KEY(int32_t, alias_, 131072, SCOPE, SCOPE, scope, SCOPE)
    ENUM_KEY(int32_t, printf, 262144, SCOPE, SCOPE, scope, SCOPE)
    ENUM_KEY(int32_t, scanf, 524288, SCOPE, SCOPE, scope, SCOPE)
END_ENUM(SCOPE, SCOPE, scope)

ENUM_CONSTANT(SCOPE, SCOPEpush, (SCOPE)788474)

extern FuncDeclaration* search_toString(StructDeclaration* sd);

extern void semanticTypeInfo(Scope* sc, Type* t);

BEGIN_ENUM(StructFlags, STRUCTFLAGS, structflags)
    ENUM_KEY(int32_t, none, 0, StructFlags, STRUCTFLAGS, structflags, SF)
    ENUM_KEY(int32_t, hasPointers, 1, StructFlags, STRUCTFLAGS, structflags, SF)
END_ENUM(StructFlags, STRUCTFLAGS, structflags)

BEGIN_ENUM(StructPOD, STRUCTPOD, structpod)
    ENUM_KEY(int32_t, no, 0, StructPOD, STRUCTPOD, structpod, SPOD)
    ENUM_KEY(int32_t, yes, 1, StructPOD, STRUCTPOD, structpod, SPOD)
    ENUM_KEY(int32_t, fwd, 2, StructPOD, STRUCTPOD, structpod, SPOD)
END_ENUM(StructPOD, STRUCTPOD, structpod)

class StructDeclaration : public AggregateDeclaration
{
public:
    bool zeroInit;
    bool hasIdentityAssign;
    bool hasBlitAssign;
    bool hasIdentityEquals;
    bool hasNoFields;
    bool hasCopyCtor;
    bool requestTypeInfo;
    Array<FuncDeclaration*> postblits;
    FuncDeclaration* postblit;
    FuncDeclaration* xeq;
    FuncDeclaration* xcmp;
    FuncDeclaration* xhash;
    static FuncDeclaration* xerreq;
    static FuncDeclaration* xerrcmp;
    uint32_t alignment;
    StructPOD ispod;
    TypeTuple* argTypes;
    static StructDeclaration* create(Loc loc, Identifier* id, bool inObject);
    Dsymbol* syntaxCopy(Dsymbol* s);
    void semanticTypeInfoMembers();
    Dsymbol* search(const Loc& loc, Identifier* ident, int32_t flags = 8);
    const char* kind() const;
    void finalizeSize();
    bool fit(const Loc& loc, Scope* sc, Array<Expression*>* elements, Type* stype);
    bool isPOD();
    StructDeclaration* isStructDeclaration();
    void accept(Visitor* v);
    uint32_t numArgTypes() const;
    Type* argType(uint32_t index);
    bool hasNonDisabledCtor();
    ~StructDeclaration();
};

class UnionDeclaration : public StructDeclaration
{
public:
    Dsymbol* syntaxCopy(Dsymbol* s);
    const char* kind() const;
    UnionDeclaration* isUnionDeclaration();
    void accept(Visitor* v);
    ~UnionDeclaration();
};

BEGIN_ANON_ENUM()
    ANON_ENUM_KEY(int32_t, IgnoreNone, 0)
    ANON_ENUM_KEY(int32_t, IgnorePrivateImports, 1)
    ANON_ENUM_KEY(int32_t, IgnoreErrors, 2)
    ANON_ENUM_KEY(int32_t, IgnoreAmbiguous, 4)
    ANON_ENUM_KEY(int32_t, SearchLocalsOnly, 8)
    ANON_ENUM_KEY(int32_t, SearchImportsOnly, 16)
    ANON_ENUM_KEY(int32_t, SearchUnqualifiedModule, 32)
    ANON_ENUM_KEY(int32_t, IgnoreSymbolVisibility, 128)
END_ANON_ENUM()

class WithScopeSymbol : public ScopeDsymbol
{
public:
    WithStatement* withstate;
    Dsymbol* search(const Loc& loc, Identifier* ident, int32_t flags = 8);
    WithScopeSymbol* isWithScopeSymbol();
    void accept(Visitor* v);
    ~WithScopeSymbol();
};

class ArrayScopeSymbol : public ScopeDsymbol
{
public:
    RootObject* arrayContent;
    Scope* sc;
    Dsymbol* search(const Loc& loc, Identifier* ident, int32_t flags = 0);
    ArrayScopeSymbol* isArrayScopeSymbol();
    void accept(Visitor* v);
    ~ArrayScopeSymbol();
};

class OverloadSet : public Dsymbol
{
public:
    Array<Dsymbol*> a;
    void push(Dsymbol* s);
    OverloadSet* isOverloadSet();
    const char* kind() const;
    void accept(Visitor* v);
    ~OverloadSet();
};

class ForwardingScopeDsymbol : public ScopeDsymbol
{
public:
    ScopeDsymbol* forward;
    Dsymbol* symtabInsert(Dsymbol* s);
    Dsymbol* symtabLookup(Dsymbol* s, Identifier* id);
    void importScope(Dsymbol* s, Prot protection);
    const char* kind() const;
    ForwardingScopeDsymbol* isForwardingScopeDsymbol();
    ~ForwardingScopeDsymbol();
};

class ExpressionDsymbol : public Dsymbol
{
public:
    Expression* exp;
    ExpressionDsymbol(Expression* exp);
    ExpressionDsymbol* isExpressionDsymbol();
};

class DsymbolTable : public RootObject
{
public:
    AssocArray<Identifier*, Dsymbol*> tab;
    Dsymbol* lookup(const Identifier* const ident);
    Dsymbol* update(Dsymbol* s);
    Dsymbol* insert(Dsymbol* s);
    Dsymbol* insert(const Identifier* const ident, Dsymbol* s);
    size_t length() const;
    DsymbolTable();
};

ENUM_CONSTANT_NUMERIC(bool, LOG, false)

extern void dsymbolSemantic(Dsymbol* dsym, Scope* sc);

ENUM_CONSTANT_NUMERIC(int32_t, IDX_NOTFOUND, 305419896)

extern Expression* isExpression(RootObject* o);

extern Dsymbol* isDsymbol(RootObject* o);

extern Type* isType(RootObject* o);

extern Tuple* isTuple(RootObject* o);

extern Parameter* isParameter(RootObject* o);

extern TemplateParameter* isTemplateParameter(RootObject* o);

extern bool isError(const RootObject* const o);

class Tuple : public RootObject
{
public:
    Array<RootObject*> objects;
    DYNCAST dyncast() const;
    const char* toChars() const;
    ~Tuple();
};

class TemplateDeclaration : public ScopeDsymbol
{
public:
    Array<TemplateParameter*>* parameters;
    Array<TemplateParameter*>* origParameters;
    Expression* constraint;
    void* instances;
    TemplateDeclaration* overnext;
    TemplateDeclaration* overroot;
    FuncDeclaration* funcroot;
    Dsymbol* onemember;
    bool literal;
    bool ismixin;
    bool isstatic;
    bool isTrivialAliasSeq;
    bool isTrivialAlias;
    bool deprecated_;
    Prot protection;
    int32_t inuse;
    TemplatePrevious* previous;
    Expression* lastConstraint;
    Array<Expression*> lastConstraintNegs;
    Array<RootObject*>* lastConstraintTiargs;
    Dsymbol* syntaxCopy(Dsymbol* _param_0);
    bool overloadInsert(Dsymbol* s);
    bool hasStaticCtorOrDtor();
    const char* kind() const;
    const char* toChars() const;
    const char* toCharsNoConstraints() const;
    const char* toCharsMaybeConstraints(bool includeConstraints) const;
    Prot prot();
    const char* getConstraintEvalError(const char*& tip);
    void formatParamsWithTiargs(Array<RootObject*>& tiargs, OutBuffer& buf);
    Scope* scopeForTemplateParameters(TemplateInstance* ti, Scope* sc);
    MATCH leastAsSpecialized(Scope* sc, TemplateDeclaration* td2, Array<Expression*>* fargs);
    RootObject* declareParameter(Scope* sc, TemplateParameter* tp, RootObject* o);
    TemplateDeclaration* isTemplateDeclaration();
    TemplateTupleParameter* isVariadic();
    bool isDeprecated() const;
    bool isOverloadable() const;
    void accept(Visitor* v);
    ~TemplateDeclaration();
};

class TypeDeduced : public Type
{
public:
    Type* tded;
    Array<Expression*> argexps;
    Array<Type*> tparams;
    void update(Expression* e, Type* tparam);
    void update(Type* tt, Expression* e, Type* tparam);
    MATCH matchAll(Type* tt);
    ~TypeDeduced();
};

class TemplateParameter : public ASTNode
{
public:
    Loc loc;
    Identifier* ident;
    bool dependent;
    virtual TemplateTypeParameter* isTemplateTypeParameter();
    virtual TemplateValueParameter* isTemplateValueParameter();
    virtual TemplateAliasParameter* isTemplateAliasParameter();
    virtual TemplateThisParameter* isTemplateThisParameter();
    virtual TemplateTupleParameter* isTemplateTupleParameter();
    virtual TemplateParameter* syntaxCopy() = 0;
    virtual bool declareParameter(Scope* sc) = 0;
    virtual void print(RootObject* oarg, RootObject* oded) = 0;
    virtual RootObject* specialization() = 0;
    virtual RootObject* defaultArg(Loc instLoc, Scope* sc) = 0;
    virtual bool hasDefaultArg() = 0;
    const char* toChars() const;
    DYNCAST dyncast() const;
    virtual RootObject* dummyArg() = 0;
    void accept(Visitor* v);
};

class TemplateTypeParameter : public TemplateParameter
{
public:
    Type* specType;
    Type* defaultType;
    TemplateTypeParameter* isTemplateTypeParameter();
    TemplateParameter* syntaxCopy();
    bool declareParameter(Scope* sc);
    void print(RootObject* oarg, RootObject* oded);
    RootObject* specialization();
    RootObject* defaultArg(Loc instLoc, Scope* sc);
    bool hasDefaultArg();
    RootObject* dummyArg();
    void accept(Visitor* v);
};

class TemplateThisParameter : public TemplateTypeParameter
{
public:
    TemplateThisParameter* isTemplateThisParameter();
    TemplateParameter* syntaxCopy();
    void accept(Visitor* v);
};

class TemplateValueParameter : public TemplateParameter
{
public:
    Type* valType;
    Expression* specValue;
    Expression* defaultValue;
    TemplateValueParameter* isTemplateValueParameter();
    TemplateParameter* syntaxCopy();
    bool declareParameter(Scope* sc);
    void print(RootObject* oarg, RootObject* oded);
    RootObject* specialization();
    RootObject* defaultArg(Loc instLoc, Scope* sc);
    bool hasDefaultArg();
    RootObject* dummyArg();
    void accept(Visitor* v);
};

class TemplateAliasParameter : public TemplateParameter
{
public:
    Type* specType;
    RootObject* specAlias;
    RootObject* defaultAlias;
    TemplateAliasParameter* isTemplateAliasParameter();
    TemplateParameter* syntaxCopy();
    bool declareParameter(Scope* sc);
    void print(RootObject* oarg, RootObject* oded);
    RootObject* specialization();
    RootObject* defaultArg(Loc instLoc, Scope* sc);
    bool hasDefaultArg();
    RootObject* dummyArg();
    void accept(Visitor* v);
};

class TemplateTupleParameter : public TemplateParameter
{
public:
    TemplateTupleParameter* isTemplateTupleParameter();
    TemplateParameter* syntaxCopy();
    bool declareParameter(Scope* sc);
    void print(RootObject* oarg, RootObject* oded);
    RootObject* specialization();
    RootObject* defaultArg(Loc instLoc, Scope* sc);
    bool hasDefaultArg();
    RootObject* dummyArg();
    void accept(Visitor* v);
};

class TemplateInstance : public ScopeDsymbol
{
public:
    Identifier* name;
    Array<RootObject*>* tiargs;
    Array<RootObject*> tdtypes;
    Array<Module*> importedModules;
    Dsymbol* tempdecl;
    Dsymbol* enclosing;
    Dsymbol* aliasdecl;
    TemplateInstance* inst;
    ScopeDsymbol* argsym;
    size_t hash;
    Array<Expression*>* fargs;
    Array<TemplateInstance*>* deferred;
    Module* memberOf;
    TemplateInstance* tinst;
    TemplateInstance* tnext;
    Module* minst;
    uint16_t _nest;
    uint8_t inuse;
    BEGIN_ENUM_NUMERIC(uint32_t, Flag, FLAG, flag)
        ENUM_KEY_NUMERIC(uint32_t, semantictiargsdone, 32768u, Flag, FLAG, flag, F)
        ENUM_KEY_NUMERIC(uint32_t, havetempdecl, 16384u, Flag, FLAG, flag, F)
        ENUM_KEY_NUMERIC(uint32_t, gagged, 8192u, Flag, FLAG, flag, F)
        ENUM_KEY_NUMERIC(uint32_t, available, 8191u, Flag, FLAG, flag, F)
    END_ENUM_NUMERIC(uint32_t, Flag, FLAG, flag)

    Dsymbol* syntaxCopy(Dsymbol* s);
    Dsymbol* toAlias();
    const char* kind() const;
    bool oneMember(Dsymbol** ps, Identifier* ident);
    const char* toChars() const;
    const char* toPrettyCharsHelper();
    void printInstantiationTrace();
    Identifier* getIdent();
    bool equalsx(TemplateInstance* ti);
    size_t toHash();
    bool isDiscardable();
    bool needsCodegen();
    TemplateInstance* isTemplateInstance();
    void accept(Visitor* v);
    ~TemplateInstance();
};

class TemplateMixin : public TemplateInstance
{
public:
    TypeQualified* tqual;
    Dsymbol* syntaxCopy(Dsymbol* s);
    const char* kind() const;
    bool oneMember(Dsymbol** ps, Identifier* ident);
    bool hasPointers();
    void setFieldOffset(AggregateDeclaration* ad, uint32_t* poffset, bool isunion);
    const char* toChars() const;
    TemplateMixin* isTemplateMixin();
    void accept(Visitor* v);
    ~TemplateMixin();
};

ENUM_CONSTANT_NUMERIC(bool, isBuildingCompiler, false)

extern void genCppHdrFiles(Array<Module*>& ms);

class ToCppBuffer : public Visitor
{
public:
    BEGIN_ENUM(EnumKind, ENUMKIND, enumkind)
        ENUM_KEY(int32_t, Int, 0, EnumKind, ENUMKIND, enumkind, EK)
        ENUM_KEY(int32_t, Numeric, 1, EnumKind, ENUMKIND, enumkind, EK)
        ENUM_KEY(int32_t, String, 2, EnumKind, ENUMKIND, enumkind, EK)
        ENUM_KEY(int32_t, Enum, 3, EnumKind, ENUMKIND, enumkind, EK)
        ENUM_KEY(int32_t, Other, 4, EnumKind, ENUMKIND, enumkind, EK)
    END_ENUM(EnumKind, ENUMKIND, enumkind)

    typedef ASTCodegen AST;
    void* visited;
    void* forwarded;
    OutBuffer* fwdbuf;
    OutBuffer* checkbuf;
    OutBuffer* donebuf;
    OutBuffer* buf;
    AggregateDeclaration* adparent;
    ClassDeclaration* cdparent;
    TemplateDeclaration* tdparent;
    Identifier* ident;
    LINK linkage;
    bool forwardedAA;
    Type** origType;
    bool hasReal;
    bool hasDefaultEnum;
    bool hasNumericEnum;
    bool hasTypedEnum;
    bool hasAnonEnum;
    bool hasAnonNumericEnum;
    bool hasNumericConstant;
    bool hasTypedConstant;
    bool printIgnored;
    ToCppBuffer(OutBuffer* checkbuf, OutBuffer* fwdbuf, OutBuffer* donebuf, OutBuffer* buf);
    EnumKind getEnumKind(Type* type);
    void writeEnumTypeName(Type* type);
    void writeDeclEnd();
    void visit(Dsymbol* s);
    void visit(Import* i);
    void visit(AttribDeclaration* pd);
    void visit(LinkDeclaration* ld);
    void visit(CPPMangleDeclaration* md);
    void visit(Module* m);
    void visit(FuncDeclaration* fd);
    void visit(UnitTestDeclaration* utd);
    void visit(VarDeclaration* vd);
    void visit(TypeInfoDeclaration* tid);
    void visit(AliasDeclaration* ad);
    void visit(Nspace* ns);
    void visit(CPPNamespaceDeclaration* ns);
    void handleNspace(Identifier* name, Array<Dsymbol*>* members);
    void visit(AnonDeclaration* ad);
    bool memberField(VarDeclaration* vd);
    void visit(StructDeclaration* sd);
    void pushAlignToBuffer(uint32_t alignment);
    void popAlignToBuffer(uint32_t alignment);
    void includeSymbol(Dsymbol* ds);
    void visit(ClassDeclaration* cd);
    void visit(EnumDeclaration* ed);
    void visit(EnumMember* em);
    void typeToBuffer(Type* t, Identifier* ident);
    void visit(Type* t);
    void visit(TypeIdentifier* t);
    void visit(TypeBasic* t);
    void visit(TypePointer* t);
    void visit(TypeSArray* t);
    void visit(TypeAArray* t);
    void visit(TypeFunction* tf);
    void enumToBuffer(EnumDeclaration* ed);
    void visit(TypeEnum* t);
    void visit(TypeStruct* t);
    void visit(TypeDArray* t);
    void visitTi(TemplateInstance* ti);
    void visit(TemplateDeclaration* td);
    void visit(TypeClass* t);
    void funcToBuffer(TypeFunction* tf, FuncDeclaration* fd);
    void visit(Parameter* p);
    void visit(Expression* e);
    void visit(NullExp* e);
    void visit(ArrayLiteralExp* e);
    void visit(StringExp* e);
    void visit(RealExp* e);
    void visit(IntegerExp* e);
    void visitInteger(dinteger_t v, Type* t);
    void visit(StructLiteralExp* sle);
};

class DebugSymbol : public Dsymbol
{
public:
    uint32_t level;
    Dsymbol* syntaxCopy(Dsymbol* s);
    const char* toChars() const;
    void addMember(Scope* sc, ScopeDsymbol* sds);
    const char* kind() const;
    DebugSymbol* isDebugSymbol();
    void accept(Visitor* v);
};

class VersionSymbol : public Dsymbol
{
public:
    uint32_t level;
    Dsymbol* syntaxCopy(Dsymbol* s);
    const char* toChars() const;
    void addMember(Scope* sc, ScopeDsymbol* sds);
    const char* kind() const;
    VersionSymbol* isVersionSymbol();
    void accept(Visitor* v);
};

ENUM_CONSTANT_NUMERIC(bool, LOGSEMANTIC, false)

extern void expandTuples(Array<Expression*>* exps);

struct UnionExp
{
    Expression* exp();
    Expression* copy();
    #pragma pack(push, 8)
    union __AnonStruct__u
    {
        char exp[40LLU];
        char integerexp[48LLU];
        char errorexp[40LLU];
        char realexp[64LLU];
        char complexexp[80LLU];
        char symoffexp[72LLU];
        char stringexp[60LLU];
        char arrayliteralexp[57LLU];
        char assocarrayliteralexp[57LLU];
        char structliteralexp[95LLU];
        char nullexp[40LLU];
        char dotvarexp[65LLU];
        char addrexp[56LLU];
        char indexexp[82LLU];
        char sliceexp[83LLU];
        char vectorexp[69LLU];
        __AnonStruct__u() {}
    };
    #pragma pack(pop)

    // Ignoring var u alignment 8
    __AnonStruct__u u;
    UnionExp() {}
};

BEGIN_ENUM_NUMERIC(uint8_t, OwnedBy, OWNEDBY, ownedby)
    ENUM_KEY_NUMERIC(uint8_t, code, 0u, OwnedBy, OWNEDBY, ownedby, OB)
    ENUM_KEY_NUMERIC(uint8_t, ctfe, 1u, OwnedBy, OWNEDBY, ownedby, OB)
    ENUM_KEY_NUMERIC(uint8_t, cache, 2u, OwnedBy, OWNEDBY, ownedby, OB)
END_ENUM_NUMERIC(uint8_t, OwnedBy, OWNEDBY, ownedby)

ENUM_CONSTANT_NUMERIC(int32_t, WANTvalue, 0)

ENUM_CONSTANT_NUMERIC(int32_t, WANTexpand, 1)

class IntegerExp : public Expression
{
public:
    dinteger_t value;
    static IntegerExp* create(Loc loc, dinteger_t value, Type* type);
    static void emplace(UnionExp* pue, Loc loc, dinteger_t value, Type* type);
    bool equals(const RootObject* const o) const;
    dinteger_t toInteger();
    _d_real toReal();
    _d_real toImaginary();
    complex_t toComplex();
    bool isBool(bool result);
    Expression* toLvalue(Scope* sc, Expression* e);
    void accept(Visitor* v);
    dinteger_t getInteger();
    void setInteger(dinteger_t value);
    Expression* syntaxCopy();
    static IntegerExp* createBool(bool b);
};

class ErrorExp : public Expression
{
public:
    static ErrorExp* get();
    Expression* toLvalue(Scope* sc, Expression* e);
    void accept(Visitor* v);
    static ErrorExp* errorexp;
};

class VoidInitExp : public Expression
{
public:
    VarDeclaration* var;
    const char* toChars() const;
    void accept(Visitor* v);
};

class RealExp : public Expression
{
public:
    _d_real value;
    static RealExp* create(Loc loc, _d_real value, Type* type);
    static void emplace(UnionExp* pue, Loc loc, _d_real value, Type* type);
    bool equals(const RootObject* const o) const;
    dinteger_t toInteger();
    uinteger_t toUInteger();
    _d_real toReal();
    _d_real toImaginary();
    complex_t toComplex();
    bool isBool(bool result);
    void accept(Visitor* v);
};

class ComplexExp : public Expression
{
public:
    complex_t value;
    static ComplexExp* create(Loc loc, complex_t value, Type* type);
    static void emplace(UnionExp* pue, Loc loc, complex_t value, Type* type);
    bool equals(const RootObject* const o) const;
    dinteger_t toInteger();
    uinteger_t toUInteger();
    _d_real toReal();
    _d_real toImaginary();
    complex_t toComplex();
    bool isBool(bool result);
    void accept(Visitor* v);
};

class IdentifierExp : public Expression
{
public:
    Identifier* ident;
    static IdentifierExp* create(Loc loc, Identifier* ident);
    bool isLvalue();
    Expression* toLvalue(Scope* sc, Expression* e);
    void accept(Visitor* v);
};

class DollarExp : public IdentifierExp
{
public:
    void accept(Visitor* v);
};

class DsymbolExp : public Expression
{
public:
    Dsymbol* s;
    bool hasOverloads;
    bool isLvalue();
    Expression* toLvalue(Scope* sc, Expression* e);
    void accept(Visitor* v);
};

class ThisExp : public Expression
{
public:
    VarDeclaration* var;
    ThisExp(const Loc& loc, const TOK tok);
    Expression* syntaxCopy();
    bool isBool(bool result);
    bool isLvalue();
    Expression* toLvalue(Scope* sc, Expression* e);
    void accept(Visitor* v);
};

class SuperExp : public ThisExp
{
public:
    void accept(Visitor* v);
};

class NullExp : public Expression
{
public:
    bool equals(const RootObject* const o) const;
    bool isBool(bool result);
    StringExp* toStringExp();
    void accept(Visitor* v);
};

class StringExp : public Expression
{
public:
    union
    {
        char* string;
        char16_t* wstring;
        char32_t* dstring;
    };
    size_t len;
    uint8_t sz;
    uint8_t committed;
    ENUM_CONSTANT_NUMERIC(char, NoPostfix, 0u)

    char postfix;
    OwnedBy ownedByCtfe;
    static StringExp* create(Loc loc, char* s);
    static StringExp* create(Loc loc, void* string, size_t len);
    static void emplace(UnionExp* pue, Loc loc, char* s);
    bool equals(const RootObject* const o) const;
    size_t numberOfCodeUnits(int32_t tynto = 0) const;
    void writeTo(void* dest, bool zero, int32_t tyto = 0) const;
    char32_t getCodeUnit(size_t i) const;
    void setCodeUnit(size_t i, char32_t c);
    StringExp* toStringExp();
    StringExp* toUTF8(Scope* sc);
    int32_t compare(const StringExp* const se2) const;
    bool isBool(bool result);
    bool isLvalue();
    Expression* toLvalue(Scope* sc, Expression* e);
    Expression* modifiableLvalue(Scope* sc, Expression* e);
    uint32_t charAt(uinteger_t i) const;
    void accept(Visitor* v);
};

class TupleExp : public Expression
{
public:
    Expression* e0;
    Array<Expression*>* exps;
    static TupleExp* create(Loc loc, Array<Expression*>* exps);
    TupleExp* toTupleExp();
    Expression* syntaxCopy();
    bool equals(const RootObject* const o) const;
    void accept(Visitor* v);
};

class ArrayLiteralExp : public Expression
{
public:
    Expression* basis;
    Array<Expression*>* elements;
    OwnedBy ownedByCtfe;
    static ArrayLiteralExp* create(Loc loc, Array<Expression*>* elements);
    static void emplace(UnionExp* pue, Loc loc, Array<Expression*>* elements);
    Expression* syntaxCopy();
    bool equals(const RootObject* const o) const;
    Expression* getElement(size_t i);
    Expression* opIndex(size_t i);
    bool isBool(bool result);
    StringExp* toStringExp();
    void accept(Visitor* v);
};

class AssocArrayLiteralExp : public Expression
{
public:
    Array<Expression*>* keys;
    Array<Expression*>* values;
    OwnedBy ownedByCtfe;
    bool equals(const RootObject* const o) const;
    Expression* syntaxCopy();
    bool isBool(bool result);
    void accept(Visitor* v);
};

ENUM_CONSTANT_NUMERIC(int32_t, stageScrub, 1)

ENUM_CONSTANT_NUMERIC(int32_t, stageSearchPointers, 2)

ENUM_CONSTANT_NUMERIC(int32_t, stageOptimize, 4)

ENUM_CONSTANT_NUMERIC(int32_t, stageApply, 8)

ENUM_CONSTANT_NUMERIC(int32_t, stageInlineScan, 16)

ENUM_CONSTANT_NUMERIC(int32_t, stageToCBuffer, 32)

class StructLiteralExp : public Expression
{
public:
    StructDeclaration* sd;
    Array<Expression*>* elements;
    Type* stype;
    Symbol* sym;
    StructLiteralExp* origin;
    StructLiteralExp* inlinecopy;
    int32_t stageflags;
    bool useStaticInit;
    bool isOriginal;
    OwnedBy ownedByCtfe;
    static StructLiteralExp* create(Loc loc, StructDeclaration* sd, void* elements, Type* stype);
    bool equals(const RootObject* const o) const;
    Expression* syntaxCopy();
    Expression* getField(Type* type, uint32_t offset);
    int32_t getFieldIndex(Type* type, uint32_t offset);
    Expression* addDtorHook(Scope* sc);
    void accept(Visitor* v);
};

class TypeExp : public Expression
{
public:
    Expression* syntaxCopy();
    bool checkType();
    bool checkValue();
    void accept(Visitor* v);
};

class ScopeExp : public Expression
{
public:
    ScopeDsymbol* sds;
    Expression* syntaxCopy();
    bool checkType();
    bool checkValue();
    void accept(Visitor* v);
};

class TemplateExp : public Expression
{
public:
    TemplateDeclaration* td;
    FuncDeclaration* fd;
    bool isLvalue();
    Expression* toLvalue(Scope* sc, Expression* e);
    bool checkType();
    bool checkValue();
    void accept(Visitor* v);
};

class NewExp : public Expression
{
public:
    Expression* thisexp;
    Array<Expression*>* newargs;
    Type* newtype;
    Array<Expression*>* arguments;
    Expression* argprefix;
    CtorDeclaration* member;
    NewDeclaration* allocator;
    bool onstack;
    bool thrownew;
    static NewExp* create(Loc loc, Expression* thisexp, Array<Expression*>* newargs, Type* newtype, Array<Expression*>* arguments);
    Expression* syntaxCopy();
    void accept(Visitor* v);
};

class NewAnonClassExp : public Expression
{
public:
    Expression* thisexp;
    Array<Expression*>* newargs;
    ClassDeclaration* cd;
    Array<Expression*>* arguments;
    Expression* syntaxCopy();
    void accept(Visitor* v);
};

class SymbolExp : public Expression
{
public:
    Declaration* var;
    Dsymbol* originalScope;
    bool hasOverloads;
    void accept(Visitor* v);
};

class SymOffExp : public SymbolExp
{
public:
    dinteger_t offset;
    bool isBool(bool result);
    void accept(Visitor* v);
};

class VarExp : public SymbolExp
{
public:
    bool delegateWasExtracted;
    static VarExp* create(Loc loc, Declaration* var, bool hasOverloads = true);
    bool equals(const RootObject* const o) const;
    Modifiable checkModifiable(Scope* sc, int32_t flag);
    bool isLvalue();
    Expression* toLvalue(Scope* sc, Expression* e);
    Expression* modifiableLvalue(Scope* sc, Expression* e);
    void accept(Visitor* v);
    Expression* syntaxCopy();
};

class OverExp : public Expression
{
public:
    OverloadSet* vars;
    bool isLvalue();
    Expression* toLvalue(Scope* sc, Expression* e);
    void accept(Visitor* v);
};

class FuncExp : public Expression
{
public:
    FuncLiteralDeclaration* fd;
    TemplateDeclaration* td;
    TOK tok;
    bool equals(const RootObject* const o) const;
    Expression* syntaxCopy();
    const char* toChars() const;
    bool checkType();
    bool checkValue();
    void accept(Visitor* v);
};

class DeclarationExp : public Expression
{
public:
    Dsymbol* declaration;
    Expression* syntaxCopy();
    bool hasCode();
    void accept(Visitor* v);
};

class TypeidExp : public Expression
{
public:
    RootObject* obj;
    Expression* syntaxCopy();
    void accept(Visitor* v);
};

class TraitsExp : public Expression
{
public:
    Identifier* ident;
    Array<RootObject*>* args;
    Expression* syntaxCopy();
    void accept(Visitor* v);
};

class HaltExp : public Expression
{
public:
    void accept(Visitor* v);
};

class IsExp : public Expression
{
public:
    Type* targ;
    Identifier* id;
    Type* tspec;
    Array<TemplateParameter*>* parameters;
    TOK tok;
    TOK tok2;
    Expression* syntaxCopy();
    void accept(Visitor* v);
};

class UnaExp : public Expression
{
public:
    Expression* e1;
    Type* att1;
    Expression* syntaxCopy();
    Expression* incompatibleTypes();
    void setNoderefOperand();
    Expression* resolveLoc(const Loc& loc, Scope* sc);
    void accept(Visitor* v);
};

typedef UnionExp(*fp_t)(Loc& loc, Type , Expression , Expression );

typedef bool(*fp2_t)(Loc& loc, TOK , Expression , Expression );

class BinExp : public Expression
{
public:
    Expression* e1;
    Expression* e2;
    Type* att1;
    Type* att2;
    Expression* syntaxCopy();
    Expression* incompatibleTypes();
    void setNoderefOperands();
    Expression* reorderSettingAAElem(Scope* sc);
    void accept(Visitor* v);
};

class BinAssignExp : public BinExp
{
public:
    bool isLvalue();
    Expression* toLvalue(Scope* sc, Expression* ex);
    Expression* modifiableLvalue(Scope* sc, Expression* e);
    void accept(Visitor* v);
};

class CompileExp : public Expression
{
public:
    Array<Expression*>* exps;
    Expression* syntaxCopy();
    bool equals(const RootObject* const o) const;
    void accept(Visitor* v);
};

class ImportExp : public UnaExp
{
public:
    void accept(Visitor* v);
};

class AssertExp : public UnaExp
{
public:
    Expression* msg;
    Expression* syntaxCopy();
    void accept(Visitor* v);
};

class DotIdExp : public UnaExp
{
public:
    Identifier* ident;
    bool noderef;
    bool wantsym;
    static DotIdExp* create(Loc loc, Expression* e, Identifier* ident);
    void accept(Visitor* v);
};

class DotTemplateExp : public UnaExp
{
public:
    TemplateDeclaration* td;
    void accept(Visitor* v);
};

class DotVarExp : public UnaExp
{
public:
    Declaration* var;
    bool hasOverloads;
    Modifiable checkModifiable(Scope* sc, int32_t flag);
    bool isLvalue();
    Expression* toLvalue(Scope* sc, Expression* e);
    Expression* modifiableLvalue(Scope* sc, Expression* e);
    void accept(Visitor* v);
};

class DotTemplateInstanceExp : public UnaExp
{
public:
    TemplateInstance* ti;
    Expression* syntaxCopy();
    bool findTempDecl(Scope* sc);
    void accept(Visitor* v);
};

class DelegateExp : public UnaExp
{
public:
    FuncDeclaration* func;
    bool hasOverloads;
    VarDeclaration* vthis2;
    void accept(Visitor* v);
};

class DotTypeExp : public UnaExp
{
public:
    Dsymbol* sym;
    void accept(Visitor* v);
};

class CallExp : public UnaExp
{
public:
    Array<Expression*>* arguments;
    FuncDeclaration* f;
    bool directcall;
    bool inDebugStatement;
    VarDeclaration* vthis2;
    static CallExp* create(Loc loc, Expression* e, Array<Expression*>* exps);
    static CallExp* create(Loc loc, Expression* e);
    static CallExp* create(Loc loc, Expression* e, Expression* earg1);
    static CallExp* create(Loc loc, FuncDeclaration* fd, Expression* earg1);
    Expression* syntaxCopy();
    bool isLvalue();
    Expression* toLvalue(Scope* sc, Expression* e);
    Expression* addDtorHook(Scope* sc);
    void accept(Visitor* v);
};

class AddrExp : public UnaExp
{
public:
    void accept(Visitor* v);
};

class PtrExp : public UnaExp
{
public:
    Modifiable checkModifiable(Scope* sc, int32_t flag);
    bool isLvalue();
    Expression* toLvalue(Scope* sc, Expression* e);
    Expression* modifiableLvalue(Scope* sc, Expression* e);
    void accept(Visitor* v);
};

class NegExp : public UnaExp
{
public:
    void accept(Visitor* v);
};

class UAddExp : public UnaExp
{
public:
    void accept(Visitor* v);
};

class ComExp : public UnaExp
{
public:
    void accept(Visitor* v);
};

class NotExp : public UnaExp
{
public:
    void accept(Visitor* v);
};

class DeleteExp : public UnaExp
{
public:
    bool isRAII;
    Expression* toBoolean(Scope* sc);
    void accept(Visitor* v);
};

class CastExp : public UnaExp
{
public:
    Type* to;
    uint8_t mod;
    Expression* syntaxCopy();
    Expression* addDtorHook(Scope* sc);
    void accept(Visitor* v);
};

class VectorExp : public UnaExp
{
public:
    TypeVector* to;
    uint32_t dim;
    OwnedBy ownedByCtfe;
    static VectorExp* create(Loc loc, Expression* e, Type* t);
    static void emplace(UnionExp* pue, Loc loc, Expression* e, Type* type);
    Expression* syntaxCopy();
    void accept(Visitor* v);
};

class VectorArrayExp : public UnaExp
{
public:
    bool isLvalue();
    Expression* toLvalue(Scope* sc, Expression* e);
    void accept(Visitor* v);
};

class SliceExp : public UnaExp
{
public:
    Expression* upr;
    Expression* lwr;
    VarDeclaration* lengthVar;
    bool upperIsInBounds;
    bool lowerIsLessThanUpper;
    bool arrayop;
    Expression* syntaxCopy();
    Modifiable checkModifiable(Scope* sc, int32_t flag);
    bool isLvalue();
    Expression* toLvalue(Scope* sc, Expression* e);
    Expression* modifiableLvalue(Scope* sc, Expression* e);
    bool isBool(bool result);
    void accept(Visitor* v);
};

class ArrayLengthExp : public UnaExp
{
public:
    void accept(Visitor* v);
};

class ArrayExp : public UnaExp
{
public:
    Array<Expression*>* arguments;
    size_t currentDimension;
    VarDeclaration* lengthVar;
    Expression* syntaxCopy();
    bool isLvalue();
    Expression* toLvalue(Scope* sc, Expression* e);
    void accept(Visitor* v);
};

class DotExp : public BinExp
{
public:
    void accept(Visitor* v);
};

class CommaExp : public BinExp
{
public:
    bool isGenerated;
    bool allowCommaExp;
    Modifiable checkModifiable(Scope* sc, int32_t flag);
    bool isLvalue();
    Expression* toLvalue(Scope* sc, Expression* e);
    Expression* modifiableLvalue(Scope* sc, Expression* e);
    bool isBool(bool result);
    Expression* toBoolean(Scope* sc);
    Expression* addDtorHook(Scope* sc);
    void accept(Visitor* v);
    static void allow(Expression* exp);
};

class IntervalExp : public Expression
{
public:
    Expression* lwr;
    Expression* upr;
    Expression* syntaxCopy();
    void accept(Visitor* v);
};

class DelegatePtrExp : public UnaExp
{
public:
    bool isLvalue();
    Expression* toLvalue(Scope* sc, Expression* e);
    Expression* modifiableLvalue(Scope* sc, Expression* e);
    void accept(Visitor* v);
};

class DelegateFuncptrExp : public UnaExp
{
public:
    bool isLvalue();
    Expression* toLvalue(Scope* sc, Expression* e);
    Expression* modifiableLvalue(Scope* sc, Expression* e);
    void accept(Visitor* v);
};

class IndexExp : public BinExp
{
public:
    VarDeclaration* lengthVar;
    bool modifiable;
    bool indexIsInBounds;
    Expression* syntaxCopy();
    Modifiable checkModifiable(Scope* sc, int32_t flag);
    bool isLvalue();
    Expression* toLvalue(Scope* sc, Expression* e);
    Expression* modifiableLvalue(Scope* sc, Expression* e);
    void accept(Visitor* v);
};

class PostExp : public BinExp
{
public:
    void accept(Visitor* v);
};

class PreExp : public UnaExp
{
public:
    void accept(Visitor* v);
};

BEGIN_ENUM(MemorySet, MEMORYSET, memoryset)
    ENUM_KEY(int32_t, none, 0, MemorySet, MEMORYSET, memoryset, MS)
    ENUM_KEY(int32_t, blockAssign, 1, MemorySet, MEMORYSET, memoryset, MS)
    ENUM_KEY(int32_t, referenceInit, 2, MemorySet, MEMORYSET, memoryset, MS)
END_ENUM(MemorySet, MEMORYSET, memoryset)

class AssignExp : public BinExp
{
public:
    MemorySet memset;
    AssignExp(const Loc& loc, TOK tok, Expression* e1, Expression* e2);
    bool isLvalue();
    Expression* toLvalue(Scope* sc, Expression* ex);
    Expression* toBoolean(Scope* sc);
    void accept(Visitor* v);
};

class ConstructExp : public AssignExp
{
public:
    void accept(Visitor* v);
};

class BlitExp : public AssignExp
{
public:
    void accept(Visitor* v);
};

class AddAssignExp : public BinAssignExp
{
public:
    void accept(Visitor* v);
};

class MinAssignExp : public BinAssignExp
{
public:
    void accept(Visitor* v);
};

class MulAssignExp : public BinAssignExp
{
public:
    void accept(Visitor* v);
};

class DivAssignExp : public BinAssignExp
{
public:
    void accept(Visitor* v);
};

class ModAssignExp : public BinAssignExp
{
public:
    void accept(Visitor* v);
};

class AndAssignExp : public BinAssignExp
{
public:
    void accept(Visitor* v);
};

class OrAssignExp : public BinAssignExp
{
public:
    void accept(Visitor* v);
};

class XorAssignExp : public BinAssignExp
{
public:
    void accept(Visitor* v);
};

class PowAssignExp : public BinAssignExp
{
public:
    void accept(Visitor* v);
};

class ShlAssignExp : public BinAssignExp
{
public:
    void accept(Visitor* v);
};

class ShrAssignExp : public BinAssignExp
{
public:
    void accept(Visitor* v);
};

class UshrAssignExp : public BinAssignExp
{
public:
    void accept(Visitor* v);
};

class CatAssignExp : public BinAssignExp
{
public:
    void accept(Visitor* v);
};

class CatElemAssignExp : public CatAssignExp
{
public:
    void accept(Visitor* v);
};

class CatDcharAssignExp : public CatAssignExp
{
public:
    void accept(Visitor* v);
};

class AddExp : public BinExp
{
public:
    void accept(Visitor* v);
};

class MinExp : public BinExp
{
public:
    void accept(Visitor* v);
};

class CatExp : public BinExp
{
public:
    Expression* resolveLoc(const Loc& loc, Scope* sc);
    void accept(Visitor* v);
};

class MulExp : public BinExp
{
public:
    void accept(Visitor* v);
};

class DivExp : public BinExp
{
public:
    void accept(Visitor* v);
};

class ModExp : public BinExp
{
public:
    void accept(Visitor* v);
};

class PowExp : public BinExp
{
public:
    void accept(Visitor* v);
};

class ShlExp : public BinExp
{
public:
    void accept(Visitor* v);
};

class ShrExp : public BinExp
{
public:
    void accept(Visitor* v);
};

class UshrExp : public BinExp
{
public:
    void accept(Visitor* v);
};

class AndExp : public BinExp
{
public:
    void accept(Visitor* v);
};

class OrExp : public BinExp
{
public:
    void accept(Visitor* v);
};

class XorExp : public BinExp
{
public:
    void accept(Visitor* v);
};

class LogicalExp : public BinExp
{
public:
    Expression* toBoolean(Scope* sc);
    void accept(Visitor* v);
};

class CmpExp : public BinExp
{
public:
    void accept(Visitor* v);
};

class InExp : public BinExp
{
public:
    void accept(Visitor* v);
};

class RemoveExp : public BinExp
{
public:
    void accept(Visitor* v);
};

class EqualExp : public BinExp
{
public:
    void accept(Visitor* v);
};

class IdentityExp : public BinExp
{
public:
    void accept(Visitor* v);
};

class CondExp : public BinExp
{
public:
    Expression* econd;
    Expression* syntaxCopy();
    Modifiable checkModifiable(Scope* sc, int32_t flag);
    bool isLvalue();
    Expression* toLvalue(Scope* sc, Expression* ex);
    Expression* modifiableLvalue(Scope* sc, Expression* e);
    Expression* toBoolean(Scope* sc);
    void hookDtors(Scope* sc);
    void accept(Visitor* v);
};

class DefaultInitExp : public Expression
{
public:
    void accept(Visitor* v);
};

class FileInitExp : public DefaultInitExp
{
public:
    Expression* resolveLoc(const Loc& loc, Scope* sc);
    void accept(Visitor* v);
};

class LineInitExp : public DefaultInitExp
{
public:
    Expression* resolveLoc(const Loc& loc, Scope* sc);
    void accept(Visitor* v);
};

class ModuleInitExp : public DefaultInitExp
{
public:
    Expression* resolveLoc(const Loc& loc, Scope* sc);
    void accept(Visitor* v);
};

class FuncInitExp : public DefaultInitExp
{
public:
    Expression* resolveLoc(const Loc& loc, Scope* sc);
    void accept(Visitor* v);
};

class PrettyFuncInitExp : public DefaultInitExp
{
public:
    Expression* resolveLoc(const Loc& loc, Scope* sc);
    void accept(Visitor* v);
};

class ObjcClassReferenceExp : public Expression
{
public:
    ClassDeclaration* classDeclaration;
    void accept(Visitor* v);
};

ENUM_CONSTANT_NUMERIC(bool, LOGSEMANTIC, false)

extern Expression* resolveProperties(Scope* sc, Expression* e);

extern Expression* expressionSemantic(Expression* e, Scope* sc);

BEGIN_ENUM(ILS, ILS, ils)
    ENUM_KEY(int32_t, uninitialized, 0, ILS, ILS, ils, ILS)
    ENUM_KEY(int32_t, no, 1, ILS, ILS, ils, ILS)
    ENUM_KEY(int32_t, yes, 2, ILS, ILS, ils, ILS)
END_ENUM(ILS, ILS, ils)

class NrvoWalker : public StatementRewriteWalker
{
public:
    FuncDeclaration* fd;
    Scope* sc;
    void visit(ReturnStatement* s);
    void visit(TryFinallyStatement* s);
};

BEGIN_ENUM_NUMERIC(uint32_t, FUNCFLAG, FUNCFLAG, funcflag)
    ENUM_KEY_NUMERIC(uint32_t, purityInprocess, 1u, FUNCFLAG, FUNCFLAG, funcflag, FUNCFLAG)
    ENUM_KEY_NUMERIC(uint32_t, safetyInprocess, 2u, FUNCFLAG, FUNCFLAG, funcflag, FUNCFLAG)
    ENUM_KEY_NUMERIC(uint32_t, nothrowInprocess, 4u, FUNCFLAG, FUNCFLAG, funcflag, FUNCFLAG)
    ENUM_KEY_NUMERIC(uint32_t, nogcInprocess, 8u, FUNCFLAG, FUNCFLAG, funcflag, FUNCFLAG)
    ENUM_KEY_NUMERIC(uint32_t, returnInprocess, 16u, FUNCFLAG, FUNCFLAG, funcflag, FUNCFLAG)
    ENUM_KEY_NUMERIC(uint32_t, inlineScanned, 32u, FUNCFLAG, FUNCFLAG, funcflag, FUNCFLAG)
    ENUM_KEY_NUMERIC(uint32_t, inferScope, 64u, FUNCFLAG, FUNCFLAG, funcflag, FUNCFLAG)
    ENUM_KEY_NUMERIC(uint32_t, hasCatches, 128u, FUNCFLAG, FUNCFLAG, funcflag, FUNCFLAG)
    ENUM_KEY_NUMERIC(uint32_t, compileTimeOnly, 256u, FUNCFLAG, FUNCFLAG, funcflag, FUNCFLAG)
    ENUM_KEY_NUMERIC(uint32_t, printf, 512u, FUNCFLAG, FUNCFLAG, funcflag, FUNCFLAG)
    ENUM_KEY_NUMERIC(uint32_t, scanf, 1024u, FUNCFLAG, FUNCFLAG, funcflag, FUNCFLAG)
END_ENUM_NUMERIC(uint32_t, FUNCFLAG, FUNCFLAG, funcflag)

struct Ensure
{
    Identifier* id;
    Statement* ensure;
    Ensure syntaxCopy();
    static Array<Ensure>* arraySyntaxCopy(Array<Ensure>* a);
    Ensure() : id(), ensure() {}
};

class FuncDeclaration : public Declaration
{
public:
    Array<Statement*>* frequires;
    Array<Ensure>* fensures;
    Statement* frequire;
    Statement* fensure;
    Statement* fbody;
    Array<FuncDeclaration*> foverrides;
    FuncDeclaration* fdrequire;
    FuncDeclaration* fdensure;
    Array<Expression*>* fdrequireParams;
    Array<Expression*>* fdensureParams;
    char* mangleString;
    VarDeclaration* vresult;
    LabelDsymbol* returnLabel;
    DsymbolTable* localsymtab;
    VarDeclaration* vthis;
    bool isThis2;
    VarDeclaration* v_arguments;
    VarDeclaration* v_argptr;
    Array<VarDeclaration*>* parameters;
    DsymbolTable* labtab;
    Dsymbol* overnext;
    FuncDeclaration* overnext0;
    Loc endloc;
    int32_t vtblIndex;
    bool naked;
    bool generated;
    bool hasAlwaysInlines;
    uint8_t isCrtCtorDtor;
    ILS inlineStatusStmt;
    ILS inlineStatusExp;
    PINLINE inlining;
    int32_t inlineNest;
    bool eh_none;
    bool semantic3Errors;
    ForeachStatement* fes;
    BaseClass* interfaceVirtual;
    bool introducing;
    Type* tintro;
    bool inferRetType;
    StorageClass storage_class2;
    int32_t hasReturnExp;
    bool nrvo_can;
    VarDeclaration* nrvo_var;
    Symbol* shidden;
    Array<ReturnStatement*>* returns;
    Array<GotoStatement*>* gotos;
    BUILTIN builtin;
    int32_t tookAddressOf;
    bool requiresClosure;
    Array<VarDeclaration*> closureVars;
    Array<VarDeclaration*> outerVars;
    Array<FuncDeclaration*> siblingCallers;
    Array<FuncDeclaration*>* inlinedNestedCallees;
    uint32_t flags;
    ObjcFuncDeclaration objc;
    static FuncDeclaration* create(const Loc& loc, const Loc& endloc, Identifier* id, StorageClass storage_class, Type* type);
    Dsymbol* syntaxCopy(Dsymbol* s);
    bool functionSemantic();
    bool functionSemantic3();
    bool equals(const RootObject* const o) const;
    int32_t overrides(FuncDeclaration* fd);
    int32_t findVtblIndex(Array<Dsymbol*>* vtbl, int32_t dim);
    BaseClass* overrideInterface();
    bool overloadInsert(Dsymbol* s);
    bool inUnittest();
    MATCH leastAsSpecialized(FuncDeclaration* g);
    LabelDsymbol* searchLabel(Identifier* ident);
    int32_t getLevel(FuncDeclaration* fd, int32_t intypeof);
    int32_t getLevelAndCheck(const Loc& loc, Scope* sc, FuncDeclaration* fd, Declaration* decl);
    ENUM_CONSTANT_NUMERIC(int32_t, LevelError, -2)

    const char* toPrettyChars(bool QualifyTypes = false);
    const char* toFullSignature();
    bool isMain() const;
    bool isCMain() const;
    bool isWinMain() const;
    bool isDllMain() const;
    bool isRtInit() const;
    bool isExport() const;
    bool isImportedSymbol() const;
    bool isCodeseg() const;
    bool isOverloadable() const;
    bool isAbstract();
    bool canInferAttributes(Scope* sc);
    void initInferAttributes();
    PURE isPure();
    PURE isPureBypassingInference();
    bool isSafe();
    bool isSafeBypassingInference();
    bool isTrusted();
    bool isNogc();
    bool isNogcBypassingInference();
    bool isTypeIsolatedIndirect(Type* t);
    virtual bool isNested() const;
    AggregateDeclaration* isThis();
    bool needThis();
    bool isVirtualMethod();
    virtual bool isVirtual() const;
    bool isFinalFunc() const;
    virtual bool addPreInvariant();
    virtual bool addPostInvariant();
    const char* kind() const;
    bool isUnique() const;
    bool needsClosure();
    bool hasNestedFrameRefs();
    static bool needsFensure(FuncDeclaration* fd);
    void buildEnsureRequire();
    ParameterList getParameterList();
    static FuncDeclaration* genCfunc(Array<Parameter*>* fparams, Type* treturn, const char* name, StorageClass stc = 0);
    static FuncDeclaration* genCfunc(Array<Parameter*>* fparams, Type* treturn, Identifier* id, StorageClass stc = 0);
    bool checkNrvo();
    FuncDeclaration* isFuncDeclaration();
    virtual FuncDeclaration* toAliasFunc();
    void accept(Visitor* v);
    ~FuncDeclaration();
};

BEGIN_ENUM_NUMERIC(uint8_t, FuncResolveFlag, FUNCRESOLVEFLAG, funcresolveflag)
    ENUM_KEY_NUMERIC(uint8_t, standard, 0u, FuncResolveFlag, FUNCRESOLVEFLAG, funcresolveflag, FRF)
    ENUM_KEY_NUMERIC(uint8_t, quiet, 1u, FuncResolveFlag, FUNCRESOLVEFLAG, funcresolveflag, FRF)
    ENUM_KEY_NUMERIC(uint8_t, overloadOnly, 2u, FuncResolveFlag, FUNCRESOLVEFLAG, funcresolveflag, FRF)
END_ENUM_NUMERIC(uint8_t, FuncResolveFlag, FUNCRESOLVEFLAG, funcresolveflag)

class FuncAliasDeclaration : public FuncDeclaration
{
public:
    FuncDeclaration* funcalias;
    bool hasOverloads;
    FuncAliasDeclaration* isFuncAliasDeclaration();
    const char* kind() const;
    FuncDeclaration* toAliasFunc();
    void accept(Visitor* v);
    ~FuncAliasDeclaration();
};

class FuncLiteralDeclaration : public FuncDeclaration
{
public:
    TOK tok;
    Type* treq;
    bool deferToObj;
    Dsymbol* syntaxCopy(Dsymbol* s);
    bool isNested() const;
    AggregateDeclaration* isThis();
    bool isVirtual() const;
    bool addPreInvariant();
    bool addPostInvariant();
    void modifyReturns(Scope* sc, Type* tret);
    FuncLiteralDeclaration* isFuncLiteralDeclaration();
    const char* kind() const;
    const char* toPrettyChars(bool QualifyTypes = false);
    void accept(Visitor* v);
    ~FuncLiteralDeclaration();
};

class CtorDeclaration : public FuncDeclaration
{
public:
    bool isCpCtor;
    Dsymbol* syntaxCopy(Dsymbol* s);
    const char* kind() const;
    const char* toChars() const;
    bool isVirtual() const;
    bool addPreInvariant();
    bool addPostInvariant();
    CtorDeclaration* isCtorDeclaration();
    void accept(Visitor* v);
    ~CtorDeclaration();
};

class PostBlitDeclaration : public FuncDeclaration
{
public:
    Dsymbol* syntaxCopy(Dsymbol* s);
    bool isVirtual() const;
    bool addPreInvariant();
    bool addPostInvariant();
    bool overloadInsert(Dsymbol* s);
    PostBlitDeclaration* isPostBlitDeclaration();
    void accept(Visitor* v);
    ~PostBlitDeclaration();
};

class DtorDeclaration : public FuncDeclaration
{
public:
    Dsymbol* syntaxCopy(Dsymbol* s);
    const char* kind() const;
    const char* toChars() const;
    bool isVirtual() const;
    bool addPreInvariant();
    bool addPostInvariant();
    bool overloadInsert(Dsymbol* s);
    DtorDeclaration* isDtorDeclaration();
    void accept(Visitor* v);
    ~DtorDeclaration();
};

class StaticCtorDeclaration : public FuncDeclaration
{
public:
    Dsymbol* syntaxCopy(Dsymbol* s);
    AggregateDeclaration* isThis();
    bool isVirtual() const;
    bool addPreInvariant();
    bool addPostInvariant();
    bool hasStaticCtorOrDtor();
    StaticCtorDeclaration* isStaticCtorDeclaration();
    void accept(Visitor* v);
    ~StaticCtorDeclaration();
};

class SharedStaticCtorDeclaration : public StaticCtorDeclaration
{
public:
    Dsymbol* syntaxCopy(Dsymbol* s);
    SharedStaticCtorDeclaration* isSharedStaticCtorDeclaration();
    void accept(Visitor* v);
    ~SharedStaticCtorDeclaration();
};

class StaticDtorDeclaration : public FuncDeclaration
{
public:
    VarDeclaration* vgate;
    Dsymbol* syntaxCopy(Dsymbol* s);
    AggregateDeclaration* isThis();
    bool isVirtual() const;
    bool hasStaticCtorOrDtor();
    bool addPreInvariant();
    bool addPostInvariant();
    StaticDtorDeclaration* isStaticDtorDeclaration();
    void accept(Visitor* v);
    ~StaticDtorDeclaration();
};

class SharedStaticDtorDeclaration : public StaticDtorDeclaration
{
public:
    Dsymbol* syntaxCopy(Dsymbol* s);
    SharedStaticDtorDeclaration* isSharedStaticDtorDeclaration();
    void accept(Visitor* v);
    ~SharedStaticDtorDeclaration();
};

class InvariantDeclaration : public FuncDeclaration
{
public:
    Dsymbol* syntaxCopy(Dsymbol* s);
    bool isVirtual() const;
    bool addPreInvariant();
    bool addPostInvariant();
    InvariantDeclaration* isInvariantDeclaration();
    void accept(Visitor* v);
    ~InvariantDeclaration();
};

class UnitTestDeclaration : public FuncDeclaration
{
public:
    char* codedoc;
    Array<FuncDeclaration*> deferredNested;
    Dsymbol* syntaxCopy(Dsymbol* s);
    AggregateDeclaration* isThis();
    bool isVirtual() const;
    bool addPreInvariant();
    bool addPostInvariant();
    UnitTestDeclaration* isUnitTestDeclaration();
    void accept(Visitor* v);
    ~UnitTestDeclaration();
};

class NewDeclaration : public FuncDeclaration
{
public:
    ParameterList parameterList;
    Dsymbol* syntaxCopy(Dsymbol* s);
    const char* kind() const;
    bool isVirtual() const;
    bool addPreInvariant();
    bool addPostInvariant();
    NewDeclaration* isNewDeclaration();
    void accept(Visitor* v);
    ~NewDeclaration();
};

class ObjcGlue
{
public:
    static void initialize();
};

ENUM_CONSTANT_NUMERIC(int32_t, TEST_EMIT_ALL, 0)

extern void genhdrfile(Module* m);

extern void moduleToBuffer(OutBuffer* buf, Module* m);

extern const char* parametersTypeToChars(ParameterList pl);

BEGIN_ENUM(NeedInterpret, NEEDINTERPRET, needinterpret)
    ENUM_KEY(int32_t, INITnointerpret, 0, NeedInterpret, NEEDINTERPRET, needinterpret, NI)
    ENUM_KEY(int32_t, INITinterpret, 1, NeedInterpret, NEEDINTERPRET, needinterpret, NI)
END_ENUM(NeedInterpret, NEEDINTERPRET, needinterpret)

BEGIN_ENUM_NUMERIC(uint8_t, InitKind, INITKIND, initkind)
    ENUM_KEY_NUMERIC(uint8_t, void_, 0u, InitKind, INITKIND, initkind, IK)
    ENUM_KEY_NUMERIC(uint8_t, error, 1u, InitKind, INITKIND, initkind, IK)
    ENUM_KEY_NUMERIC(uint8_t, struct_, 2u, InitKind, INITKIND, initkind, IK)
    ENUM_KEY_NUMERIC(uint8_t, array, 3u, InitKind, INITKIND, initkind, IK)
    ENUM_KEY_NUMERIC(uint8_t, exp, 4u, InitKind, INITKIND, initkind, IK)
END_ENUM_NUMERIC(uint8_t, InitKind, INITKIND, initkind)

class Initializer : public ASTNode
{
public:
    Loc loc;
    InitKind kind;
    const char* toChars() const;
    ErrorInitializer* isErrorInitializer();
    VoidInitializer* isVoidInitializer();
    StructInitializer* isStructInitializer();
    ArrayInitializer* isArrayInitializer();
    ExpInitializer* isExpInitializer();
    void accept(Visitor* v);
};

class VoidInitializer : public Initializer
{
public:
    Type* type;
    void accept(Visitor* v);
};

class ErrorInitializer : public Initializer
{
public:
    void accept(Visitor* v);
};

class StructInitializer : public Initializer
{
public:
    Array<Identifier*> field;
    Array<Initializer*> value;
    void accept(Visitor* v);
    ~StructInitializer();
};

class ArrayInitializer : public Initializer
{
public:
    Array<Expression*> index;
    Array<Initializer*> value;
    uint32_t dim;
    Type* type;
    bool sem;
    bool isAssociativeArray() const;
    void accept(Visitor* v);
    ~ArrayInitializer();
};

class ExpInitializer : public Initializer
{
public:
    bool expandTuples;
    Expression* exp;
    void accept(Visitor* v);
};

extern bool hasNonConstPointers(Expression* e);

extern Initializer* initializerSemantic(Initializer* init, Scope* sc, Type* t, NeedInterpret needInterpret);

extern Expression* initializerToExpression(Initializer* init, Type* itype);

ENUM_CONSTANT_NUMERIC(int32_t, COST_MAX, 250)

extern void json_generate(OutBuffer* buf, Array<Module*>* modules);

ENUM_CONSTANT(const char*, jsonFieldNames, "`compilerInfo`, `buildInfo`, `modules`, `semantics`")

extern JsonFieldFlags tryParseJsonField(const char* fieldName);

ENUM_CONSTANT_NUMERIC(bool, LOG, false)

extern Library* LibElf_factory();

extern "C" void printInternalFailure(_IO_FILE* stream);

extern void generateJson(Array<Module*>* modules);

typedef int32_t(*MainFunc)(DArray< DArray< char > > args);

extern "C" DArray< DArray< char > > rt_options;

extern "C" int32_t main(int32_t argc, char** argv);

extern "C" int32_t _Dmain(DArray< DArray< char > > _param_0);

extern "C" void printGlobalConfigs(_IO_FILE* stream);

extern "C" void flushMixins();

ENUM_CONSTANT_NUMERIC(int32_t, LOGDOTEXP, 0)

ENUM_CONSTANT_NUMERIC(int32_t, LOGDEFAULTINIT, 0)

ENUM_CONSTANT_NUMERIC(uint64_t, SIZE_INVALID, 18446744073709551615LLU)

BEGIN_ENUM(ENUMTY, ENUMTY, enumty)
    ENUM_KEY(int32_t, Tarray, 0, ENUMTY, ENUMTY, enumty, ENUMTY)
    ENUM_KEY(int32_t, Tsarray, 1, ENUMTY, ENUMTY, enumty, ENUMTY)
    ENUM_KEY(int32_t, Taarray, 2, ENUMTY, ENUMTY, enumty, ENUMTY)
    ENUM_KEY(int32_t, Tpointer, 3, ENUMTY, ENUMTY, enumty, ENUMTY)
    ENUM_KEY(int32_t, Treference, 4, ENUMTY, ENUMTY, enumty, ENUMTY)
    ENUM_KEY(int32_t, Tfunction, 5, ENUMTY, ENUMTY, enumty, ENUMTY)
    ENUM_KEY(int32_t, Tident, 6, ENUMTY, ENUMTY, enumty, ENUMTY)
    ENUM_KEY(int32_t, Tclass, 7, ENUMTY, ENUMTY, enumty, ENUMTY)
    ENUM_KEY(int32_t, Tstruct, 8, ENUMTY, ENUMTY, enumty, ENUMTY)
    ENUM_KEY(int32_t, Tenum, 9, ENUMTY, ENUMTY, enumty, ENUMTY)
    ENUM_KEY(int32_t, Tdelegate, 10, ENUMTY, ENUMTY, enumty, ENUMTY)
    ENUM_KEY(int32_t, Tnone, 11, ENUMTY, ENUMTY, enumty, ENUMTY)
    ENUM_KEY(int32_t, Tvoid, 12, ENUMTY, ENUMTY, enumty, ENUMTY)
    ENUM_KEY(int32_t, Tint8, 13, ENUMTY, ENUMTY, enumty, ENUMTY)
    ENUM_KEY(int32_t, Tuns8, 14, ENUMTY, ENUMTY, enumty, ENUMTY)
    ENUM_KEY(int32_t, Tint16, 15, ENUMTY, ENUMTY, enumty, ENUMTY)
    ENUM_KEY(int32_t, Tuns16, 16, ENUMTY, ENUMTY, enumty, ENUMTY)
    ENUM_KEY(int32_t, Tint32, 17, ENUMTY, ENUMTY, enumty, ENUMTY)
    ENUM_KEY(int32_t, Tuns32, 18, ENUMTY, ENUMTY, enumty, ENUMTY)
    ENUM_KEY(int32_t, Tint64, 19, ENUMTY, ENUMTY, enumty, ENUMTY)
    ENUM_KEY(int32_t, Tuns64, 20, ENUMTY, ENUMTY, enumty, ENUMTY)
    ENUM_KEY(int32_t, Tfloat32, 21, ENUMTY, ENUMTY, enumty, ENUMTY)
    ENUM_KEY(int32_t, Tfloat64, 22, ENUMTY, ENUMTY, enumty, ENUMTY)
    ENUM_KEY(int32_t, Tfloat80, 23, ENUMTY, ENUMTY, enumty, ENUMTY)
    ENUM_KEY(int32_t, Timaginary32, 24, ENUMTY, ENUMTY, enumty, ENUMTY)
    ENUM_KEY(int32_t, Timaginary64, 25, ENUMTY, ENUMTY, enumty, ENUMTY)
    ENUM_KEY(int32_t, Timaginary80, 26, ENUMTY, ENUMTY, enumty, ENUMTY)
    ENUM_KEY(int32_t, Tcomplex32, 27, ENUMTY, ENUMTY, enumty, ENUMTY)
    ENUM_KEY(int32_t, Tcomplex64, 28, ENUMTY, ENUMTY, enumty, ENUMTY)
    ENUM_KEY(int32_t, Tcomplex80, 29, ENUMTY, ENUMTY, enumty, ENUMTY)
    ENUM_KEY(int32_t, Tbool, 30, ENUMTY, ENUMTY, enumty, ENUMTY)
    ENUM_KEY(int32_t, Tchar, 31, ENUMTY, ENUMTY, enumty, ENUMTY)
    ENUM_KEY(int32_t, Twchar, 32, ENUMTY, ENUMTY, enumty, ENUMTY)
    ENUM_KEY(int32_t, Tdchar, 33, ENUMTY, ENUMTY, enumty, ENUMTY)
    ENUM_KEY(int32_t, Terror, 34, ENUMTY, ENUMTY, enumty, ENUMTY)
    ENUM_KEY(int32_t, Tinstance, 35, ENUMTY, ENUMTY, enumty, ENUMTY)
    ENUM_KEY(int32_t, Ttypeof, 36, ENUMTY, ENUMTY, enumty, ENUMTY)
    ENUM_KEY(int32_t, Ttuple, 37, ENUMTY, ENUMTY, enumty, ENUMTY)
    ENUM_KEY(int32_t, Tslice, 38, ENUMTY, ENUMTY, enumty, ENUMTY)
    ENUM_KEY(int32_t, Treturn, 39, ENUMTY, ENUMTY, enumty, ENUMTY)
    ENUM_KEY(int32_t, Tnull, 40, ENUMTY, ENUMTY, enumty, ENUMTY)
    ENUM_KEY(int32_t, Tvector, 41, ENUMTY, ENUMTY, enumty, ENUMTY)
    ENUM_KEY(int32_t, Tint128, 42, ENUMTY, ENUMTY, enumty, ENUMTY)
    ENUM_KEY(int32_t, Tuns128, 43, ENUMTY, ENUMTY, enumty, ENUMTY)
    ENUM_KEY(int32_t, Ttraits, 44, ENUMTY, ENUMTY, enumty, ENUMTY)
    ENUM_KEY(int32_t, Tmixin, 45, ENUMTY, ENUMTY, enumty, ENUMTY)
    ENUM_KEY(int32_t, TMAX, 46, ENUMTY, ENUMTY, enumty, ENUMTY)
END_ENUM(ENUMTY, ENUMTY, enumty)

typedef uint8_t TY;

BEGIN_ENUM(MODFlags, MODFLAGS, modflags)
    ENUM_KEY(int32_t, const_, 1, MODFlags, MODFLAGS, modflags, MODF)
    ENUM_KEY(int32_t, immutable_, 4, MODFlags, MODFLAGS, modflags, MODF)
    ENUM_KEY(int32_t, shared_, 2, MODFlags, MODFLAGS, modflags, MODF)
    ENUM_KEY(int32_t, wild, 8, MODFlags, MODFLAGS, modflags, MODF)
    ENUM_KEY(int32_t, wildconst, 9, MODFlags, MODFLAGS, modflags, MODF)
    ENUM_KEY(int32_t, mutable, 16, MODFlags, MODFLAGS, modflags, MODF)
END_ENUM(MODFlags, MODFLAGS, modflags)

typedef uint8_t MOD;

BEGIN_ENUM(DotExpFlag, DOTEXPFLAG, dotexpflag)
    ENUM_KEY(int32_t, gag, 1, DotExpFlag, DOTEXPFLAG, dotexpflag, DEF)
    ENUM_KEY(int32_t, noDeref, 2, DotExpFlag, DOTEXPFLAG, dotexpflag, DEF)
END_ENUM(DotExpFlag, DOTEXPFLAG, dotexpflag)

class TypeError : public Type
{
public:
    const char* kind() const;
    Type* syntaxCopy();
    d_uns64 size(const Loc& loc);
    Expression* defaultInitLiteral(const Loc& loc);
    void accept(Visitor* v);
};

class TypeNext : public Type
{
public:
    Type* next;
    void checkDeprecated(const Loc& loc, Scope* sc);
    int32_t hasWild() const;
    Type* nextOf();
    Type* makeConst();
    Type* makeImmutable();
    Type* makeShared();
    Type* makeSharedConst();
    Type* makeWild();
    Type* makeWildConst();
    Type* makeSharedWild();
    Type* makeSharedWildConst();
    Type* makeMutable();
    MATCH constConv(Type* to);
    uint8_t deduceWild(Type* t, bool isRef);
    void transitive();
    void accept(Visitor* v);
};

class TypeBasic : public Type
{
public:
    char* dstring;
    uint32_t flags;
    const char* kind() const;
    Type* syntaxCopy();
    d_uns64 size(const Loc& loc) /* const */;
    uint32_t alignsize();
    bool isintegral();
    bool isfloating() /* const */;
    bool isreal() /* const */;
    bool isimaginary() /* const */;
    bool iscomplex() /* const */;
    bool isscalar() /* const */;
    bool isunsigned() /* const */;
    MATCH implicitConvTo(Type* to);
    bool isZeroInit(const Loc& loc) /* const */;
    TypeBasic* isTypeBasic();
    void accept(Visitor* v);
};

class TypeVector : public Type
{
public:
    Type* basetype;
    static TypeVector* create(Type* basetype);
    const char* kind() const;
    Type* syntaxCopy();
    d_uns64 size(const Loc& loc);
    uint32_t alignsize();
    bool isintegral();
    bool isfloating();
    bool isscalar();
    bool isunsigned();
    bool isBoolean() /* const */;
    MATCH implicitConvTo(Type* to);
    Expression* defaultInitLiteral(const Loc& loc);
    TypeBasic* elementType();
    bool isZeroInit(const Loc& loc);
    void accept(Visitor* v);
};

class TypeArray : public TypeNext
{
public:
    void accept(Visitor* v);
};

class TypeSArray : public TypeArray
{
public:
    Expression* dim;
    const char* kind() const;
    Type* syntaxCopy();
    d_uns64 size(const Loc& loc);
    uint32_t alignsize();
    bool isString();
    bool isZeroInit(const Loc& loc);
    uint32_t alignment();
    MATCH constConv(Type* to);
    MATCH implicitConvTo(Type* to);
    Expression* defaultInitLiteral(const Loc& loc);
    bool hasPointers();
    bool needsDestruction();
    bool needsCopyOrPostblit();
    bool needsNested();
    void accept(Visitor* v);
};

class TypeDArray : public TypeArray
{
public:
    const char* kind() const;
    Type* syntaxCopy();
    d_uns64 size(const Loc& loc) /* const */;
    uint32_t alignsize() /* const */;
    bool isString();
    bool isZeroInit(const Loc& loc) /* const */;
    bool isBoolean() /* const */;
    MATCH implicitConvTo(Type* to);
    bool hasPointers() /* const */;
    void accept(Visitor* v);
};

class TypeAArray : public TypeArray
{
public:
    Type* index;
    Loc loc;
    static TypeAArray* create(Type* t, Type* index);
    const char* kind() const;
    Type* syntaxCopy();
    d_uns64 size(const Loc& loc) /* const */;
    bool isZeroInit(const Loc& loc) /* const */;
    bool isBoolean() /* const */;
    bool hasPointers() /* const */;
    MATCH implicitConvTo(Type* to);
    MATCH constConv(Type* to);
    void accept(Visitor* v);
};

class TypePointer : public TypeNext
{
public:
    static TypePointer* create(Type* t);
    const char* kind() const;
    Type* syntaxCopy();
    d_uns64 size(const Loc& loc) /* const */;
    MATCH implicitConvTo(Type* to);
    MATCH constConv(Type* to);
    bool isscalar() /* const */;
    bool isZeroInit(const Loc& loc) /* const */;
    bool hasPointers() /* const */;
    void accept(Visitor* v);
};

class TypeReference : public TypeNext
{
public:
    const char* kind() const;
    Type* syntaxCopy();
    d_uns64 size(const Loc& loc) /* const */;
    bool isZeroInit(const Loc& loc) /* const */;
    void accept(Visitor* v);
};

BEGIN_ENUM(RET, RET, ret)
    ENUM_KEY(int32_t, regs, 1, RET, RET, ret, RET)
    ENUM_KEY(int32_t, stack, 2, RET, RET, ret, RET)
END_ENUM(RET, RET, ret)

BEGIN_ENUM_NUMERIC(uint8_t, TRUST, TRUST, trust)
    ENUM_KEY_NUMERIC(uint8_t, default_, 0u, TRUST, TRUST, trust, TRUST)
    ENUM_KEY_NUMERIC(uint8_t, system, 1u, TRUST, TRUST, trust, TRUST)
    ENUM_KEY_NUMERIC(uint8_t, trusted, 2u, TRUST, TRUST, trust, TRUST)
    ENUM_KEY_NUMERIC(uint8_t, safe, 3u, TRUST, TRUST, trust, TRUST)
END_ENUM_NUMERIC(uint8_t, TRUST, TRUST, trust)

BEGIN_ENUM(TRUSTformat, TRUSTFORMAT, trustformat)
    ENUM_KEY(int32_t, TRUSTformatDefault, 0, TRUSTformat, TRUSTFORMAT, trustformat, TRUST)
    ENUM_KEY(int32_t, TRUSTformatSystem, 1, TRUSTformat, TRUSTFORMAT, trustformat, TRUST)
END_ENUM(TRUSTformat, TRUSTFORMAT, trustformat)

class TypeFunction : public TypeNext
{
public:
    ParameterList parameterList;
    BEGIN_ENUM_NUMERIC(uint32_t, FunctionFlag, FUNCTIONFLAG, functionflag)
        ENUM_KEY_NUMERIC(uint32_t, none, 0u, FunctionFlag, FUNCTIONFLAG, functionflag, FF)
        ENUM_KEY_NUMERIC(uint32_t, isnothrow, 1u, FunctionFlag, FUNCTIONFLAG, functionflag, FF)
        ENUM_KEY_NUMERIC(uint32_t, isnogc, 2u, FunctionFlag, FUNCTIONFLAG, functionflag, FF)
        ENUM_KEY_NUMERIC(uint32_t, isproperty, 4u, FunctionFlag, FUNCTIONFLAG, functionflag, FF)
        ENUM_KEY_NUMERIC(uint32_t, isref, 8u, FunctionFlag, FUNCTIONFLAG, functionflag, FF)
        ENUM_KEY_NUMERIC(uint32_t, isreturn, 16u, FunctionFlag, FUNCTIONFLAG, functionflag, FF)
        ENUM_KEY_NUMERIC(uint32_t, isscope, 32u, FunctionFlag, FUNCTIONFLAG, functionflag, FF)
        ENUM_KEY_NUMERIC(uint32_t, isreturninferred, 64u, FunctionFlag, FUNCTIONFLAG, functionflag, FF)
        ENUM_KEY_NUMERIC(uint32_t, isscopeinferred, 128u, FunctionFlag, FUNCTIONFLAG, functionflag, FF)
        ENUM_KEY_NUMERIC(uint32_t, islive, 256u, FunctionFlag, FUNCTIONFLAG, functionflag, FF)
        ENUM_KEY_NUMERIC(uint32_t, incomplete, 512u, FunctionFlag, FUNCTIONFLAG, functionflag, FF)
        ENUM_KEY_NUMERIC(uint32_t, inoutParam, 1024u, FunctionFlag, FUNCTIONFLAG, functionflag, FF)
        ENUM_KEY_NUMERIC(uint32_t, inoutQual, 2048u, FunctionFlag, FUNCTIONFLAG, functionflag, FF)
    END_ENUM_NUMERIC(uint32_t, FunctionFlag, FUNCTIONFLAG, functionflag)

    LINK linkage;
    FunctionFlag funcFlags;
    TRUST trust;
    PURE purity;
    int8_t inuse;
    Array<Expression*>* fargs;
    static TypeFunction* create(Array<Parameter*>* parameters, Type* treturn, uint8_t varargs, LINK linkage, StorageClass stc = 0);
    const char* kind() const;
    Type* syntaxCopy();
    void purityLevel();
    bool hasLazyParameters();
    bool isDstyleVariadic() const;
    bool parameterEscapes(Type* tthis, Parameter* p);
    StorageClass parameterStorageClass(Type* tthis, Parameter* p);
    Type* addStorageClass(StorageClass stc);
    Type* substWildTo(uint32_t _param_0);
    const char* getParamError(Expression* arg, Parameter* par);
    bool isnothrow() const;
    void isnothrow(bool v);
    bool isnogc() const;
    void isnogc(bool v);
    bool isproperty() const;
    void isproperty(bool v);
    bool isref() const;
    void isref(bool v);
    bool isreturn() const;
    void isreturn(bool v);
    bool isScopeQual() const;
    void isScopeQual(bool v);
    bool isreturninferred() const;
    void isreturninferred(bool v);
    bool isscopeinferred() const;
    void isscopeinferred(bool v);
    bool islive() const;
    void islive(bool v);
    bool incomplete() const;
    void incomplete(bool v);
    bool isInOutParam() const;
    void isInOutParam(bool v);
    bool isInOutQual() const;
    void isInOutQual(bool v);
    bool iswild() const;
    void accept(Visitor* v);
};

class TypeDelegate : public TypeNext
{
public:
    static TypeDelegate* create(Type* t);
    const char* kind() const;
    Type* syntaxCopy();
    Type* addStorageClass(StorageClass stc);
    d_uns64 size(const Loc& loc) /* const */;
    uint32_t alignsize() /* const */;
    MATCH implicitConvTo(Type* to);
    bool isZeroInit(const Loc& loc) /* const */;
    bool isBoolean() /* const */;
    bool hasPointers() /* const */;
    void accept(Visitor* v);
};

class TypeTraits : public Type
{
public:
    Loc loc;
    TraitsExp* exp;
    Dsymbol* sym;
    const char* kind() const;
    Type* syntaxCopy();
    Dsymbol* toDsymbol(Scope* sc);
    void accept(Visitor* v);
    d_uns64 size(const Loc& loc);
};

class TypeMixin : public Type
{
public:
    Loc loc;
    Array<Expression*>* exps;
    const char* kind() const;
    Type* syntaxCopy();
    Dsymbol* toDsymbol(Scope* sc);
    void accept(Visitor* v);
};

class TypeQualified : public Type
{
public:
    Loc loc;
    Array<RootObject*> idents;
    void syntaxCopyHelper(TypeQualified* t);
    void addIdent(Identifier* ident);
    void addInst(TemplateInstance* inst);
    void addIndex(RootObject* e);
    d_uns64 size(const Loc& loc);
    void accept(Visitor* v);
    ~TypeQualified();
};

class TypeIdentifier : public TypeQualified
{
public:
    Identifier* ident;
    Dsymbol* originalSymbol;
    const char* kind() const;
    Type* syntaxCopy();
    Dsymbol* toDsymbol(Scope* sc);
    void accept(Visitor* v);
    ~TypeIdentifier();
};

class TypeInstance : public TypeQualified
{
public:
    TemplateInstance* tempinst;
    const char* kind() const;
    Type* syntaxCopy();
    Dsymbol* toDsymbol(Scope* sc);
    void accept(Visitor* v);
    ~TypeInstance();
};

class TypeTypeof : public TypeQualified
{
public:
    Expression* exp;
    int32_t inuse;
    const char* kind() const;
    Type* syntaxCopy();
    Dsymbol* toDsymbol(Scope* sc);
    d_uns64 size(const Loc& loc);
    void accept(Visitor* v);
    ~TypeTypeof();
};

class TypeReturn : public TypeQualified
{
public:
    const char* kind() const;
    Type* syntaxCopy();
    Dsymbol* toDsymbol(Scope* sc);
    void accept(Visitor* v);
    ~TypeReturn();
};

BEGIN_ENUM(AliasThisRec, ALIASTHISREC, aliasthisrec)
    ENUM_KEY(int32_t, no, 0, AliasThisRec, ALIASTHISREC, aliasthisrec, ATR)
    ENUM_KEY(int32_t, yes, 1, AliasThisRec, ALIASTHISREC, aliasthisrec, ATR)
    ENUM_KEY(int32_t, fwdref, 2, AliasThisRec, ALIASTHISREC, aliasthisrec, ATR)
    ENUM_KEY(int32_t, typeMask, 3, AliasThisRec, ALIASTHISREC, aliasthisrec, ATR)
    ENUM_KEY(int32_t, tracing, 4, AliasThisRec, ALIASTHISREC, aliasthisrec, ATR)
    ENUM_KEY(int32_t, tracingDT, 8, AliasThisRec, ALIASTHISREC, aliasthisrec, ATR)
END_ENUM(AliasThisRec, ALIASTHISREC, aliasthisrec)

class TypeStruct : public Type
{
public:
    StructDeclaration* sym;
    AliasThisRec att;
    bool inuse;
    static TypeStruct* create(StructDeclaration* sym);
    const char* kind() const;
    d_uns64 size(const Loc& loc);
    uint32_t alignsize();
    Type* syntaxCopy();
    Dsymbol* toDsymbol(Scope* sc);
    uint32_t alignment();
    Expression* defaultInitLiteral(const Loc& loc);
    bool isZeroInit(const Loc& loc);
    bool isAssignable();
    bool isBoolean() /* const */;
    bool needsDestruction() /* const */;
    bool needsCopyOrPostblit();
    bool needsNested();
    bool hasPointers();
    bool hasVoidInitPointers();
    MATCH implicitConvTo(Type* to);
    MATCH constConv(Type* to);
    uint8_t deduceWild(Type* t, bool isRef);
    Type* toHeadMutable();
    void accept(Visitor* v);
};

class TypeEnum : public Type
{
public:
    EnumDeclaration* sym;
    const char* kind() const;
    Type* syntaxCopy();
    d_uns64 size(const Loc& loc);
    Type* memType(const Loc& loc);
    uint32_t alignsize();
    Dsymbol* toDsymbol(Scope* sc);
    bool isintegral();
    bool isfloating();
    bool isreal();
    bool isimaginary();
    bool iscomplex();
    bool isscalar();
    bool isunsigned();
    bool isBoolean();
    bool isString();
    bool isAssignable();
    bool needsDestruction();
    bool needsCopyOrPostblit();
    bool needsNested();
    MATCH implicitConvTo(Type* to);
    MATCH constConv(Type* to);
    bool isZeroInit(const Loc& loc);
    bool hasPointers();
    bool hasVoidInitPointers();
    Type* nextOf();
    void accept(Visitor* v);
};

class TypeClass : public Type
{
public:
    ClassDeclaration* sym;
    AliasThisRec att;
    CPPMANGLE cppmangle;
    const char* kind() const;
    d_uns64 size(const Loc& loc) /* const */;
    Type* syntaxCopy();
    Dsymbol* toDsymbol(Scope* sc);
    ClassDeclaration* isClassHandle();
    bool isBaseOf(Type* t, int32_t* poffset);
    MATCH implicitConvTo(Type* to);
    MATCH constConv(Type* to);
    uint8_t deduceWild(Type* t, bool isRef);
    Type* toHeadMutable();
    bool isZeroInit(const Loc& loc) /* const */;
    bool isscope() /* const */;
    bool isBoolean() /* const */;
    bool hasPointers() /* const */;
    void accept(Visitor* v);
};

class TypeTuple : public Type
{
public:
    static TypeTuple* empty;
    Array<Parameter*>* arguments;
    static TypeTuple* create(Array<Parameter*>* arguments);
    static TypeTuple* create();
    static TypeTuple* create(Type* t1);
    static TypeTuple* create(Type* t1, Type* t2);
    const char* kind() const;
    Type* syntaxCopy();
    bool equals(const RootObject* const o) const;
    void accept(Visitor* v);
};

class TypeSlice : public TypeNext
{
public:
    Expression* lwr;
    Expression* upr;
    const char* kind() const;
    Type* syntaxCopy();
    void accept(Visitor* v);
};

class TypeNull : public Type
{
public:
    const char* kind() const;
    Type* syntaxCopy();
    MATCH implicitConvTo(Type* to);
    bool hasPointers();
    bool isBoolean() /* const */;
    d_uns64 size(const Loc& loc) /* const */;
    void accept(Visitor* v);
};

class Parameter : public ASTNode
{
public:
    StorageClass storageClass;
    Type* type;
    Identifier* ident;
    Expression* defaultArg;
    UserAttributeDeclaration* userAttribDecl;
    static Parameter* create(StorageClass storageClass, Type* type, Identifier* ident, Expression* defaultArg, UserAttributeDeclaration* userAttribDecl);
    Parameter* syntaxCopy();
    Type* isLazyArray();
    bool isReference() const;
    DYNCAST dyncast() const;
    void accept(Visitor* v);
    static size_t dim(Array<Parameter*>* parameters);
    static Parameter* getNth(Array<Parameter*>* parameters, size_t nth);
    const char* toChars() const;
    bool isCovariant(bool returnByRef, const Parameter* const p, bool previewIn) const;
    BEGIN_ENUM(SR, SR, sr)
        ENUM_KEY(int32_t, None, 0, SR, SR, sr, SR)
        ENUM_KEY(int32_t, Scope, 1, SR, SR, sr, SR)
        ENUM_KEY(int32_t, ReturnScope, 2, SR, SR, sr, SR)
        ENUM_KEY(int32_t, Ref, 3, SR, SR, sr, SR)
        ENUM_KEY(int32_t, ReturnRef, 4, SR, SR, sr, SR)
        ENUM_KEY(int32_t, RefScope, 5, SR, SR, sr, SR)
        ENUM_KEY(int32_t, ReturnRef_Scope, 6, SR, SR, sr, SR)
        ENUM_KEY(int32_t, Ref_ReturnScope, 7, SR, SR, sr, SR)
    END_ENUM(SR, SR, sr)

};

extern AggregateDeclaration* isAggregate(Type* t);

class NOGCVisitor : public StoppableVisitor
{
public:
    FuncDeclaration* f;
    bool err;
    void doCond(Expression* exp);
    void visit(Expression* e);
    void visit(DeclarationExp* e);
    void visit(CallExp* e);
    void visit(ArrayLiteralExp* e);
    void visit(AssocArrayLiteralExp* e);
    void visit(NewExp* e);
    void visit(DeleteExp* e);
    void visit(IndexExp* e);
    void visit(AssignExp* e);
    void visit(CatAssignExp* e);
    void visit(CatExp* e);
};

class Nspace : public ScopeDsymbol
{
public:
    Expression* identExp;
    Dsymbol* syntaxCopy(Dsymbol* s);
    void addMember(Scope* sc, ScopeDsymbol* sds);
    void setScope(Scope* sc);
    Dsymbol* search(const Loc& loc, Identifier* ident, int32_t flags = 8);
    bool hasPointers();
    void setFieldOffset(AggregateDeclaration* ad, uint32_t* poffset, bool isunion);
    const char* kind() const;
    Nspace* isNspace();
    void accept(Visitor* v);
    ~Nspace();
};

typedef Array<ObNode*> ObNodes;

typedef StmtState<ObNode> StmtState;

BEGIN_ENUM_NUMERIC(uint8_t, ObType, OBTYPE, obtype)
    ENUM_KEY_NUMERIC(uint8_t, goto_, 0u, ObType, OBTYPE, obtype, OT)
    ENUM_KEY_NUMERIC(uint8_t, return_, 1u, ObType, OBTYPE, obtype, OT)
    ENUM_KEY_NUMERIC(uint8_t, retexp, 2u, ObType, OBTYPE, obtype, OT)
    ENUM_KEY_NUMERIC(uint8_t, throw_, 3u, ObType, OBTYPE, obtype, OT)
    ENUM_KEY_NUMERIC(uint8_t, exit, 4u, ObType, OBTYPE, obtype, OT)
    ENUM_KEY_NUMERIC(uint8_t, try_, 5u, ObType, OBTYPE, obtype, OT)
    ENUM_KEY_NUMERIC(uint8_t, finally_, 6u, ObType, OBTYPE, obtype, OT)
    ENUM_KEY_NUMERIC(uint8_t, fend, 7u, ObType, OBTYPE, obtype, OT)
END_ENUM_NUMERIC(uint8_t, ObType, OBTYPE, obtype)

BEGIN_ENUM_NUMERIC(uint8_t, PtrState, PTRSTATE, ptrstate)
    ENUM_KEY_NUMERIC(uint8_t, Initial, 0u, PtrState, PTRSTATE, ptrstate, PS)
    ENUM_KEY_NUMERIC(uint8_t, Undefined, 1u, PtrState, PTRSTATE, ptrstate, PS)
    ENUM_KEY_NUMERIC(uint8_t, Owner, 2u, PtrState, PTRSTATE, ptrstate, PS)
    ENUM_KEY_NUMERIC(uint8_t, Borrowed, 3u, PtrState, PTRSTATE, ptrstate, PS)
    ENUM_KEY_NUMERIC(uint8_t, Readonly, 4u, PtrState, PTRSTATE, ptrstate, PS)
END_ENUM_NUMERIC(uint8_t, PtrState, PTRSTATE, ptrstate)

class Objc
{
public:
    static void _init();
    static void deinitialize();
    virtual void setObjc(ClassDeclaration* cd) = 0;
    virtual void setObjc(InterfaceDeclaration* ) = 0;
    virtual void deprecate(InterfaceDeclaration* interfaceDeclaration) const = 0;
    virtual void setSelector(FuncDeclaration* , Scope* sc) = 0;
    virtual void validateSelector(FuncDeclaration* fd) = 0;
    virtual void checkLinkage(FuncDeclaration* fd) = 0;
    virtual bool isVirtual(const FuncDeclaration* const fd) const = 0;
    virtual ClassDeclaration* getParent(FuncDeclaration* fd, ClassDeclaration* cd) const = 0;
    virtual void addToClassMethodList(FuncDeclaration* fd, ClassDeclaration* cd) const = 0;
    virtual AggregateDeclaration* isThis(FuncDeclaration* funcDeclaration) const = 0;
    virtual VarDeclaration* createSelectorParameter(FuncDeclaration* fd, Scope* sc) const = 0;
    virtual void setMetaclass(InterfaceDeclaration* interfaceDeclaration, Scope* sc) const = 0;
    virtual void setMetaclass(ClassDeclaration* classDeclaration, Scope* sc) const = 0;
    virtual ClassDeclaration* getRuntimeMetaclass(ClassDeclaration* classDeclaration) const = 0;
    virtual void addSymbols(AttribDeclaration* attribDeclaration, Array<ClassDeclaration*>* classes, Array<ClassDeclaration*>* categories) const = 0;
    virtual void addSymbols(ClassDeclaration* classDeclaration, Array<ClassDeclaration*>* classes, Array<ClassDeclaration*>* categories) const = 0;
    virtual void checkOffsetof(Expression* expression, AggregateDeclaration* aggregateDeclaration) const = 0;
    virtual void checkTupleof(Expression* expression, TypeClass* type) const = 0;
};

BEGIN_ENUM(ParseStatementFlags, PARSESTATEMENTFLAGS, parsestatementflags)
    ENUM_KEY(int32_t, semi, 1, ParseStatementFlags, PARSESTATEMENTFLAGS, parsestatementflags, PSF)
    ENUM_KEY(int32_t, scope_, 2, ParseStatementFlags, PARSESTATEMENTFLAGS, parsestatementflags, PSF)
    ENUM_KEY(int32_t, curly, 4, ParseStatementFlags, PARSESTATEMENTFLAGS, parsestatementflags, PSF)
    ENUM_KEY(int32_t, curlyScope, 8, ParseStatementFlags, PARSESTATEMENTFLAGS, parsestatementflags, PSF)
    ENUM_KEY(int32_t, semiOk, 16, ParseStatementFlags, PARSESTATEMENTFLAGS, parsestatementflags, PSF)
END_ENUM(ParseStatementFlags, PARSESTATEMENTFLAGS, parsestatementflags)

BEGIN_ENUM(PREC, PREC, prec)
    ENUM_KEY(int32_t, zero, 0, PREC, PREC, prec, PREC)
    ENUM_KEY(int32_t, expr, 1, PREC, PREC, prec, PREC)
    ENUM_KEY(int32_t, assign, 2, PREC, PREC, prec, PREC)
    ENUM_KEY(int32_t, cond, 3, PREC, PREC, prec, PREC)
    ENUM_KEY(int32_t, oror, 4, PREC, PREC, prec, PREC)
    ENUM_KEY(int32_t, andand, 5, PREC, PREC, prec, PREC)
    ENUM_KEY(int32_t, or, 6, PREC, PREC, prec, PREC)
    ENUM_KEY(int32_t, xor, 7, PREC, PREC, prec, PREC)
    ENUM_KEY(int32_t, and, 8, PREC, PREC, prec, PREC)
    ENUM_KEY(int32_t, equal, 9, PREC, PREC, prec, PREC)
    ENUM_KEY(int32_t, rel, 10, PREC, PREC, prec, PREC)
    ENUM_KEY(int32_t, shift, 11, PREC, PREC, prec, PREC)
    ENUM_KEY(int32_t, add, 12, PREC, PREC, prec, PREC)
    ENUM_KEY(int32_t, mul, 13, PREC, PREC, prec, PREC)
    ENUM_KEY(int32_t, pow, 14, PREC, PREC, prec, PREC)
    ENUM_KEY(int32_t, unary, 15, PREC, PREC, prec, PREC)
    ENUM_KEY(int32_t, primary, 16, PREC, PREC, prec, PREC)
END_ENUM(PREC, PREC, prec)

class PostorderStatementVisitor : public StoppableVisitor
{
public:
    StoppableVisitor* v;
    bool doCond(Statement* s);
    bool applyTo(Statement* s);
    void visit(Statement* s);
    void visit(PeelStatement* s);
    void visit(CompoundStatement* s);
    void visit(UnrolledLoopStatement* s);
    void visit(ScopeStatement* s);
    void visit(WhileStatement* s);
    void visit(DoStatement* s);
    void visit(ForStatement* s);
    void visit(ForeachStatement* s);
    void visit(ForeachRangeStatement* s);
    void visit(IfStatement* s);
    void visit(PragmaStatement* s);
    void visit(SwitchStatement* s);
    void visit(CaseStatement* s);
    void visit(DefaultStatement* s);
    void visit(SynchronizedStatement* s);
    void visit(WithStatement* s);
    void visit(TryCatchStatement* s);
    void visit(TryFinallyStatement* s);
    void visit(ScopeGuardStatement* s);
    void visit(DebugStatement* s);
    void visit(LabelStatement* s);
};

ENUM_CONSTANT_NUMERIC(bool, LOG, false)

ENUM_CONSTANT_NUMERIC(bool, LOG, false)

extern void semantic2(Dsymbol* dsym, Scope* sc);

ENUM_CONSTANT_NUMERIC(bool, LOG, false)

extern void semantic3(Dsymbol* dsym, Scope* sc);

extern bool isTrivialExp(Expression* e);

extern bool hasSideEffect(Expression* e);

BEGIN_ENUM_NUMERIC(uint8_t, STMT, STMT, stmt)
    ENUM_KEY_NUMERIC(uint8_t, Error, 0u, STMT, STMT, stmt, STMT)
    ENUM_KEY_NUMERIC(uint8_t, Peel, 1u, STMT, STMT, stmt, STMT)
    ENUM_KEY_NUMERIC(uint8_t, Exp, 2u, STMT, STMT, stmt, STMT)
    ENUM_KEY_NUMERIC(uint8_t, DtorExp, 3u, STMT, STMT, stmt, STMT)
    ENUM_KEY_NUMERIC(uint8_t, Compile, 4u, STMT, STMT, stmt, STMT)
    ENUM_KEY_NUMERIC(uint8_t, Compound, 5u, STMT, STMT, stmt, STMT)
    ENUM_KEY_NUMERIC(uint8_t, CompoundDeclaration, 6u, STMT, STMT, stmt, STMT)
    ENUM_KEY_NUMERIC(uint8_t, CompoundAsm, 7u, STMT, STMT, stmt, STMT)
    ENUM_KEY_NUMERIC(uint8_t, UnrolledLoop, 8u, STMT, STMT, stmt, STMT)
    ENUM_KEY_NUMERIC(uint8_t, Scope, 9u, STMT, STMT, stmt, STMT)
    ENUM_KEY_NUMERIC(uint8_t, Forwarding, 10u, STMT, STMT, stmt, STMT)
    ENUM_KEY_NUMERIC(uint8_t, While, 11u, STMT, STMT, stmt, STMT)
    ENUM_KEY_NUMERIC(uint8_t, Do, 12u, STMT, STMT, stmt, STMT)
    ENUM_KEY_NUMERIC(uint8_t, For, 13u, STMT, STMT, stmt, STMT)
    ENUM_KEY_NUMERIC(uint8_t, Foreach, 14u, STMT, STMT, stmt, STMT)
    ENUM_KEY_NUMERIC(uint8_t, ForeachRange, 15u, STMT, STMT, stmt, STMT)
    ENUM_KEY_NUMERIC(uint8_t, If, 16u, STMT, STMT, stmt, STMT)
    ENUM_KEY_NUMERIC(uint8_t, Conditional, 17u, STMT, STMT, stmt, STMT)
    ENUM_KEY_NUMERIC(uint8_t, StaticForeach, 18u, STMT, STMT, stmt, STMT)
    ENUM_KEY_NUMERIC(uint8_t, Pragma, 19u, STMT, STMT, stmt, STMT)
    ENUM_KEY_NUMERIC(uint8_t, StaticAssert, 20u, STMT, STMT, stmt, STMT)
    ENUM_KEY_NUMERIC(uint8_t, Switch, 21u, STMT, STMT, stmt, STMT)
    ENUM_KEY_NUMERIC(uint8_t, Case, 22u, STMT, STMT, stmt, STMT)
    ENUM_KEY_NUMERIC(uint8_t, CaseRange, 23u, STMT, STMT, stmt, STMT)
    ENUM_KEY_NUMERIC(uint8_t, Default, 24u, STMT, STMT, stmt, STMT)
    ENUM_KEY_NUMERIC(uint8_t, GotoDefault, 25u, STMT, STMT, stmt, STMT)
    ENUM_KEY_NUMERIC(uint8_t, GotoCase, 26u, STMT, STMT, stmt, STMT)
    ENUM_KEY_NUMERIC(uint8_t, SwitchError, 27u, STMT, STMT, stmt, STMT)
    ENUM_KEY_NUMERIC(uint8_t, Return, 28u, STMT, STMT, stmt, STMT)
    ENUM_KEY_NUMERIC(uint8_t, Break, 29u, STMT, STMT, stmt, STMT)
    ENUM_KEY_NUMERIC(uint8_t, Continue, 30u, STMT, STMT, stmt, STMT)
    ENUM_KEY_NUMERIC(uint8_t, Synchronized, 31u, STMT, STMT, stmt, STMT)
    ENUM_KEY_NUMERIC(uint8_t, With, 32u, STMT, STMT, stmt, STMT)
    ENUM_KEY_NUMERIC(uint8_t, TryCatch, 33u, STMT, STMT, stmt, STMT)
    ENUM_KEY_NUMERIC(uint8_t, TryFinally, 34u, STMT, STMT, stmt, STMT)
    ENUM_KEY_NUMERIC(uint8_t, ScopeGuard, 35u, STMT, STMT, stmt, STMT)
    ENUM_KEY_NUMERIC(uint8_t, Throw, 36u, STMT, STMT, stmt, STMT)
    ENUM_KEY_NUMERIC(uint8_t, Debug, 37u, STMT, STMT, stmt, STMT)
    ENUM_KEY_NUMERIC(uint8_t, Goto, 38u, STMT, STMT, stmt, STMT)
    ENUM_KEY_NUMERIC(uint8_t, Label, 39u, STMT, STMT, stmt, STMT)
    ENUM_KEY_NUMERIC(uint8_t, Asm, 40u, STMT, STMT, stmt, STMT)
    ENUM_KEY_NUMERIC(uint8_t, InlineAsm, 41u, STMT, STMT, stmt, STMT)
    ENUM_KEY_NUMERIC(uint8_t, GccAsm, 42u, STMT, STMT, stmt, STMT)
    ENUM_KEY_NUMERIC(uint8_t, Import, 43u, STMT, STMT, stmt, STMT)
END_ENUM_NUMERIC(uint8_t, STMT, STMT, stmt)

class Statement : public ASTNode
{
public:
    Loc loc;
    STMT stmt;
    DYNCAST dyncast() const;
    virtual Statement* syntaxCopy();
    static Array<Statement*>* arraySyntaxCopy(Array<Statement*>* a);
    const char* toChars() const;
    void error(const char* format, ...);
    void warning(const char* format, ...);
    void deprecation(const char* format, ...);
    virtual Statement* getRelatedLabeled();
    virtual bool hasBreak() const;
    virtual bool hasContinue() const;
    bool usesEH();
    bool comeFrom();
    bool hasCode();
    virtual Statement* scopeCode(Scope* sc, Statement** sentry, Statement** sexception, Statement** sfinally);
    virtual Array<Statement*>* flatten(Scope* sc);
    virtual Statement* last();
    void accept(Visitor* v);
    virtual ReturnStatement* endsWithReturnStatement();
    ErrorStatement* isErrorStatement();
    ScopeStatement* isScopeStatement();
    ExpStatement* isExpStatement();
    CompoundStatement* isCompoundStatement();
    ReturnStatement* isReturnStatement();
    IfStatement* isIfStatement();
    CaseStatement* isCaseStatement();
    DefaultStatement* isDefaultStatement();
    LabelStatement* isLabelStatement();
    GotoStatement* isGotoStatement();
    GotoDefaultStatement* isGotoDefaultStatement();
    GotoCaseStatement* isGotoCaseStatement();
    BreakStatement* isBreakStatement();
    DtorExpStatement* isDtorExpStatement();
    ForwardingStatement* isForwardingStatement();
    DoStatement* isDoStatement();
    WhileStatement* isWhileStatement();
    ForStatement* isForStatement();
    ForeachStatement* isForeachStatement();
    SwitchStatement* isSwitchStatement();
    ContinueStatement* isContinueStatement();
    WithStatement* isWithStatement();
    TryCatchStatement* isTryCatchStatement();
    ThrowStatement* isThrowStatement();
    TryFinallyStatement* isTryFinallyStatement();
    SwitchErrorStatement* isSwitchErrorStatement();
    UnrolledLoopStatement* isUnrolledLoopStatement();
    ForeachRangeStatement* isForeachRangeStatement();
    CompoundDeclarationStatement* isCompoundDeclarationStatement();
};

class ErrorStatement : public Statement
{
public:
    Statement* syntaxCopy();
    void accept(Visitor* v);
};

class PeelStatement : public Statement
{
public:
    Statement* s;
    void accept(Visitor* v);
};

class ExpStatement : public Statement
{
public:
    Expression* exp;
    static ExpStatement* create(Loc loc, Expression* exp);
    Statement* syntaxCopy();
    Statement* scopeCode(Scope* sc, Statement** sentry, Statement** sexception, Statement** sfinally);
    Array<Statement*>* flatten(Scope* sc);
    void accept(Visitor* v);
};

class DtorExpStatement : public ExpStatement
{
public:
    VarDeclaration* var;
    Statement* syntaxCopy();
    void accept(Visitor* v);
};

class CompileStatement : public Statement
{
public:
    Array<Expression*>* exps;
    Statement* syntaxCopy();
    Array<Statement*>* compileIt(Scope* sc);
    Array<Statement*>* flatten(Scope* sc);
    void accept(Visitor* v);
};

class CompoundStatement : public Statement
{
public:
    Array<Statement*>* statements;
    static CompoundStatement* create(Loc loc, Statement* s1, Statement* s2);
    Statement* syntaxCopy();
    Array<Statement*>* flatten(Scope* sc);
    ReturnStatement* endsWithReturnStatement();
    Statement* last();
    void accept(Visitor* v);
};

class CompoundDeclarationStatement : public CompoundStatement
{
public:
    Statement* syntaxCopy();
    void accept(Visitor* v);
};

class UnrolledLoopStatement : public Statement
{
public:
    Array<Statement*>* statements;
    Statement* syntaxCopy();
    bool hasBreak() const;
    bool hasContinue() const;
    void accept(Visitor* v);
};

class ScopeStatement : public Statement
{
public:
    Statement* statement;
    Loc endloc;
    Statement* syntaxCopy();
    ReturnStatement* endsWithReturnStatement();
    bool hasBreak() const;
    bool hasContinue() const;
    void accept(Visitor* v);
};

class ForwardingStatement : public Statement
{
public:
    ForwardingScopeDsymbol* sym;
    Statement* statement;
    Statement* syntaxCopy();
    Array<Statement*>* flatten(Scope* sc);
    void accept(Visitor* v);
};

class WhileStatement : public Statement
{
public:
    Expression* condition;
    Statement* _body;
    Loc endloc;
    Statement* syntaxCopy();
    bool hasBreak() const;
    bool hasContinue() const;
    void accept(Visitor* v);
};

class DoStatement : public Statement
{
public:
    Statement* _body;
    Expression* condition;
    Loc endloc;
    Statement* syntaxCopy();
    bool hasBreak() const;
    bool hasContinue() const;
    void accept(Visitor* v);
};

class ForStatement : public Statement
{
public:
    Statement* _init;
    Expression* condition;
    Expression* increment;
    Statement* _body;
    Loc endloc;
    Statement* relatedLabeled;
    Statement* syntaxCopy();
    Statement* scopeCode(Scope* sc, Statement** sentry, Statement** sexception, Statement** sfinally);
    Statement* getRelatedLabeled();
    bool hasBreak() const;
    bool hasContinue() const;
    void accept(Visitor* v);
};

class ForeachStatement : public Statement
{
public:
    TOK op;
    Array<Parameter*>* parameters;
    Expression* aggr;
    Statement* _body;
    Loc endloc;
    VarDeclaration* key;
    VarDeclaration* value;
    FuncDeclaration* func;
    Array<Statement*>* cases;
    Array<ScopeStatement*>* gotos;
    Statement* syntaxCopy();
    bool hasBreak() const;
    bool hasContinue() const;
    void accept(Visitor* v);
};

class ForeachRangeStatement : public Statement
{
public:
    TOK op;
    Parameter* prm;
    Expression* lwr;
    Expression* upr;
    Statement* _body;
    Loc endloc;
    VarDeclaration* key;
    Statement* syntaxCopy();
    bool hasBreak() const;
    bool hasContinue() const;
    void accept(Visitor* v);
};

class IfStatement : public Statement
{
public:
    Parameter* prm;
    Expression* condition;
    Statement* ifbody;
    Statement* elsebody;
    VarDeclaration* match;
    Loc endloc;
    Statement* syntaxCopy();
    void accept(Visitor* v);
};

class ConditionalStatement : public Statement
{
public:
    Condition* condition;
    Statement* ifbody;
    Statement* elsebody;
    Statement* syntaxCopy();
    Array<Statement*>* flatten(Scope* sc);
    void accept(Visitor* v);
};

class StaticForeachStatement : public Statement
{
public:
    StaticForeach* sfe;
    Statement* syntaxCopy();
    Array<Statement*>* flatten(Scope* sc);
    void accept(Visitor* v);
};

class PragmaStatement : public Statement
{
public:
    Identifier* ident;
    Array<Expression*>* args;
    Statement* _body;
    Statement* syntaxCopy();
    void accept(Visitor* v);
};

class StaticAssertStatement : public Statement
{
public:
    StaticAssert* sa;
    Statement* syntaxCopy();
    void accept(Visitor* v);
};

class SwitchStatement : public Statement
{
public:
    Expression* condition;
    Statement* _body;
    bool isFinal;
    DefaultStatement* sdefault;
    Statement* tryBody;
    TryFinallyStatement* tf;
    Array<GotoCaseStatement*> gotoCases;
    Array<CaseStatement*>* cases;
    int32_t hasNoDefault;
    int32_t hasVars;
    VarDeclaration* lastVar;
    Statement* syntaxCopy();
    bool hasBreak() const;
    void accept(Visitor* v);
    ~SwitchStatement();
};

class CaseStatement : public Statement
{
public:
    Expression* exp;
    Statement* statement;
    int32_t index;
    VarDeclaration* lastVar;
    void* extra;
    Statement* syntaxCopy();
    void accept(Visitor* v);
};

class CaseRangeStatement : public Statement
{
public:
    Expression* first;
    Expression* last;
    Statement* statement;
    Statement* syntaxCopy();
    void accept(Visitor* v);
};

class DefaultStatement : public Statement
{
public:
    Statement* statement;
    VarDeclaration* lastVar;
    Statement* syntaxCopy();
    void accept(Visitor* v);
};

class GotoDefaultStatement : public Statement
{
public:
    SwitchStatement* sw;
    Statement* syntaxCopy();
    void accept(Visitor* v);
};

class GotoCaseStatement : public Statement
{
public:
    Expression* exp;
    CaseStatement* cs;
    Statement* syntaxCopy();
    void accept(Visitor* v);
};

class SwitchErrorStatement : public Statement
{
public:
    Expression* exp;
    void accept(Visitor* v);
};

class ReturnStatement : public Statement
{
public:
    Expression* exp;
    size_t caseDim;
    Statement* syntaxCopy();
    ReturnStatement* endsWithReturnStatement();
    void accept(Visitor* v);
};

class BreakStatement : public Statement
{
public:
    Identifier* ident;
    Statement* syntaxCopy();
    void accept(Visitor* v);
};

class ContinueStatement : public Statement
{
public:
    Identifier* ident;
    Statement* syntaxCopy();
    void accept(Visitor* v);
};

class SynchronizedStatement : public Statement
{
public:
    Expression* exp;
    Statement* _body;
    Statement* syntaxCopy();
    bool hasBreak() const;
    bool hasContinue() const;
    void accept(Visitor* v);
};

class WithStatement : public Statement
{
public:
    Expression* exp;
    Statement* _body;
    VarDeclaration* wthis;
    Loc endloc;
    Statement* syntaxCopy();
    void accept(Visitor* v);
};

class TryCatchStatement : public Statement
{
public:
    Statement* _body;
    Array<Catch*>* catches;
    Statement* tryBody;
    Statement* syntaxCopy();
    bool hasBreak() const;
    void accept(Visitor* v);
};

class Catch : public RootObject
{
public:
    Loc loc;
    Type* type;
    Identifier* ident;
    Statement* handler;
    VarDeclaration* var;
    bool errors;
    bool internalCatch;
    Catch* syntaxCopy();
};

class TryFinallyStatement : public Statement
{
public:
    Statement* _body;
    Statement* finalbody;
    Statement* tryBody;
    bool bodyFallsThru;
    static TryFinallyStatement* create(Loc loc, Statement* _body, Statement* finalbody);
    Statement* syntaxCopy();
    bool hasBreak() const;
    bool hasContinue() const;
    void accept(Visitor* v);
};

class ScopeGuardStatement : public Statement
{
public:
    TOK tok;
    Statement* statement;
    Statement* syntaxCopy();
    Statement* scopeCode(Scope* sc, Statement** sentry, Statement** sexception, Statement** sfinally);
    void accept(Visitor* v);
};

class ThrowStatement : public Statement
{
public:
    Expression* exp;
    bool internalThrow;
    Statement* syntaxCopy();
    void accept(Visitor* v);
};

class DebugStatement : public Statement
{
public:
    Statement* statement;
    Statement* syntaxCopy();
    Array<Statement*>* flatten(Scope* sc);
    void accept(Visitor* v);
};

class GotoStatement : public Statement
{
public:
    Identifier* ident;
    LabelDsymbol* label;
    Statement* tryBody;
    TryFinallyStatement* tf;
    ScopeGuardStatement* os;
    VarDeclaration* lastVar;
    Statement* syntaxCopy();
    void accept(Visitor* v);
};

class LabelStatement : public Statement
{
public:
    Identifier* ident;
    Statement* statement;
    Statement* tryBody;
    TryFinallyStatement* tf;
    ScopeGuardStatement* os;
    VarDeclaration* lastVar;
    Statement* gotoTarget;
    void* extra;
    bool breaks;
    Statement* syntaxCopy();
    Array<Statement*>* flatten(Scope* sc);
    Statement* scopeCode(Scope* sc, Statement** sentry, Statement** sexit, Statement** sfinally);
    void accept(Visitor* v);
};

class LabelDsymbol : public Dsymbol
{
public:
    LabelStatement* statement;
    bool deleted;
    bool iasm;
    static LabelDsymbol* create(Identifier* ident);
    LabelDsymbol* isLabel();
    void accept(Visitor* v);
};

class AsmStatement : public Statement
{
public:
    Token* tokens;
    Statement* syntaxCopy();
    void accept(Visitor* v);
};

class InlineAsmStatement : public AsmStatement
{
public:
    code* asmcode;
    uint32_t asmalign;
    uint32_t regs;
    bool refparam;
    bool naked;
    Statement* syntaxCopy();
    void accept(Visitor* v);
};

class GccAsmStatement : public AsmStatement
{
public:
    StorageClass stc;
    Expression* insn;
    Array<Expression*>* args;
    uint32_t outputargs;
    Array<Identifier*>* names;
    Array<Expression*>* constraints;
    Array<Expression*>* clobbers;
    Array<Identifier*>* labels;
    Array<GotoStatement*>* gotos;
    Statement* syntaxCopy();
    void accept(Visitor* v);
};

class CompoundAsmStatement : public CompoundStatement
{
public:
    StorageClass stc;
    CompoundAsmStatement* syntaxCopy();
    Array<Statement*>* flatten(Scope* sc);
    void accept(Visitor* v);
};

class ImportStatement : public Statement
{
public:
    Array<Dsymbol*>* imports;
    Statement* syntaxCopy();
    void accept(Visitor* v);
};

extern Statement* statementSemantic(Statement* s, Scope* sc);

class StaticAssert : public Dsymbol
{
public:
    Expression* exp;
    Expression* msg;
    Dsymbol* syntaxCopy(Dsymbol* s);
    void addMember(Scope* sc, ScopeDsymbol* sds);
    bool oneMember(Dsymbol** ps, Identifier* ident);
    const char* kind() const;
    void accept(Visitor* v);
};

struct Target
{
    uint32_t ptrsize;
    uint32_t realsize;
    uint32_t realpad;
    uint32_t realalignsize;
    uint32_t classinfosize;
    uint64_t maxStaticDataSize;
    TargetC c;
    TargetCPP cpp;
    TargetObjC objc;
    DArray< const char > architectureName;
    template <typename T>
    struct FPTypeProperties
    {
        // Ignoring var max alignment 0
        real_t max;
        // Ignoring var min_normal alignment 0
        real_t min_normal;
        // Ignoring var nan alignment 0
        real_t nan;
        // Ignoring var infinity alignment 0
        real_t infinity;
        // Ignoring var epsilon alignment 0
        real_t epsilon;
        // Ignoring var dig alignment 0
        d_int64 dig;
        // Ignoring var mant_dig alignment 0
        d_int64 mant_dig;
        // Ignoring var max_exp alignment 0
        d_int64 max_exp;
        // Ignoring var min_exp alignment 0
        d_int64 min_exp;
        // Ignoring var max_10_exp alignment 0
        d_int64 max_10_exp;
        // Ignoring var min_10_exp alignment 0
        d_int64 min_10_exp;
    };

    FPTypeProperties<float> FloatProperties;
    FPTypeProperties<double> DoubleProperties;
    FPTypeProperties<_d_real> RealProperties;
    Type* tvalist;
    void _init(const Param& params);
    void deinitialize();
    uint32_t alignsize(Type* type);
    uint32_t fieldalign(Type* type);
    uint32_t critsecsize();
    Type* va_listType(const Loc& loc, Scope* sc);
    int32_t isVectorTypeSupported(int32_t sz, Type* type);
    bool isVectorOpSupported(Type* type, uint8_t op, Type* t2);
    LINK systemLinkage();
    TypeTuple* toArgTypes(Type* t);
    bool isReturnOnStack(TypeFunction* tf, bool needsThis);
    uint64_t parameterSize(const Loc& loc, Type* t);
    void applyInRefParams(TypeFunction* tf);
    BEGIN_ENUM(TargetInfoKeys, TARGETINFOKEYS, targetinfokeys)
        ENUM_KEY(int32_t, cppRuntimeLibrary, 0, TargetInfoKeys, TARGETINFOKEYS, targetinfokeys, TIK)
        ENUM_KEY(int32_t, cppStd, 1, TargetInfoKeys, TARGETINFOKEYS, targetinfokeys, TIK)
        ENUM_KEY(int32_t, floatAbi, 2, TargetInfoKeys, TARGETINFOKEYS, targetinfokeys, TIK)
        ENUM_KEY(int32_t, objectFormat, 3, TargetInfoKeys, TARGETINFOKEYS, targetinfokeys, TIK)
    END_ENUM(TargetInfoKeys, TARGETINFOKEYS, targetinfokeys)

    Expression* getTargetInfo(const char* name, const Loc& loc);
    Target() : ptrsize(), realsize(), realpad(), realalignsize(), classinfosize(), maxStaticDataSize(), c(), cpp(), objc(), architectureName(), FloatProperties(), DoubleProperties(), RealProperties() {}
};

extern Target target;

extern bool tpsemantic(TemplateParameter* tp, Scope* sc, Array<TemplateParameter*>* parameters);

ENUM_CONSTANT_NUMERIC(bool, LOGSEMANTIC, false)

extern Type* typeSemantic(Type* type, const Loc& loc, Scope* sc);

extern Type* getTypeInfoType(Loc loc, Type* t, Scope* sc);

class SemanticTimeTransitiveVisitor : public SemanticTimePermissiveVisitor
{
public:
    void visit(PeelStatement* s);
    void visit(UnrolledLoopStatement* s);
    void visit(DebugStatement* s);
    void visit(ForwardingStatement* s);
    void visit(StructLiteralExp* e);
    void visit(DotTemplateExp* e);
    void visit(DotVarExp* e);
    void visit(DelegateExp* e);
    void visit(DotTypeExp* e);
    void visit(VectorExp* e);
    void visit(VectorArrayExp* e);
    void visit(SliceExp* e);
    void visit(ArrayLengthExp* e);
    void visit(DelegatePtrExp* e);
    void visit(DelegateFuncptrExp* e);
    void visit(DotExp* e);
    void visit(IndexExp* e);
    void visit(RemoveExp* e);
};

extern void backend_init();

extern targ_size_t _align(targ_size_t size, targ_size_t offset);

extern targ_size_t size(uint32_t ty);

extern Symbol* symboldata(targ_size_t offset, uint32_t ty);

extern void backend_term();

typedef Array<elem*> Elems;

extern int32_t REGSIZE();

extern bool ISREF(Declaration* var);

extern bool ISX64REF(Declaration* var);

extern bool ISX64REF(IRState* irs, Expression* exp);

extern elem* addressElem(elem* e, Type* t, bool alwaysCopy = false);

extern bool elemIsLvalue(elem* e);

extern elem* array_toPtr(Type* t, elem* e);

extern elem* array_toDarray(Type* t, elem* e);

extern elem* sarray_toDarray(const Loc& loc, Type* tfrom, Type* tto, elem* e);

extern elem* getTypeInfo(Loc loc, Type* t, IRState* irs);

extern StructDeclaration* needsPostblit(Type* t);

extern StructDeclaration* needsDtor(Type* t);

extern StringTable<Symbol*>* stringTab;

extern void clearStringTab();

extern elem* toElem(Expression* e, IRState* irs);

extern elem* toElemDtor(Expression* e, IRState* irs);

extern Symbol* toStringSymbol(const char* str, size_t len, size_t sz);

extern Symbol* toStringSymbol(StringExp* se);

extern elem* buildArrayBoundsError(IRState* irs, const Loc& loc, elem* lwr, elem* upr, elem* elength);

extern void toTraceGC(IRState* irs, elem* e, const Loc& loc);

extern elem* callCAssert(IRState* irs, const Loc& loc, Expression* exp, Expression* emsg, const char* str);

extern elem* genHalt(const Loc& loc);

extern bool type_zeroCopy(TYPE* t);

extern elem* elAssign(elem* e1, elem* e2, Type* t, TYPE* tx);

extern elem* setEthis2(const Loc& loc, IRState* irs, FuncDeclaration* fd, elem* ethis2, elem** ethis, elem** eside);

extern Symbol* except_gentables();

extern void except_fillInEHTable(Symbol* s);

extern Statement* asmSemantic(AsmStatement* s, Scope* sc);

extern uint32_t iasm_regs(block* bp);

typedef Array<Symbol*> symbols;

extern elem* eictor;

extern Symbol* ictorlocalgot;

extern Symbol* bzeroSymbol;

extern Array<Symbol*> sctors;

extern Array<StaticDtorDeclaration*> ectorgates;

extern Array<Symbol*> sdtors;

extern Array<Symbol*> stests;

extern Array<Symbol*> ssharedctors;

extern Array<SharedStaticDtorDeclaration*> esharedctorgates;

extern Array<Symbol*> sshareddtors;

extern const char* lastmname;

extern Array<Dsymbol*> obj_symbols_towrite;

extern void obj_append(Dsymbol* s);

extern void obj_write_deferred(Library* library);

extern Outbuffer objbuf;

extern void obj_start(const char* srcfile);

extern void obj_end(Library* library, const char* objfilename);

extern bool obj_includelib(const char* name);

extern void obj_startaddress(Symbol* s);

extern bool obj_linkerdirective(const char* directive);

extern void genObjFile(Module* m, bool multiobj);

extern void FuncDeclaration_toObjFile(FuncDeclaration* fd, bool multiobj);

extern uint32_t totym(Type* tx);

extern Symbol* toSymbol(Type* t);

extern Symbol* getBzeroSymbol();

extern elem* toEfilenamePtr(Module* m);

class ObjcGlue
{
public:
    struct ElemResult
    {
        elem* ec;
        elem* ethis;
        ElemResult() : ec(), ethis() {}
    };

    static void initialize();
    virtual void reset() = 0;
    virtual void setupMethodSelector(FuncDeclaration* fd, elem** esel) = 0;
    virtual ElemResult setupMethodCall(FuncDeclaration* fd, TypeFunction* tf, bool directcall, elem* ec, elem* ehidden, elem* ethis) = 0;
    virtual void setupEp(elem* esel, elem** ep, int32_t leftToRight) = 0;
    virtual void generateModuleInfo(Module* module_) = 0;
    virtual elem* toElem(ObjcClassReferenceExp* e) const = 0;
    virtual void toObjFile(ClassDeclaration* classDeclaration) const = 0;
    virtual size_t addSelectorParameterSymbol(FuncDeclaration* functionDeclaration, Symbol** parameters, size_t parameterCount) const = 0;
    virtual elem* getOffset(VarDeclaration* var, Type* type, elem* offset) const = 0;
};

typedef StmtState<block> StmtState;

extern void elem_setLoc(elem* e, const Loc& loc);

extern void Statement_toIR(Statement* s, IRState* irs);

extern void insertFinallyBlockCalls(block* startblock);

extern void insertFinallyBlockGotos(block* startblock);

extern Symbol* toSymbolX(Dsymbol* ds, const char* prefix, int32_t sclass, TYPE* t, const char* suffix);

extern Symbol* toSymbol(Dsymbol* s);

extern Symbol* toImport(Symbol* sym);

extern Symbol* toImport(Dsymbol* ds);

extern Symbol* toThunkSymbol(FuncDeclaration* fd, int32_t offset);

extern Symbol* fake_classsym(Identifier* id);

extern Symbol* toVtblSymbol(ClassDeclaration* cd);

extern Symbol* toInitializer(AggregateDeclaration* ad);

extern Symbol* toInitializer(EnumDeclaration* ed);

extern Symbol* aaGetSymbol(TypeAArray* taa, const char* func, int32_t flags);

extern Symbol* toSymbol(StructLiteralExp* sle);

extern Symbol* toSymbol(ClassReferenceExp* cre);

extern Symbol* toSymbolCpp(ClassDeclaration* cd);

extern Symbol* toSymbolCppTypeInfo(ClassDeclaration* cd);

extern TYPE* Type_toCtype(Type* t);

extern void toDebug(EnumDeclaration* ed);

extern void toDebug(StructDeclaration* sd);

extern void toDebug(ClassDeclaration* cd);

extern void toDebugClosure(Symbol* closstru);

typedef Array<dt_t*> Dts;

extern void Initializer_toDt(Initializer* init, DtBuilder& dtb);

extern void Expression_toDt(Expression* e, DtBuilder& dtb);

extern void ClassDeclaration_toDt(ClassDeclaration* cd, DtBuilder& dtb);

extern void StructDeclaration_toDt(StructDeclaration* sd, DtBuilder& dtb);

extern void cpp_type_info_ptr_toDt(ClassDeclaration* cd, DtBuilder& dtb);

extern void Type_toDt(Type* t, DtBuilder& dtb);

extern void ClassReferenceExp_toInstanceDt(ClassReferenceExp* ce, DtBuilder& dtb);

extern void TypeInfo_toDt(DtBuilder& dtb, TypeInfoDeclaration* d);

extern elem* getEthis(const Loc& loc, IRState* irs, Dsymbol* fd, Dsymbol* fdp, Dsymbol* origSc);

extern elem* fixEthis2(elem* ethis, FuncDeclaration* fd, bool ctxt2 = false);

extern elem* setEthis(const Loc& loc, IRState* irs, elem* ey, AggregateDeclaration* ad, bool setthis2 = false);

ENUM_CONSTANT_NUMERIC(int32_t, NotIntrinsic, -1)

ENUM_CONSTANT_NUMERIC(int32_t, OPtoPrec, 183)

extern int32_t intrinsic_op(FuncDeclaration* fd);

extern elem* resolveLengthVar(VarDeclaration* lengthVar, elem** pe, Type* t1);

extern TYPE* getParentClosureType(Symbol* sthis, FuncDeclaration* fd);

extern void setClosureVarOffset(FuncDeclaration* fd);

extern void buildClosure(FuncDeclaration* fd, IRState* irs);

extern void buildCapture(FuncDeclaration* fd);

extern RET retStyle(TypeFunction* tf, bool needsThis);

extern void genModuleInfo(Module* m);

extern void write_pointers(Type* type, Symbol* s, uint32_t offset);

extern void write_instance_pointers(Type* type, Symbol* s, uint32_t offset);

extern void toObjFile(Dsymbol* ds, bool multiobj);

extern uint32_t baseVtblOffset(ClassDeclaration* cd, BaseClass* bc);

ENUM_CONSTANT_NUMERIC(int32_t, GENOBJ, 1)

extern uint32_t mskl(uint32_t i);

BEGIN_ENUM(WM, WM, wm)
    ENUM_KEY(int32_t, WM_no_inline, 1, WM, WM, wm, WM)
    ENUM_KEY(int32_t, WM_assignment, 2, WM, WM, wm, WM)
    ENUM_KEY(int32_t, WM_nestcomment, 3, WM, WM, wm, WM)
    ENUM_KEY(int32_t, WM_assignthis, 4, WM, WM, wm, WM)
    ENUM_KEY(int32_t, WM_notagname, 5, WM, WM, wm, WM)
    ENUM_KEY(int32_t, WM_valuenotused, 6, WM, WM, wm, WM)
    ENUM_KEY(int32_t, WM_extra_semi, 7, WM, WM, wm, WM)
    ENUM_KEY(int32_t, WM_large_auto, 8, WM, WM, wm, WM)
    ENUM_KEY(int32_t, WM_obsolete_del, 9, WM, WM, wm, WM)
    ENUM_KEY(int32_t, WM_obsolete_inc, 10, WM, WM, wm, WM)
    ENUM_KEY(int32_t, WM_init2tmp, 11, WM, WM, wm, WM)
    ENUM_KEY(int32_t, WM_used_b4_set, 12, WM, WM, wm, WM)
    ENUM_KEY(int32_t, WM_bad_op, 13, WM, WM, wm, WM)
    ENUM_KEY(int32_t, WM_386_op, 14, WM, WM, wm, WM)
    ENUM_KEY(int32_t, WM_ret_auto, 15, WM, WM, wm, WM)
    ENUM_KEY(int32_t, WM_ds_ne_dgroup, 16, WM, WM, wm, WM)
    ENUM_KEY(int32_t, WM_unknown_pragma, 17, WM, WM, wm, WM)
    ENUM_KEY(int32_t, WM_implied_ret, 18, WM, WM, wm, WM)
    ENUM_KEY(int32_t, WM_num_args, 19, WM, WM, wm, WM)
    ENUM_KEY(int32_t, WM_before_pch, 20, WM, WM, wm, WM)
    ENUM_KEY(int32_t, WM_pch_first, 21, WM, WM, wm, WM)
    ENUM_KEY(int32_t, WM_pch_config, 22, WM, WM, wm, WM)
    ENUM_KEY(int32_t, WM_divby0, 23, WM, WM, wm, WM)
    ENUM_KEY(int32_t, WM_badnumber, 24, WM, WM, wm, WM)
    ENUM_KEY(int32_t, WM_ccast, 25, WM, WM, wm, WM)
    ENUM_KEY(int32_t, WM_obsolete, 26, WM, WM, wm, WM)
    ENUM_KEY(int32_t, WM_skip_attribute, 27, WM, WM, wm, WM)
    ENUM_KEY(int32_t, WM_warning_message, 28, WM, WM, wm, WM)
    ENUM_KEY(int32_t, WM_bad_vastart, 29, WM, WM, wm, WM)
    ENUM_KEY(int32_t, WM_undefined_inline, 30, WM, WM, wm, WM)
END_ENUM(WM, WM, wm)

ENUM_CONSTANT_NUMERIC(int32_t, LARGEDATA, 0)

ENUM_CONSTANT_NUMERIC(int32_t, LARGECODE, 0)

BEGIN_ENUM(LANG, LANG, lang)
    ENUM_KEY(int32_t, LANGenglish, 0, LANG, LANG, lang, LANG)
    ENUM_KEY(int32_t, LANGgerman, 1, LANG, LANG, lang, LANG)
    ENUM_KEY(int32_t, LANGfrench, 2, LANG, LANG, lang, LANG)
    ENUM_KEY(int32_t, LANGjapanese, 3, LANG, LANG, lang, LANG)
END_ENUM(LANG, LANG, lang)

ENUM_CONSTANT_NUMERIC(int32_t, IDMAX, 900)

ENUM_CONSTANT_NUMERIC(uint64_t, IDOHD, 17LLU)

ENUM_CONSTANT_NUMERIC(int32_t, STRMAX, 65000)

struct Thunk
{
    Symbol* sfunc;
    Symbol* sthunk;
    targ_size_t d;
    targ_size_t d2;
    int32_t i;
    Thunk() : sfunc(), sthunk(), d(), d2(), i() {}
};

struct token_t;

typedef Symbol Funcsym;

struct blklst;

typedef LIST* symlist_t;

typedef uint64_t* vec_t;

typedef uint8_t enum_TK;

extern Config config;

extern uint32_t CPP();

struct Srcpos
{
    uint32_t Slinnum;
    uint32_t Scharnum;
    const char* Sfilename;
    const char* const name() const;
    static Srcpos create(const char* filename, uint32_t linnum, int32_t charnum);
    void set(const char* filename, uint32_t linnum, int32_t charnum);
    void print(const char* func) const;
    Srcpos() {}
};

typedef uint32_t stflags_t;

BEGIN_ANON_ENUM()
    ANON_ENUM_KEY(int32_t, PFLpreprocessor, 1)
    ANON_ENUM_KEY(int32_t, PFLmasm, 2)
    ANON_ENUM_KEY(int32_t, PFLbasm, 4)
    ANON_ENUM_KEY(int32_t, PFLsemi, 8)
    ANON_ENUM_KEY(int32_t, PFLmftemp, 32)
    ANON_ENUM_KEY(int32_t, PFLextdef, 64)
    ANON_ENUM_KEY(int32_t, PFLhxwrote, 128)
    ANON_ENUM_KEY(int32_t, PFLhxdone, 256)
    ANON_ENUM_KEY(int32_t, PFLhxread, 512)
    ANON_ENUM_KEY(int32_t, PFLhxgen, 1024)
    ANON_ENUM_KEY(int32_t, PFLphread, 2048)
    ANON_ENUM_KEY(int32_t, PFLcomdef, 4096)
    ANON_ENUM_KEY(int32_t, PFLmacdef, 8192)
    ANON_ENUM_KEY(int32_t, PFLsymdef, 16384)
    ANON_ENUM_KEY(int32_t, PFLinclude, 32768)
    ANON_ENUM_KEY(int32_t, PFLmfc, 65536)
END_ANON_ENUM()

typedef char sthflags_t;

BEGIN_ANON_ENUM()
    ANON_ENUM_KEY(int32_t, FLAG_INPLACE, 0)
    ANON_ENUM_KEY(int32_t, FLAG_HX, 1)
    ANON_ENUM_KEY(int32_t, FLAG_SYM, 2)
END_ANON_ENUM()

struct Pstate
{
    uint8_t STinopeq;
    uint8_t STinarglist;
    uint8_t STinsizeof;
    uint8_t STintemplate;
    uint8_t STdeferDefaultArg;
    uint8_t STnoexpand;
    uint8_t STignoretal;
    uint8_t STexplicitInstantiation;
    uint8_t STexplicitSpecialization;
    uint8_t STinconstexp;
    uint8_t STisaddr;
    uint32_t STinexp;
    uint8_t STinfilter;
    uint8_t STinexcept;
    block* STbfilter;
    Symbol* STfuncsym_p;
    uint32_t STflags;
    char SThflag;
    Symbol* STclasssym;
    LIST* STclasslist;
    Symbol* STstag;
    int32_t STmarksi;
    uint8_t STnoparse;
    uint8_t STdeferparse;
    int32_t STgclass;
    int32_t STdefertemps;
    int32_t STdeferaccesscheck;
    int32_t STnewtypeid;
    int32_t STdefaultargumentexpression;
    block* STbtry;
    block* STgotolist;
    int32_t STtdbtimestamp;
    Symbol* STlastfunc;
    uint32_t STsequence;
    uint32_t STmaxsequence;
    Pstate() : STinopeq(), STinarglist(), STinsizeof(), STintemplate(), STdeferDefaultArg(), STnoexpand(), STignoretal(), STexplicitInstantiation(), STexplicitSpecialization(), STinconstexp(), STisaddr(), STinexp(), STfuncsym_p(), STflags(), SThflag(), STclasssym(), STclasslist(), STstag(), STmarksi(), STnoparse(), STdeferparse(), STgclass(), STdefertemps(), STdeferaccesscheck(), STnewtypeid(), STdefaultargumentexpression(), STbtry(), STgotolist(), STtdbtimestamp(), STlastfunc(), STsequence(), STmaxsequence() {}
};

extern void funcsym_p(Symbol* fp);

extern Symbol* funcsym_p();

extern uint32_t preprocessor();

extern uint32_t inline_asm();

extern Pstate pstate;

struct Cstate
{
    blklst* CSfilblk;
    Symbol* CSlinkage;
    LIST* CSlist_freelist;
    symtab_t* CSpsymtab;
    char* modname;
    Cstate() : CSfilblk(), CSlinkage(), CSlist_freelist(), CSpsymtab(), modname() {}
};

extern Cstate cstate;

BEGIN_ANON_ENUM()
    ANON_ENUM_KEY(int32_t, SCEXP, 1)
    ANON_ENUM_KEY(int32_t, SCKEP, 2)
    ANON_ENUM_KEY(int32_t, SCSCT, 4)
    ANON_ENUM_KEY(int32_t, SCSS, 8)
    ANON_ENUM_KEY(int32_t, SCRD, 16)
END_ANON_ENUM()

typedef char enum_SC;

typedef void* ClassDeclaration_;

typedef void* Declaration_;

typedef void* Module_;

struct Blockx
{
    block* startblock;
    block* curblock;
    Symbol* funcsym;
    Symbol* context;
    int32_t scope_index;
    int32_t next_index;
    uint32_t flags;
    block* tryblock;
    elem* init;
    void* classdec;
    void* member;
    void* _module;
    Blockx() {}
};

typedef uint16_t bflags_t;

BEGIN_ANON_ENUM()
    ANON_ENUM_KEY(int32_t, BFLvisited, 1)
    ANON_ENUM_KEY(int32_t, BFLmark, 2)
    ANON_ENUM_KEY(int32_t, BFLjmpoptdone, 4)
    ANON_ENUM_KEY(int32_t, BFLnostackopt, 8)
    ANON_ENUM_KEY(int32_t, BFLehcode, 16)
    ANON_ENUM_KEY(int32_t, BFLunwind, 4096)
    ANON_ENUM_KEY(int32_t, BFLnomerg, 32)
    ANON_ENUM_KEY(int32_t, BFLprolog, 128)
    ANON_ENUM_KEY(int32_t, BFLepilog, 256)
    ANON_ENUM_KEY(int32_t, BFLrefparam, 512)
    ANON_ENUM_KEY(int32_t, BFLreflocal, 1024)
    ANON_ENUM_KEY(int32_t, BFLoutsideprolog, 2048)
    ANON_ENUM_KEY(int32_t, BFLlabel, 8192)
    ANON_ENUM_KEY(int32_t, BFLvolatile, 16384)
    ANON_ENUM_KEY(int32_t, BFLnounroll, 32768)
END_ANON_ENUM()

struct block
{
    union
    {
        elem* Belem;
        LIST* Blist;
    };
    block* Bnext;
    LIST* Bsucc;
    LIST* Bpred;
    int32_t Bindex;
    int32_t Bendindex;
    block* Btry;
    union
    {
        int64_t* Bswitch;
        struct
        {
            uint32_t usIasmregs;
            uint8_t bIasmrefparam;
        };
        struct
        {
            Symbol* catchvar;
        };
        struct
        {
            Symbol* Bcatchtype;
            uint32_t* actionTable;
        };
        struct
        {
            Symbol* jcatchvar;
            int32_t Bscope_index;
            int32_t Blast_index;
        };
        struct
        {
            Symbol* flag;
            block* b_ret;
        };
        struct _BS
        {
            Symbol* jcvar;
            int32_t Bscope_idx;
            int32_t Blast_idx;
            _BS() : Bscope_idx(), Blast_idx() {}
        };

        _BS BS;
    };
    Srcpos Bsrcpos;
    uint8_t BC;
    uint8_t Balign;
    uint16_t Bflags;
    code* Bcode;
    uint32_t Bweight;
    uint32_t Bdfoidx;
    uint32_t Bnumber;
    union
    {
        uint32_t _BLU;
        struct
        {
            int32_t Bsymstart;
            int32_t Bsymend;
            block* Bendscope;
            uint32_t Bblknum;
            Symbol* Binitvar;
            block* Bgotolist;
            block* Bgotothread;
        };
        struct
        {
            uint64_t* Bdom;
            uint64_t* Binrd;
            uint64_t* Boutrd;
            uint64_t* Binlv;
            uint64_t* Boutlv;
            uint64_t* Bin;
            uint64_t* Bout;
            uint64_t* Bgen;
            uint64_t* Bkill;
            uint64_t* Bout2;
            uint64_t* Bgen2;
            uint64_t* Bkill2;
        };
        struct
        {
            targ_size_t Btablesize;
            targ_size_t Btableoffset;
            targ_size_t Btablebase;
            targ_size_t Boffset;
            targ_size_t Bsize;
            con_t Bregcon;
            targ_size_t Btryoff;
        };
    };
    void appendSucc(block* b);
    void prependSucc(block* b);
    int32_t numSucc();
    block* nthSucc(int32_t n);
    void setNthSucc(int32_t n, block* b);
    block() {}
};

extern block* list_block(LIST* lst);

typedef int32_t BC;

BEGIN_ANON_ENUM()
    ANON_ENUM_KEY(int32_t, BCgoto, 1)
    ANON_ENUM_KEY(int32_t, BCiftrue, 2)
    ANON_ENUM_KEY(int32_t, BCret, 3)
    ANON_ENUM_KEY(int32_t, BCretexp, 4)
    ANON_ENUM_KEY(int32_t, BCexit, 5)
    ANON_ENUM_KEY(int32_t, BCasm, 6)
    ANON_ENUM_KEY(int32_t, BCswitch, 7)
    ANON_ENUM_KEY(int32_t, BCifthen, 8)
    ANON_ENUM_KEY(int32_t, BCjmptab, 9)
    ANON_ENUM_KEY(int32_t, BCtry, 10)
    ANON_ENUM_KEY(int32_t, BCcatch, 11)
    ANON_ENUM_KEY(int32_t, BCjump, 12)
    ANON_ENUM_KEY(int32_t, BC_try, 13)
    ANON_ENUM_KEY(int32_t, BC_filter, 14)
    ANON_ENUM_KEY(int32_t, BC_finally, 15)
    ANON_ENUM_KEY(int32_t, BC_ret, 16)
    ANON_ENUM_KEY(int32_t, BC_except, 17)
    ANON_ENUM_KEY(int32_t, BCjcatch, 18)
    ANON_ENUM_KEY(int32_t, BC_lpad, 19)
    ANON_ENUM_KEY(int32_t, BCMAX, 20)
END_ANON_ENUM()

struct BlockRange
{
    BlockRange(block* b);
    block* front();
    void popFront();
    bool empty() const;
    block* b;
    BlockRange() {}
};

struct symtab_t
{
    int32_t top;
    int32_t symmax;
    Symbol** tab;
    symtab_t() : top(), symmax(), tab() {}
};

typedef uint32_t func_flags_t;

BEGIN_ANON_ENUM()
    ANON_ENUM_KEY(int32_t, Fpending, 1)
    ANON_ENUM_KEY(int32_t, Foutput, 2)
    ANON_ENUM_KEY(int32_t, Foperator, 4)
    ANON_ENUM_KEY(int32_t, Fcast, 8)
    ANON_ENUM_KEY(int32_t, Finline, 16)
    ANON_ENUM_KEY(int32_t, Foverload, 32)
    ANON_ENUM_KEY(int32_t, Ftypesafe, 64)
    ANON_ENUM_KEY(int32_t, Fmustoutput, 128)
    ANON_ENUM_KEY(int32_t, Fvirtual, 256)
    ANON_ENUM_KEY(int32_t, Fctor, 512)
    ANON_ENUM_KEY(int32_t, Fdtor, 1024)
    ANON_ENUM_KEY(int32_t, Fnotparent, 2048)
    ANON_ENUM_KEY(int32_t, Finlinenest, 4096)
    ANON_ENUM_KEY(int32_t, Flinkage, 8192)
    ANON_ENUM_KEY(int32_t, Fstatic, 16384)
    ANON_ENUM_KEY(int32_t, Fbitcopy, 32768)
    ANON_ENUM_KEY(int32_t, Fpure, 65536)
    ANON_ENUM_KEY(int32_t, Finstance, 131072)
    ANON_ENUM_KEY(int32_t, Ffixed, 262144)
    ANON_ENUM_KEY(int32_t, Fintro, 524288)
    ANON_ENUM_KEY(int32_t, Fkeeplink, 2097152)
    ANON_ENUM_KEY(int32_t, Fnodebug, 4194304)
    ANON_ENUM_KEY(int32_t, Fgen, 8388608)
    ANON_ENUM_KEY(int32_t, Finvariant, 16777216)
    ANON_ENUM_KEY(int32_t, Fexplicit, 33554432)
    ANON_ENUM_KEY(int32_t, Fsurrogate, 67108864)
END_ANON_ENUM()

typedef uint32_t func_flags3_t;

BEGIN_ANON_ENUM()
    ANON_ENUM_KEY(int32_t, Fvtblgen, 1)
    ANON_ENUM_KEY(int32_t, Femptyexc, 2)
    ANON_ENUM_KEY(int32_t, Fcppeh, 4)
    ANON_ENUM_KEY(int32_t, Fnteh, 8)
    ANON_ENUM_KEY(int32_t, Fdeclared, 16)
    ANON_ENUM_KEY(int32_t, Fmark, 32)
    ANON_ENUM_KEY(int32_t, Fdoinline, 64)
    ANON_ENUM_KEY(int32_t, Foverridden, 128)
    ANON_ENUM_KEY(int32_t, Fjmonitor, 256)
    ANON_ENUM_KEY(int32_t, Fnosideeff, 512)
    ANON_ENUM_KEY(int32_t, F3badoparrow, 1024)
    ANON_ENUM_KEY(int32_t, Fmain, 2048)
    ANON_ENUM_KEY(int32_t, Fnested, 4096)
    ANON_ENUM_KEY(int32_t, Fmember, 8192)
    ANON_ENUM_KEY(int32_t, Fnotailrecursion, 16384)
    ANON_ENUM_KEY(int32_t, Ffakeeh, 32768)
    ANON_ENUM_KEY(int32_t, Fnothrow, 65536)
    ANON_ENUM_KEY(int32_t, Feh_none, 131072)
END_ANON_ENUM()

struct func_t
{
    LIST* Fsymtree;
    block* Fstartblock;
    symtab_t Flocsym;
    Srcpos Fstartline;
    Srcpos Fendline;
    Symbol* F__func__;
    uint32_t Fflags;
    uint32_t Fflags3;
    uint8_t Foper;
    Symbol* Fparsescope;
    Symbol* Fclass;
    Symbol* Foversym;
    LIST* Fclassfriends;
    block* Fbaseblock;
    block* Fbaseendblock;
    elem* Fbaseinit;
    token_t* Fbody;
    uint32_t Fsequence;
    union
    {
        Symbol* Ftempl;
        Thunk* Fthunk;
    };
    Symbol* Falias;
    LIST* Fthunks;
    param_t* Farglist;
    param_t* Fptal;
    LIST* Ffwdrefinstances;
    LIST* Fexcspec;
    Symbol* Fexplicitspec;
    Symbol* Fsurrogatesym;
    char* Fredirect;
    Barray<Symbol*> typesTable;
    union
    {
        uint32_t LSDAoffset;
        Symbol* LSDAsym;
    };
    func_t() : Fsymtree(), Fstartblock(), Flocsym(), Fstartline(), Fendline(), F__func__(), Fflags(), Fflags3(), Foper(), Fparsescope(), Fclass(), Foversym(), Fclassfriends(), Fbaseblock(), Fbaseendblock(), Fbaseinit(), Fbody(), Fsequence(), Falias(), Fthunks(), Farglist(), Fptal(), Ffwdrefinstances(), Fexcspec(), Fexplicitspec(), Fsurrogatesym(), Fredirect() {}
};

struct meminit_t
{
    LIST* MIelemlist;
    Symbol* MIsym;
    meminit_t() : MIelemlist(), MIsym() {}
};

typedef uint32_t baseclass_flags_t;

BEGIN_ANON_ENUM()
    ANON_ENUM_KEY(int32_t, BCFpublic, 1)
    ANON_ENUM_KEY(int32_t, BCFprotected, 2)
    ANON_ENUM_KEY(int32_t, BCFprivate, 4)
    ANON_ENUM_KEY(int32_t, BCFvirtual, 8)
    ANON_ENUM_KEY(int32_t, BCFvfirst, 16)
    ANON_ENUM_KEY(int32_t, BCFnewvtbl, 32)
    ANON_ENUM_KEY(int32_t, BCFvirtprim, 64)
    ANON_ENUM_KEY(int32_t, BCFdependent, 128)
END_ANON_ENUM()

ENUM_CONSTANT_NUMERIC(uint32_t, BCFpmask, 7u)

struct baseclass_t
{
    Symbol* BCbase;
    baseclass_t* BCnext;
    targ_size_t BCoffset;
    uint16_t BCvbtbloff;
    LIST* BCpublics;
    LIST* BCmptrlist;
    Symbol* BCvtbl;
    uint32_t BCflags;
    Symbol* BCparent;
    baseclass_t* BCpbase;
    baseclass_t() : BCbase(), BCnext(), BCoffset(), BCvbtbloff(), BCpublics(), BCmptrlist(), BCvtbl(), BCflags(), BCparent(), BCpbase() {}
};

extern void baseclass_free(baseclass_t* b);

typedef char mptr_flags_t;

BEGIN_ANON_ENUM()
    ANON_ENUM_KEY(int32_t, MPTRvirtual, 1)
    ANON_ENUM_KEY(int32_t, MPTRcovariant, 2)
END_ANON_ENUM()

struct mptr_t
{
    int16_t MPd;
    int16_t MPi;
    Symbol* MPf;
    Symbol* MPparent;
    char MPflags;
    mptr_t() : MPd(), MPi(), MPf(), MPparent(), MPflags() {}
};

extern mptr_t* list_mptr(LIST* lst);

struct TMF
{
    Symbol* stag;
    token_t* tbody;
    token_t* to;
    param_t* temp_arglist;
    int32_t member_class;
    int32_t castoverload;
    char* name;
    int32_t member_template;
    param_t* temp_arglist2;
    param_t* ptal;
    Symbol* sclassfriend;
    uint32_t access_specifier;
    TMF() : stag(), tbody(), to(), temp_arglist(), member_class(), castoverload(), name(), member_template(), temp_arglist2(), ptal(), sclassfriend(), access_specifier() {}
};

struct TME
{
    param_t* ptal;
    Symbol* stempl;
    TME() : ptal(), stempl() {}
};

struct TMNE
{
    uint8_t tk;
    char* name;
    param_t* ptal;
    token_t* tdecl;
    TMNE() : tk(), name(), ptal(), tdecl() {}
};

struct TMNF
{
    token_t* tdecl;
    param_t* temp_arglist;
    Symbol* stag;
    Symbol* stempl;
    TMNF() : tdecl(), temp_arglist(), stag(), stempl() {}
};

struct template_t
{
    LIST* TMinstances;
    param_t* TMptpl;
    token_t* TMbody;
    uint32_t TMsequence;
    LIST* TMmemberfuncs;
    LIST* TMexplicit;
    LIST* TMnestedexplicit;
    Symbol* TMnext;
    uint8_t TMtk;
    int32_t TMflags;
    Symbol* TMprimary;
    Symbol* TMpartial;
    param_t* TMptal;
    LIST* TMfriends;
    LIST* TMnestedfriends;
    int32_t TMflags2;
    template_t() : TMinstances(), TMptpl(), TMbody(), TMsequence(), TMmemberfuncs(), TMexplicit(), TMnestedexplicit(), TMnext(), TMtk(), TMflags(), TMprimary(), TMpartial(), TMptal(), TMfriends(), TMnestedfriends(), TMflags2() {}
};

typedef uint32_t enum_flags_t;

BEGIN_ANON_ENUM()
    ANON_ENUM_KEY(int32_t, SENnotagname, 1)
    ANON_ENUM_KEY(int32_t, SENforward, 2)
END_ANON_ENUM()

struct enum_t
{
    uint32_t SEflags;
    Symbol* SEalias;
    LIST* SEenumlist;
    enum_t() : SEflags(), SEalias(), SEenumlist() {}
};

typedef uint32_t struct_flags_t;

BEGIN_ANON_ENUM()
    ANON_ENUM_KEY(int32_t, STRanonymous, 1)
    ANON_ENUM_KEY(int32_t, STRglobal, 2)
    ANON_ENUM_KEY(int32_t, STRnotagname, 4)
    ANON_ENUM_KEY(int32_t, STRoutdef, 8)
    ANON_ENUM_KEY(int32_t, STRbitfields, 16)
    ANON_ENUM_KEY(int32_t, STRabstract, 32)
    ANON_ENUM_KEY(int32_t, STRbitcopy, 64)
    ANON_ENUM_KEY(int32_t, STRanyctor, 128)
    ANON_ENUM_KEY(int32_t, STRnoctor, 256)
    ANON_ENUM_KEY(int32_t, STRgen, 512)
    ANON_ENUM_KEY(int32_t, STRvtblext, 1024)
    ANON_ENUM_KEY(int32_t, STRexport, 2048)
    ANON_ENUM_KEY(int32_t, STRpredef, 4096)
    ANON_ENUM_KEY(int32_t, STRunion, 8192)
    ANON_ENUM_KEY(int32_t, STRclass, 16384)
    ANON_ENUM_KEY(int32_t, STRimport, 32768)
    ANON_ENUM_KEY(int32_t, STRstaticmems, 65536)
    ANON_ENUM_KEY(int32_t, STR0size, 131072)
    ANON_ENUM_KEY(int32_t, STRinstantiating, 262144)
    ANON_ENUM_KEY(int32_t, STRexplicit, 524288)
    ANON_ENUM_KEY(int32_t, STRgenctor0, 1048576)
    ANON_ENUM_KEY(int32_t, STRnotpod, 2097152)
END_ANON_ENUM()

struct struct_t
{
    targ_size_t Sstructsize;
    LIST* Sfldlst;
    Symbol* Sroot;
    uint32_t Salignsize;
    uint8_t Sstructalign;
    uint32_t Sflags;
    uint32_t ptrtype;
    uint16_t access;
    targ_size_t Snonvirtsize;
    LIST* Svirtual;
    LIST** Spvirtder;
    LIST* Sopoverload;
    LIST* Scastoverload;
    LIST* Sclassfriends;
    LIST* Sfriendclass;
    LIST* Sfriendfuncs;
    LIST* Sinlinefuncs;
    baseclass_t* Sbase;
    baseclass_t* Svirtbase;
    baseclass_t* Smptrbase;
    baseclass_t* Sprimary;
    Symbol* Svecctor;
    Symbol* Sctor;
    Symbol* Sdtor;
    Symbol* Sprimdtor;
    Symbol* Spriminv;
    Symbol* Sscaldeldtor;
    Symbol* Sinvariant;
    Symbol* Svptr;
    Symbol* Svtbl;
    Symbol* Svbptr;
    Symbol* Svbptr_parent;
    targ_size_t Svbptr_off;
    Symbol* Svbtbl;
    baseclass_t* Svbptrbase;
    Symbol* Sopeq;
    Symbol* Sopeq2;
    Symbol* Scpct;
    Symbol* Sveccpct;
    Symbol* Salias;
    Symbol* Stempsym;
    TYPE* Sarg1type;
    TYPE* Sarg2type;
    param_t* Sarglist;
    param_t* Spr_arglist;
    struct_t() : Sstructsize(), Sfldlst(), Sroot(), Salignsize(), Sstructalign(), Sflags(), ptrtype(), access(), Snonvirtsize(), Svirtual(), Spvirtder(), Sopoverload(), Scastoverload(), Sclassfriends(), Sfriendclass(), Sfriendfuncs(), Sinlinefuncs(), Sbase(), Svirtbase(), Smptrbase(), Sprimary(), Svecctor(), Sctor(), Sdtor(), Sprimdtor(), Spriminv(), Sscaldeldtor(), Sinvariant(), Svptr(), Svtbl(), Svbptr(), Svbptr_parent(), Svbptr_off(), Svbtbl(), Svbptrbase(), Sopeq(), Sopeq2(), Scpct(), Sveccpct(), Salias(), Stempsym(), Sarg1type(), Sarg2type(), Sarglist(), Spr_arglist() {}
};

extern Symbol* list_symbol(LIST* lst);

extern void list_setsymbol(LIST* lst, Symbol* s);

extern Symbol* list_Classsym(LIST* lst);

BEGIN_ANON_ENUM()
    ANON_ENUM_KEY(int32_t, SFLvalue, 1)
    ANON_ENUM_KEY(int32_t, SFLimplem, 2)
    ANON_ENUM_KEY(int32_t, SFLdouble, 2)
    ANON_ENUM_KEY(int32_t, SFLfree, 4)
    ANON_ENUM_KEY(int32_t, SFLmark, 8)
    ANON_ENUM_KEY(int32_t, SFLexit, 16)
    ANON_ENUM_KEY(int32_t, SFLtrue, 512)
    ANON_ENUM_KEY(int32_t, SFLreplace, 8)
    ANON_ENUM_KEY(int32_t, SFLskipinit, 65536)
    ANON_ENUM_KEY(int32_t, SFLnodebug, 131072)
    ANON_ENUM_KEY(int32_t, SFLwasstatic, 8388608)
    ANON_ENUM_KEY(int32_t, SFLweak, 16777216)
    ANON_ENUM_KEY(int32_t, SFLhidden, 33554432)
    ANON_ENUM_KEY(int32_t, SFLartifical, 67108864)
    ANON_ENUM_KEY(int32_t, SFLnodtor, 16)
    ANON_ENUM_KEY(int32_t, SFLdtorexp, 128)
    ANON_ENUM_KEY(int32_t, SFLmutable, 1048576)
    ANON_ENUM_KEY(int32_t, SFLdyninit, 2097152)
    ANON_ENUM_KEY(int32_t, SFLtmp, 4194304)
    ANON_ENUM_KEY(int32_t, SFLthunk, 262144)
    ANON_ENUM_KEY(int32_t, SFLprivate, 96)
    ANON_ENUM_KEY(int32_t, SFLprotected, 64)
    ANON_ENUM_KEY(int32_t, SFLpublic, 32)
    ANON_ENUM_KEY(int32_t, SFLnone, 0)
    ANON_ENUM_KEY(int32_t, SFLpmask, 96)
    ANON_ENUM_KEY(int32_t, SFLvtbl, 8192)
    ANON_ENUM_KEY(int32_t, GTregcand, 256)
    ANON_ENUM_KEY(int32_t, SFLdead, 2048)
    ANON_ENUM_KEY(int32_t, GTunregister, 134217728)
    ANON_ENUM_KEY(int32_t, SFLunambig, 1024)
    ANON_ENUM_KEY(int32_t, SFLlivexit, 4096)
    ANON_ENUM_KEY(int32_t, SFLnotbasiciv, 16384)
    ANON_ENUM_KEY(int32_t, SFLnord, 2)
    ANON_ENUM_KEY(int32_t, GTtried, 8)
    ANON_ENUM_KEY(int32_t, GTbyte, 32768)
    ANON_ENUM_KEY(int32_t, SFLread, 262144)
    ANON_ENUM_KEY(int32_t, SFLspill, 524288)
END_ANON_ENUM()

struct Symbol
{
    ENUM_CONSTANT_NUMERIC(int32_t, IDsymbol, 22136)

    Symbol* Sl;
    Symbol* Sr;
    Symbol* Snext;
    dt_t* Sdt;
    int32_t Salignment;
    int32_t Salignsize();
    TYPE* Stype;
    uint32_t ty() const;
    union
    {
        enum_t* Senum;
        struct
        {
            func_t* Sfunc;
            LIST* Spath1;
        };
        struct
        {
            int32_t Slabel;
            block* Slabelblk_;
        };
        struct
        {
            uint8_t Sbit;
            uint8_t Swidth;
            targ_size_t Smemoff;
        };
        elem* Svalue;
        struct_t* Sstruct;
        template_t* Stemplate;
        struct
        {
            uint8_t Spreg;
            uint8_t Spreg2;
        };
    };
    uint32_t Spregm();
    Symbol* Sscope;
    const char* prettyIdent;
    targ_size_t Slocalgotoffset;
    char Sclass;
    char Sfl;
    uint32_t Sflags;
    uint64_t* Srange;
    uint64_t* Slvreg;
    targ_size_t Ssize;
    targ_size_t Soffset;
    int32_t Ssymnum;
    int32_t Sseg;
    int32_t Sweight;
    int32_t Sdw_ref_idx;
    union
    {
        uint32_t Sxtrnnum;
        uint32_t Stypidx;
        struct
        {
            uint8_t Sreglsw;
            uint8_t Sregmsw;
            uint32_t Sregm;
        };
    };
    uint32_t Sregsaved;
    uint32_t lnoscopestart;
    uint32_t lnoscopeend;
    char Sident[1LLU];
    int32_t needThis();
    bool Sisdead(bool anyiasm);
    Symbol() {}
};

extern void symbol_debug(const Symbol* const s);

extern bool isclassmember(const Symbol* const s);

typedef Symbol Classsym;

typedef Symbol Nspacesym;

typedef Symbol Aliassym;

extern const char* prettyident(const Symbol* const s);

typedef uint32_t pflags_t;

BEGIN_ANON_ENUM()
    ANON_ENUM_KEY(int32_t, PFexplicit, 1)
END_ANON_ENUM()

extern EHmethod ehmethod(Symbol* f);

struct param_t
{
    ENUM_CONSTANT_NUMERIC(int32_t, IDparam, 28752)

    char* Pident;
    TYPE* Ptype;
    elem* Pelem;
    token_t* PelemToken;
    TYPE* Pdeftype;
    param_t* Pptpl;
    Symbol* Psym;
    param_t* Pnext;
    uint32_t Pflags;
    param_t* createTal(param_t* p);
    param_t* search(char* id);
    int32_t searchn(char* id);
    uint32_t length();
    void print();
    void print_list();
    param_t() {}
};

extern void param_debug(const param_t* const p);

typedef int32_t FL;

BEGIN_ANON_ENUM()
    ANON_ENUM_KEY(int32_t, FLunde, 0)
    ANON_ENUM_KEY(int32_t, FLconst, 1)
    ANON_ENUM_KEY(int32_t, FLoper, 2)
    ANON_ENUM_KEY(int32_t, FLfunc, 3)
    ANON_ENUM_KEY(int32_t, FLdata, 4)
    ANON_ENUM_KEY(int32_t, FLreg, 5)
    ANON_ENUM_KEY(int32_t, FLpseudo, 6)
    ANON_ENUM_KEY(int32_t, FLauto, 7)
    ANON_ENUM_KEY(int32_t, FLfast, 8)
    ANON_ENUM_KEY(int32_t, FLpara, 9)
    ANON_ENUM_KEY(int32_t, FLextern, 10)
    ANON_ENUM_KEY(int32_t, FLcode, 11)
    ANON_ENUM_KEY(int32_t, FLblock, 12)
    ANON_ENUM_KEY(int32_t, FLudata, 13)
    ANON_ENUM_KEY(int32_t, FLcs, 14)
    ANON_ENUM_KEY(int32_t, FLswitch, 15)
    ANON_ENUM_KEY(int32_t, FLfltreg, 16)
    ANON_ENUM_KEY(int32_t, FLoffset, 17)
    ANON_ENUM_KEY(int32_t, FLdatseg, 18)
    ANON_ENUM_KEY(int32_t, FLctor, 19)
    ANON_ENUM_KEY(int32_t, FLdtor, 20)
    ANON_ENUM_KEY(int32_t, FLregsave, 21)
    ANON_ENUM_KEY(int32_t, FLasm, 22)
    ANON_ENUM_KEY(int32_t, FLndp, 23)
    ANON_ENUM_KEY(int32_t, FLfardata, 24)
    ANON_ENUM_KEY(int32_t, FLcsdata, 25)
    ANON_ENUM_KEY(int32_t, FLlocalsize, 26)
    ANON_ENUM_KEY(int32_t, FLtlsdata, 27)
    ANON_ENUM_KEY(int32_t, FLbprel, 28)
    ANON_ENUM_KEY(int32_t, FLframehandler, 29)
    ANON_ENUM_KEY(int32_t, FLblockoff, 30)
    ANON_ENUM_KEY(int32_t, FLallocatmp, 31)
    ANON_ENUM_KEY(int32_t, FLstack, 32)
    ANON_ENUM_KEY(int32_t, FLdsymbol, 33)
    ANON_ENUM_KEY(int32_t, FLgot, 34)
    ANON_ENUM_KEY(int32_t, FLgotoff, 35)
    ANON_ENUM_KEY(int32_t, FLfuncarg, 36)
    ANON_ENUM_KEY(int32_t, FLMAX, 37)
END_ANON_ENUM()

struct EEcontext
{
    uint32_t EElinnum;
    char* EEexpr;
    char* EEtypedef;
    int8_t EEpending;
    int8_t EEimminent;
    int8_t EEcompile;
    int8_t EEin;
    elem* EEelem;
    Symbol* EEfunc;
    code* EEcode;
    EEcontext() : EElinnum(), EEexpr(), EEtypedef(), EEpending(), EEimminent(), EEcompile(), EEin(), EEelem(), EEfunc(), EEcode() {}
};

extern EEcontext eecontext;

typedef uint32_t goal_t;

BEGIN_ANON_ENUM()
    ANON_ENUM_KEY(int32_t, GOALnone, 0)
    ANON_ENUM_KEY(int32_t, GOALvalue, 1)
    ANON_ENUM_KEY(int32_t, GOALflags, 2)
    ANON_ENUM_KEY(int32_t, GOALagain, 4)
    ANON_ENUM_KEY(int32_t, GOALstruct, 8)
    ANON_ENUM_KEY(int32_t, GOALhandle, 16)
    ANON_ENUM_KEY(int32_t, GOALignore_exceptions, 32)
END_ANON_ENUM()

struct Declar
{
    Symbol* class_sym;
    Symbol* namespace_sym;
    int32_t oper;
    bool constructor;
    bool destructor;
    bool _invariant;
    param_t* ptal;
    bool explicitSpecialization;
    int32_t hasExcSpec;
    Declar() : class_sym(), namespace_sym(), oper(), constructor(), destructor(), _invariant(), ptal(), explicitSpecialization(), hasExcSpec() {}
};

extern Declar gdeclar;

struct dt_t
{
    dt_t* DTnext;
    char dt;
    uint8_t Dty;
    uint8_t DTn;
    uint8_t DTalign;
    union
    {
        struct
        {
            ENUM_CONSTANT_NUMERIC(uint64_t, DTibytesMax, 24LLU)

            int8_t DTdata[24LLU];
        };
        targ_size_t DTazeros;
        struct
        {
            int8_t* DTpbytes;
            uint32_t DTnbytes;
            int32_t DTseg;
            targ_size_t DTabytes;
        };
        struct
        {
            Symbol* DTsym;
            targ_size_t DToffset;
        };
    };
    dt_t() : DTnext(), dt(), Dty(), DTn(), DTalign() {}
};

BEGIN_ANON_ENUM()
    ANON_ENUM_KEY(int32_t, DT_abytes, 0)
    ANON_ENUM_KEY(int32_t, DT_azeros, 1)
    ANON_ENUM_KEY(int32_t, DT_xoff, 2)
    ANON_ENUM_KEY(int32_t, DT_nbytes, 3)
    ANON_ENUM_KEY(int32_t, DT_common, 4)
    ANON_ENUM_KEY(int32_t, DT_coff, 5)
    ANON_ENUM_KEY(int32_t, DT_ibytes, 6)
END_ANON_ENUM()

ENUM_CONSTANT(const char*, VERSION, "9.00.0")

ENUM_CONSTANT(const char*, VERSIONHEX, "0x900")

ENUM_CONSTANT_NUMERIC(int32_t, VERSIONINT, 2304)

ENUM_CONSTANT_NUMERIC(bool, TARGET_LINUX, true)

ENUM_CONSTANT_NUMERIC(bool, TARGET_OSX, false)

ENUM_CONSTANT_NUMERIC(bool, TARGET_FREEBSD, false)

ENUM_CONSTANT_NUMERIC(bool, TARGET_OPENBSD, false)

ENUM_CONSTANT_NUMERIC(bool, TARGET_SOLARIS, false)

ENUM_CONSTANT_NUMERIC(bool, TARGET_WINDOS, false)

ENUM_CONSTANT_NUMERIC(bool, TARGET_DRAGONFLYBSD, false)

BEGIN_ANON_ENUM()
    ANON_ENUM_KEY(int32_t, ATTR_LINKMOD, 1)
    ANON_ENUM_KEY(int32_t, ATTR_TYPEMOD, 2)
    ANON_ENUM_KEY(int32_t, ATTR_FUNCINFO, 4)
    ANON_ENUM_KEY(int32_t, ATTR_DATAINFO, 8)
    ANON_ENUM_KEY(int32_t, ATTR_TRANSU, 16)
    ANON_ENUM_KEY(int32_t, ATTR_IGNORED, 32)
    ANON_ENUM_KEY(int32_t, ATTR_WARNING, 64)
    ANON_ENUM_KEY(int32_t, ATTR_SEGMENT, 128)
END_ANON_ENUM()

BEGIN_ANON_ENUM()
    ANON_ENUM_KEY(int32_t, ALOC_DECSTART, 1)
    ANON_ENUM_KEY(int32_t, ALOC_SYMDEF, 2)
    ANON_ENUM_KEY(int32_t, ALOC_PARAM, 4)
    ANON_ENUM_KEY(int32_t, ALOC_FUNC, 8)
END_ANON_ENUM()

ENUM_CONSTANT(const char*, SUFFIX, "")

ENUM_CONSTANT_NUMERIC(int32_t, TERMCODE, 0)

ENUM_CONSTANT_NUMERIC(int32_t, ANGLE_BRACKET_HACK, 0)

ENUM_CONSTANT_NUMERIC(int32_t, IMPLIED_PRAGMA_ONCE, 1)

ENUM_CONSTANT_NUMERIC(bool, HEADER_LIST, true)

ENUM_CONSTANT_NUMERIC(bool, SIXTEENBIT, false)

ENUM_CONSTANT_NUMERIC(bool, TARGET_SEGMENTED, false)

extern bool LDOUBLE();

ENUM_CONSTANT_NUMERIC(int32_t, NTEXCEPTIONS, 2)

ENUM_CONSTANT_NUMERIC(int32_t, EXIT_BREAK, 255)

typedef int8_t targ_char;

typedef uint8_t targ_uchar;

typedef int8_t targ_schar;

typedef int16_t targ_short;

typedef uint16_t targ_ushort;

typedef int32_t targ_long;

typedef uint32_t targ_ulong;

typedef int64_t targ_llong;

typedef uint64_t targ_ullong;

typedef float targ_float;

typedef double targ_double;

extern uint64_t MSREG(uint64_t p);

typedef int32_t targ_int;

typedef uint32_t targ_uns;

BEGIN_ANON_ENUM()
    ANON_ENUM_KEY(int32_t, CHARSIZE, 1)
    ANON_ENUM_KEY(int32_t, SHORTSIZE, 2)
    ANON_ENUM_KEY(int32_t, WCHARSIZE, 2)
    ANON_ENUM_KEY(int32_t, LONGSIZE, 4)
    ANON_ENUM_KEY(int32_t, LLONGSIZE, 8)
    ANON_ENUM_KEY(int32_t, CENTSIZE, 16)
    ANON_ENUM_KEY(int32_t, FLOATSIZE, 4)
    ANON_ENUM_KEY(int32_t, DOUBLESIZE, 8)
    ANON_ENUM_KEY(int32_t, TMAXSIZE, 16)
END_ANON_ENUM()

ENUM_CONSTANT_NUMERIC(int32_t, REGMASK, 65535)

typedef int64_t targ_ptrdiff_t;

typedef uint64_t targ_size_t;

extern bool MFUNC();

ENUM_CONSTANT_NUMERIC(int32_t, CV3, 0)

ENUM_CONSTANT_NUMERIC(bool, ELFOBJ, true)

ENUM_CONSTANT_NUMERIC(bool, MACHOBJ, false)

ENUM_CONSTANT_NUMERIC(bool, SYMDEB_CODEVIEW, false)

ENUM_CONSTANT_NUMERIC(bool, SYMDEB_DWARF, true)

BEGIN_ANON_ENUM()
    ANON_ENUM_KEY(int32_t, Smodel, 0)
    ANON_ENUM_KEY(int32_t, Mmodel, 1)
    ANON_ENUM_KEY(int32_t, Cmodel, 2)
    ANON_ENUM_KEY(int32_t, Lmodel, 3)
    ANON_ENUM_KEY(int32_t, Vmodel, 4)
END_ANON_ENUM()

ENUM_CONSTANT_NUMERIC(int32_t, MEMMODELS, 1)

BEGIN_ANON_ENUM()
    ANON_ENUM_KEY(int32_t, CODE, 1)
    ANON_ENUM_KEY(int32_t, DATA, 2)
    ANON_ENUM_KEY(int32_t, CDATA, 3)
    ANON_ENUM_KEY(int32_t, UDATA, 4)
    ANON_ENUM_KEY(int32_t, CDATAREL, 5)
    ANON_ENUM_KEY(int32_t, UNKNOWN, -1)
    ANON_ENUM_KEY(int32_t, DGROUPIDX, 1)
END_ANON_ENUM()

ENUM_CONSTANT_NUMERIC(int32_t, REGMAX, 29)

typedef uint32_t tym_t;

typedef int32_t SYMIDX;

BEGIN_ENUM(linkage_t, LINKAGE_T, linkage_t)
    ENUM_KEY(int32_t, LINK_C, 0, linkage_t, LINKAGE_T, linkage_t, )
    ENUM_KEY(int32_t, LINK_CPP, 1, linkage_t, LINKAGE_T, linkage_t, )
    ENUM_KEY(int32_t, LINK_PASCAL, 2, linkage_t, LINKAGE_T, linkage_t, )
    ENUM_KEY(int32_t, LINK_FORTRAN, 3, linkage_t, LINKAGE_T, linkage_t, )
    ENUM_KEY(int32_t, LINK_SYSCALL, 4, linkage_t, LINKAGE_T, linkage_t, )
    ENUM_KEY(int32_t, LINK_STDCALL, 5, linkage_t, LINKAGE_T, linkage_t, )
    ENUM_KEY(int32_t, LINK_D, 6, linkage_t, LINKAGE_T, linkage_t, )
    ENUM_KEY(int32_t, LINK_MAXDIM, 7, linkage_t, LINKAGE_T, linkage_t, )
END_ENUM(linkage_t, LINKAGE_T, linkage_t)

typedef int8_t cpu_target_t;

BEGIN_ANON_ENUM()
    ANON_ENUM_KEY(int32_t, TARGET_8086, 0)
    ANON_ENUM_KEY(int32_t, TARGET_80286, 2)
    ANON_ENUM_KEY(int32_t, TARGET_80386, 3)
    ANON_ENUM_KEY(int32_t, TARGET_80486, 4)
    ANON_ENUM_KEY(int32_t, TARGET_Pentium, 5)
    ANON_ENUM_KEY(int32_t, TARGET_PentiumMMX, 6)
    ANON_ENUM_KEY(int32_t, TARGET_PentiumPro, 7)
    ANON_ENUM_KEY(int32_t, TARGET_PentiumII, 8)
END_ANON_ENUM()

typedef int8_t symbolic_debug_t;

BEGIN_ANON_ENUM()
    ANON_ENUM_KEY(int32_t, CVNONE, 0)
    ANON_ENUM_KEY(int32_t, CVOLD, 1)
    ANON_ENUM_KEY(int32_t, CV4, 2)
    ANON_ENUM_KEY(int32_t, CVSYM, 3)
    ANON_ENUM_KEY(int32_t, CVTDB, 4)
    ANON_ENUM_KEY(int32_t, CVDWARF_C, 5)
    ANON_ENUM_KEY(int32_t, CVDWARF_D, 6)
    ANON_ENUM_KEY(int32_t, CVSTABS, 7)
    ANON_ENUM_KEY(int32_t, CV8, 8)
END_ANON_ENUM()

typedef uint32_t windows_flags_t;

BEGIN_ANON_ENUM()
    ANON_ENUM_KEY(int32_t, WFwindows, 1)
    ANON_ENUM_KEY(int32_t, WFdll, 2)
    ANON_ENUM_KEY(int32_t, WFincbp, 4)
    ANON_ENUM_KEY(int32_t, WFloadds, 8)
    ANON_ENUM_KEY(int32_t, WFexpdef, 16)
    ANON_ENUM_KEY(int32_t, WFss, 32)
    ANON_ENUM_KEY(int32_t, WFreduced, 64)
    ANON_ENUM_KEY(int32_t, WFdgroup, 128)
    ANON_ENUM_KEY(int32_t, WFexport, 256)
    ANON_ENUM_KEY(int32_t, WFds, 512)
    ANON_ENUM_KEY(int32_t, WFmacros, 1024)
    ANON_ENUM_KEY(int32_t, WFssneds, 2048)
    ANON_ENUM_KEY(int32_t, WFthunk, 4096)
    ANON_ENUM_KEY(int32_t, WFsaveds, 8192)
    ANON_ENUM_KEY(int32_t, WFdsnedgroup, 16384)
    ANON_ENUM_KEY(int32_t, WFexe, 32768)
END_ANON_ENUM()

typedef uint32_t objfmt_t;

BEGIN_ANON_ENUM()
    ANON_ENUM_KEY(int32_t, OBJ_OMF, 1)
    ANON_ENUM_KEY(int32_t, OBJ_MSCOFF, 2)
    ANON_ENUM_KEY(int32_t, OBJ_ELF, 4)
    ANON_ENUM_KEY(int32_t, OBJ_MACH, 8)
END_ANON_ENUM()

typedef uint32_t exefmt_t;

BEGIN_ANON_ENUM()
    ANON_ENUM_KEY(int32_t, EX_DOSX, 1)
    ANON_ENUM_KEY(int32_t, EX_ZPM, 2)
    ANON_ENUM_KEY(int32_t, EX_RATIONAL, 4)
    ANON_ENUM_KEY(int32_t, EX_PHARLAP, 8)
    ANON_ENUM_KEY(int32_t, EX_COM, 16)
    ANON_ENUM_KEY(int32_t, EX_OS2, 64)
    ANON_ENUM_KEY(int32_t, EX_OS1, 128)
    ANON_ENUM_KEY(int32_t, EX_WIN32, 256)
    ANON_ENUM_KEY(int32_t, EX_MZ, 512)
    ANON_ENUM_KEY(int32_t, EX_XENIX, 1024)
    ANON_ENUM_KEY(int32_t, EX_SCOUNIX, 2048)
    ANON_ENUM_KEY(int32_t, EX_UNIXSVR4, 4096)
    ANON_ENUM_KEY(int32_t, EX_LINUX, 8192)
    ANON_ENUM_KEY(int32_t, EX_WIN64, 16384)
    ANON_ENUM_KEY(int32_t, EX_LINUX64, 32768)
    ANON_ENUM_KEY(int32_t, EX_OSX, 65536)
    ANON_ENUM_KEY(int32_t, EX_OSX64, 131072)
    ANON_ENUM_KEY(int32_t, EX_FREEBSD, 262144)
    ANON_ENUM_KEY(int32_t, EX_FREEBSD64, 524288)
    ANON_ENUM_KEY(int32_t, EX_SOLARIS, 1048576)
    ANON_ENUM_KEY(int32_t, EX_SOLARIS64, 2097152)
    ANON_ENUM_KEY(int32_t, EX_OPENBSD, 4194304)
    ANON_ENUM_KEY(int32_t, EX_OPENBSD64, 8388608)
    ANON_ENUM_KEY(int32_t, EX_DRAGONFLYBSD64, 16777216)
END_ANON_ENUM()

ENUM_CONSTANT_NUMERIC(uint32_t, EX_flat, 33546560u)

ENUM_CONSTANT_NUMERIC(uint32_t, EX_dos, 543u)

typedef uint32_t config_flags_t;

BEGIN_ANON_ENUM()
    ANON_ENUM_KEY(int32_t, CFGuchar, 1)
    ANON_ENUM_KEY(int32_t, CFGsegs, 2)
    ANON_ENUM_KEY(int32_t, CFGtrace, 4)
    ANON_ENUM_KEY(int32_t, CFGglobal, 8)
    ANON_ENUM_KEY(int32_t, CFGstack, 16)
    ANON_ENUM_KEY(int32_t, CFGalwaysframe, 32)
    ANON_ENUM_KEY(int32_t, CFGnoebp, 64)
    ANON_ENUM_KEY(int32_t, CFGromable, 128)
    ANON_ENUM_KEY(int32_t, CFGeasyomf, 256)
    ANON_ENUM_KEY(int32_t, CFGfarvtbls, 512)
    ANON_ENUM_KEY(int32_t, CFGnoinlines, 1024)
    ANON_ENUM_KEY(int32_t, CFGnowarning, 2048)
END_ANON_ENUM()

typedef uint32_t config_flags2_t;

BEGIN_ANON_ENUM()
    ANON_ENUM_KEY(int32_t, CFG2comdat, 1)
    ANON_ENUM_KEY(int32_t, CFG2nodeflib, 2)
    ANON_ENUM_KEY(int32_t, CFG2browse, 4)
    ANON_ENUM_KEY(int32_t, CFG2dyntyping, 8)
    ANON_ENUM_KEY(int32_t, CFG2fulltypes, 16)
    ANON_ENUM_KEY(int32_t, CFG2warniserr, 32)
    ANON_ENUM_KEY(int32_t, CFG2phauto, 64)
    ANON_ENUM_KEY(int32_t, CFG2phuse, 128)
    ANON_ENUM_KEY(int32_t, CFG2phgen, 256)
    ANON_ENUM_KEY(int32_t, CFG2once, 512)
    ANON_ENUM_KEY(int32_t, CFG2hdrdebug, 1024)
    ANON_ENUM_KEY(int32_t, CFG2phautoy, 2048)
    ANON_ENUM_KEY(int32_t, CFG2noobj, 4096)
    ANON_ENUM_KEY(int32_t, CFG2noerrmax, 8192)
    ANON_ENUM_KEY(int32_t, CFG2expand, 16384)
    ANON_ENUM_KEY(int32_t, CFG2stomp, 32768)
    ANON_ENUM_KEY(int32_t, CFG2gms, 65536)
END_ANON_ENUM()

typedef uint32_t config_flags3_t;

BEGIN_ANON_ENUM()
    ANON_ENUM_KEY(int32_t, CFG3ju, 1)
    ANON_ENUM_KEY(int32_t, CFG3eh, 2)
    ANON_ENUM_KEY(int32_t, CFG3strcod, 4)
    ANON_ENUM_KEY(int32_t, CFG3eseqds, 8)
    ANON_ENUM_KEY(int32_t, CFG3ptrchk, 16)
    ANON_ENUM_KEY(int32_t, CFG3strictproto, 32)
    ANON_ENUM_KEY(int32_t, CFG3autoproto, 64)
    ANON_ENUM_KEY(int32_t, CFG3rtti, 128)
    ANON_ENUM_KEY(int32_t, CFG3relax, 256)
    ANON_ENUM_KEY(int32_t, CFG3cpp, 512)
    ANON_ENUM_KEY(int32_t, CFG3igninc, 1024)
    ANON_ENUM_KEY(int32_t, CFG3mars, 2048)
    ANON_ENUM_KEY(int32_t, CFG3nofar, 4096)
    ANON_ENUM_KEY(int32_t, CFG3noline, 8192)
    ANON_ENUM_KEY(int32_t, CFG3comment, 16384)
    ANON_ENUM_KEY(int32_t, CFG3cppcomment, 32768)
    ANON_ENUM_KEY(int32_t, CFG3wkfloat, 65536)
    ANON_ENUM_KEY(int32_t, CFG3digraphs, 131072)
    ANON_ENUM_KEY(int32_t, CFG3semirelax, 262144)
    ANON_ENUM_KEY(int32_t, CFG3pic, 524288)
    ANON_ENUM_KEY(int32_t, CFG3pie, 1048576)
END_ANON_ENUM()

typedef uint32_t config_flags4_t;

BEGIN_ANON_ENUM()
    ANON_ENUM_KEY(int32_t, CFG4speed, 1)
    ANON_ENUM_KEY(int32_t, CFG4space, 2)
    ANON_ENUM_KEY(int32_t, CFG4allcomdat, 4)
    ANON_ENUM_KEY(int32_t, CFG4fastfloat, 8)
    ANON_ENUM_KEY(int32_t, CFG4fdivcall, 16)
    ANON_ENUM_KEY(int32_t, CFG4tempinst, 32)
    ANON_ENUM_KEY(int32_t, CFG4oldstdmangle, 64)
    ANON_ENUM_KEY(int32_t, CFG4pascal, 128)
    ANON_ENUM_KEY(int32_t, CFG4stdcall, 256)
    ANON_ENUM_KEY(int32_t, CFG4cacheph, 512)
    ANON_ENUM_KEY(int32_t, CFG4alternate, 1024)
    ANON_ENUM_KEY(int32_t, CFG4bool, 2048)
    ANON_ENUM_KEY(int32_t, CFG4wchar_t, 4096)
    ANON_ENUM_KEY(int32_t, CFG4notempexp, 8192)
    ANON_ENUM_KEY(int32_t, CFG4anew, 16384)
    ANON_ENUM_KEY(int32_t, CFG4oldtmangle, 32768)
    ANON_ENUM_KEY(int32_t, CFG4dllrtl, 65536)
    ANON_ENUM_KEY(int32_t, CFG4noemptybaseopt, 131072)
    ANON_ENUM_KEY(int32_t, CFG4nowchar_t, 262144)
    ANON_ENUM_KEY(int32_t, CFG4forscope, 524288)
    ANON_ENUM_KEY(int32_t, CFG4warnccast, 1048576)
    ANON_ENUM_KEY(int32_t, CFG4adl, 2097152)
    ANON_ENUM_KEY(int32_t, CFG4enumoverload, 4194304)
    ANON_ENUM_KEY(int32_t, CFG4implicitfromvoid, 8388608)
    ANON_ENUM_KEY(int32_t, CFG4dependent, 16777216)
    ANON_ENUM_KEY(int32_t, CFG4wchar_is_long, 33554432)
    ANON_ENUM_KEY(int32_t, CFG4underscore, 67108864)
END_ANON_ENUM()

ENUM_CONSTANT_NUMERIC(uint32_t, CFG4optimized, 3u)

ENUM_CONSTANT_NUMERIC(uint32_t, CFG4stackalign, 1u)

typedef uint32_t config_flags5_t;

BEGIN_ANON_ENUM()
    ANON_ENUM_KEY(int32_t, CFG5debug, 1)
    ANON_ENUM_KEY(int32_t, CFG5in, 2)
    ANON_ENUM_KEY(int32_t, CFG5out, 4)
    ANON_ENUM_KEY(int32_t, CFG5invariant, 8)
END_ANON_ENUM()

ENUM_CONSTANT_NUMERIC(uint32_t, CFGX, 2048u)

ENUM_CONSTANT_NUMERIC(uint32_t, CFGX2, 128994u)

ENUM_CONSTANT_NUMERIC(uint32_t, CFGX3, 20u)

ENUM_CONSTANT_NUMERIC(uint32_t, CFGX4, 16785979u)

ENUM_CONSTANT_NUMERIC(uint32_t, CFGY4, 115736576u)

typedef uint32_t htod_flags_t;

BEGIN_ANON_ENUM()
    ANON_ENUM_KEY(int32_t, HTODFinclude, 1)
    ANON_ENUM_KEY(int32_t, HTODFsysinclude, 2)
    ANON_ENUM_KEY(int32_t, HTODFtypedef, 4)
    ANON_ENUM_KEY(int32_t, HTODFcdecl, 8)
END_ANON_ENUM()

struct Config
{
    char language;
    DArray< char > _version;
    char exetype[3LLU];
    int8_t target_cpu;
    int8_t target_scheduler;
    int16_t versionint;
    int32_t defstructalign;
    int16_t hxversion;
    int8_t fulltypes;
    uint32_t wflags;
    bool fpxmmregs;
    uint8_t avx;
    uint8_t inline8087;
    int16_t memmodel;
    uint32_t objfmt;
    uint32_t exe;
    uint32_t flags;
    uint32_t flags2;
    uint32_t flags3;
    uint32_t flags4;
    uint32_t flags5;
    uint32_t htodFlags;
    uint8_t ansi_c;
    uint8_t asian_char;
    uint32_t threshold;
    linkage_t linkage;
    EHmethod ehmethod;
    bool useModuleInfo;
    bool useTypeInfo;
    bool useExceptions;
    Config() : language(), _version(), target_cpu(), target_scheduler(), versionint(), defstructalign(), hxversion(), fulltypes(), wflags(), fpxmmregs(), avx(), inline8087(), memmodel(), objfmt(), exe(), flags(), flags2(), flags3(), flags4(), flags5(), htodFlags(), ansi_c(), asian_char(), threshold(), useModuleInfo(), useTypeInfo(), useExceptions() {}
};

ENUM_CONSTANT_NUMERIC(int32_t, THRESHMAX, 65535)

BEGIN_ENUM(LANG, LANG, lang)
    ENUM_KEY(int32_t, LANGenglish, 0, LANG, LANG, lang, LANG)
    ENUM_KEY(int32_t, LANGgerman, 1, LANG, LANG, lang, LANG)
    ENUM_KEY(int32_t, LANGfrench, 2, LANG, LANG, lang, LANG)
    ENUM_KEY(int32_t, LANGjapanese, 3, LANG, LANG, lang, LANG)
END_ENUM(LANG, LANG, lang)

struct Configv
{
    uint8_t addlinenumbers;
    uint8_t verbose;
    char* csegname;
    char* deflibname;
    LANG language;
    int32_t errmax;
    Configv() : addlinenumbers(), verbose(), csegname(), deflibname(), errmax() {}
};

typedef uint8_t reg_t;

typedef uint32_t regm_t;

struct Cent
{
    targ_ullong lsw;
    targ_ullong msw;
    Cent() : lsw(), msw() {}
};

union eve
{
    int8_t Vchar;
    int8_t Vschar;
    uint8_t Vuchar;
    int16_t Vshort;
    uint16_t Vushort;
    int32_t Vint;
    uint32_t Vuns;
    int32_t Vlong;
    uint32_t Vulong;
    int64_t Vllong;
    targ_ullong Vullong;
    Cent Vcent;
    float Vfloat;
    double Vdouble;
    _d_real Vldouble;
    Complex_f Vcfloat;
    Complex_d Vcdouble;
    Complex_ld Vcldouble;
    targ_size_t Vpointer;
    int64_t Vptrdiff;
    uint8_t Vreg;
    float Vfloat4[4LLU];
    double Vdouble2[2LLU];
    int8_t Vschar16[16LLU];
    uint8_t Vuchar16[16LLU];
    int16_t Vshort8[8LLU];
    uint16_t Vushort8[8LLU];
    int32_t Vlong4[4LLU];
    uint32_t Vulong4[4LLU];
    int64_t Vllong2[2LLU];
    uint64_t Vullong2[2LLU];
    float Vfloat8[8LLU];
    double Vdouble4[4LLU];
    int8_t Vschar32[32LLU];
    uint8_t Vuchar32[32LLU];
    int16_t Vshort16[16LLU];
    uint16_t Vushort16[16LLU];
    int32_t Vlong8[8LLU];
    uint32_t Vulong8[8LLU];
    int64_t Vllong4[4LLU];
    uint64_t Vullong4[4LLU];
    struct
    {
        int32_t Voff;
        uint16_t Vseg;
    };
    struct
    {
        targ_size_t Voffset;
        Symbol* Vsym;
        union
        {
            param_t* Vtal;
            LIST* Erd;
        };
    };
    struct
    {
        targ_size_t Voffset2;
        Symbol* Vsym2;
        elem* ethis;
    };
    struct
    {
        targ_size_t Voffset3;
        char* Vstring;
        targ_size_t Vstrlen;
    };
    struct
    {
        elem* E1;
        elem* E2;
        Symbol* Edtor;
    };
    struct
    {
        elem* Eleft2;
        void* Edecl;
    };
    eve() : Vchar(), Vschar(), Vuchar(), Vshort(), Vushort(), Vint(), Vuns(), Vlong(), Vulong(), Vllong(), Vullong(), Vcent(), Vfloat(), Vdouble(), Vldouble(), Vcfloat(), Vcdouble(), Vcldouble(), Vpointer(), Vptrdiff(), Vreg() {}
};

typedef uint32_t SYMFLGS;

typedef int32_t SC;

BEGIN_ANON_ENUM()
    ANON_ENUM_KEY(int32_t, SCunde, 0)
    ANON_ENUM_KEY(int32_t, SCauto, 1)
    ANON_ENUM_KEY(int32_t, SCstatic, 2)
    ANON_ENUM_KEY(int32_t, SCthread, 3)
    ANON_ENUM_KEY(int32_t, SCextern, 4)
    ANON_ENUM_KEY(int32_t, SCregister, 5)
    ANON_ENUM_KEY(int32_t, SCpseudo, 6)
    ANON_ENUM_KEY(int32_t, SCglobal, 7)
    ANON_ENUM_KEY(int32_t, SCcomdat, 8)
    ANON_ENUM_KEY(int32_t, SCparameter, 9)
    ANON_ENUM_KEY(int32_t, SCregpar, 10)
    ANON_ENUM_KEY(int32_t, SCfastpar, 11)
    ANON_ENUM_KEY(int32_t, SCshadowreg, 12)
    ANON_ENUM_KEY(int32_t, SCtypedef, 13)
    ANON_ENUM_KEY(int32_t, SCexplicit, 14)
    ANON_ENUM_KEY(int32_t, SCmutable, 15)
    ANON_ENUM_KEY(int32_t, SClabel, 16)
    ANON_ENUM_KEY(int32_t, SCstruct, 17)
    ANON_ENUM_KEY(int32_t, SCenum, 18)
    ANON_ENUM_KEY(int32_t, SCfield, 19)
    ANON_ENUM_KEY(int32_t, SCconst, 20)
    ANON_ENUM_KEY(int32_t, SCmember, 21)
    ANON_ENUM_KEY(int32_t, SCanon, 22)
    ANON_ENUM_KEY(int32_t, SCinline, 23)
    ANON_ENUM_KEY(int32_t, SCsinline, 24)
    ANON_ENUM_KEY(int32_t, SCeinline, 25)
    ANON_ENUM_KEY(int32_t, SCoverload, 26)
    ANON_ENUM_KEY(int32_t, SCfriend, 27)
    ANON_ENUM_KEY(int32_t, SCvirtual, 28)
    ANON_ENUM_KEY(int32_t, SClocstat, 29)
    ANON_ENUM_KEY(int32_t, SCtemplate, 30)
    ANON_ENUM_KEY(int32_t, SCfunctempl, 31)
    ANON_ENUM_KEY(int32_t, SCftexpspec, 32)
    ANON_ENUM_KEY(int32_t, SClinkage, 33)
    ANON_ENUM_KEY(int32_t, SCpublic, 34)
    ANON_ENUM_KEY(int32_t, SCcomdef, 35)
    ANON_ENUM_KEY(int32_t, SCbprel, 36)
    ANON_ENUM_KEY(int32_t, SCnamespace, 37)
    ANON_ENUM_KEY(int32_t, SCalias, 38)
    ANON_ENUM_KEY(int32_t, SCfuncalias, 39)
    ANON_ENUM_KEY(int32_t, SCmemalias, 40)
    ANON_ENUM_KEY(int32_t, SCstack, 41)
    ANON_ENUM_KEY(int32_t, SCadl, 42)
    ANON_ENUM_KEY(int32_t, SCMAX, 43)
END_ANON_ENUM()

extern int32_t ClassInline(int32_t c);

extern int32_t SymInline(Symbol* s);

typedef LIST* symlist_t;

extern char* ftdbname;

typedef uint32_t idx_t;

struct debtyp_t
{
    // Ignoring var prev alignment 1
    uint32_t prev;
    // Ignoring var length alignment 1
    uint16_t length;
    // Ignoring var data alignment 1
    uint8_t data[2LLU];
    debtyp_t() {}
};

struct Cgcv
{
    uint32_t signature;
    LIST* list;
    uint32_t deb_offset;
    uint32_t sz_idx;
    int32_t LCFDoffset;
    int32_t LCFDpointer;
    int32_t FD_code;
    Cgcv() : signature(), list(), deb_offset(), sz_idx(), LCFDoffset(), LCFDpointer(), FD_code() {}
};

extern Cgcv cgcv;

extern void TOWORD(uint8_t* a, uint32_t b);

extern void TOLONG(uint8_t* a, uint32_t b);

extern void TOIDX(uint8_t* a, uint32_t b);

ENUM_CONSTANT_NUMERIC(int32_t, DEBSYM, 5)

ENUM_CONSTANT_NUMERIC(int32_t, DEBTYP, 6)

typedef int32_t segidx_t;

struct _Declaration;

struct _LabelDsymbol;

union evc
{
    int32_t Vint;
    uint32_t Vuns;
    int32_t Vlong;
    int64_t Vllong;
    targ_size_t Vsize_t;
    struct
    {
        targ_size_t Vpointer;
        int32_t Vseg;
    };
    Srcpos Vsrcpos;
    elem* Vtor;
    block* Vswitch;
    code* Vcode;
    block* Vblock;
    struct
    {
        targ_size_t Voffset;
        Symbol* Vsym;
    };
    struct
    {
        targ_size_t Vdoffset;
        _Declaration* Vdsym;
    };
    struct
    {
        targ_size_t Vloffset;
        _LabelDsymbol* Vlsym;
    };
    struct
    {
        size_t len;
        char* bytes;
    };
    evc() : Vint(), Vuns(), Vlong(), Vllong(), Vsize_t(), Vsrcpos(), Vtor(), Vswitch(), Vcode(), Vblock() {}
};

extern code* code_next(code* c);

extern code* code_list;

extern code* code_malloc();

extern con_t regcon;

struct REGSAVE
{
    targ_size_t off;
    uint32_t top;
    uint32_t idx;
    int32_t alignment;
    void reset();
    void save(CodeBuilder& cdb, uint8_t reg, uint32_t* pidx);
    void restore(CodeBuilder& cdb, uint8_t reg, uint32_t idx);
    REGSAVE() : off(), top(), idx(), alignment() {}
};

extern REGSAVE regsave;

struct LocalSection
{
    targ_size_t offset;
    targ_size_t size;
    int32_t alignment;
    void init();
    LocalSection() : offset(), size(), alignment() {}
};

extern uint32_t usednteh;

BEGIN_ANON_ENUM()
    ANON_ENUM_KEY(int32_t, NTEH_try, 1)
    ANON_ENUM_KEY(int32_t, NTEH_except, 2)
    ANON_ENUM_KEY(int32_t, NTEHexcspec, 4)
    ANON_ENUM_KEY(int32_t, NTEHcleanup, 8)
    ANON_ENUM_KEY(int32_t, NTEHtry, 16)
    ANON_ENUM_KEY(int32_t, NTEHcpp, 28)
    ANON_ENUM_KEY(int32_t, EHcleanup, 32)
    ANON_ENUM_KEY(int32_t, EHtry, 64)
    ANON_ENUM_KEY(int32_t, NTEHjmonitor, 128)
    ANON_ENUM_KEY(int32_t, NTEHpassthru, 256)
END_ANON_ENUM()

struct CGstate
{
    int32_t stackclean;
    LocalSection funcarg;
    targ_size_t funcargtos;
    bool accessedTLS;
    CGstate() : stackclean(), funcarg(), funcargtos(), accessedTLS() {}
};

ENUM_CONSTANT_NUMERIC(int32_t, GENSINDEXSIZE, 7)

typedef uint32_t IDXSTR;

typedef uint32_t IDXSEC;

typedef uint32_t IDXSYM;

struct seg_data
{
    int32_t SDseg;
    targ_size_t SDoffset;
    int32_t SDalignment;
    uint32_t SDshtidx;
    Outbuffer* SDbuf;
    Outbuffer* SDrel;
    uint32_t SDsymidx;
    uint32_t SDrelidx;
    targ_size_t SDrelmaxoff;
    int32_t SDrelindex;
    int32_t SDrelcnt;
    uint32_t SDshtidxout;
    Symbol* SDsym;
    int32_t SDassocseg;
    uint32_t SDaranges_offset;
    Barray<linnum_data> SDlinnum_data;
    seg_data() : SDseg(), SDoffset(), SDalignment(), SDshtidx(), SDbuf(), SDrel(), SDsymidx(), SDrelidx(), SDrelmaxoff(), SDrelindex(), SDrelcnt(), SDshtidxout(), SDsym(), SDassocseg(), SDaranges_offset(), SDlinnum_data() {}
};

struct linnum_data
{
    const char* filename;
    uint32_t filenumber;
    Barray<LinOff> linoff;
    linnum_data() : filename(), filenumber(), linoff() {}
};

struct LinOff
{
    uint32_t lineNumber;
    uint32_t offset;
    LinOff() : lineNumber(), offset() {}
};

extern Rarray<seg_data*> SegData;

extern targ_size_t& Offset(int32_t seg);

extern targ_size_t& Doffset();

extern targ_size_t& CDoffset();

struct FuncParamRegs
{
    static FuncParamRegs create(uint32_t tyf);
    int32_t alloc(TYPE* t, uint32_t ty, uint8_t* reg1, uint8_t* reg2);
    uint32_t tyf;
    int32_t i;
    int32_t regcnt;
    int32_t xmmcnt;
    uint32_t numintegerregs;
    uint32_t numfloatregs;
    const uint8_t* argregs;
    const uint8_t* floatregs;
    FuncParamRegs() {}
};

extern uint32_t msavereg;

extern uint32_t mfuncreg;

extern uint32_t allregs;

extern int32_t BPRM;

extern uint32_t FLOATREGS;

extern uint32_t FLOATREGS2;

extern uint32_t DOUBLEREGS;

extern char needframe;

extern char gotref;

extern targ_size_t localsize;

extern targ_size_t funcoffset;

extern targ_size_t framehandleroffset;

extern int32_t cseg;

extern int32_t STACKALIGN;

extern int32_t TARGET_STACKALIGN;

extern LocalSection Para;

extern LocalSection Fast;

extern LocalSection Auto;

extern LocalSection EEStack;

extern LocalSection Alloca;

extern int32_t pass;

BEGIN_ANON_ENUM()
    ANON_ENUM_KEY(int32_t, PASSinitial, 0)
    ANON_ENUM_KEY(int32_t, PASSreg, 1)
    ANON_ENUM_KEY(int32_t, PASSfinal, 2)
END_ANON_ENUM()

extern int32_t dfoidx;

extern bool floatreg;

extern targ_size_t prolog_allocoffset;

extern targ_size_t startoffset;

extern targ_size_t retoffset;

extern targ_size_t retsize;

extern uint32_t stackpush;

extern int32_t stackchanged;

extern int32_t refparam;

extern int32_t reflocal;

extern bool anyiasm;

extern char calledafunc;

extern bool calledFinally;

extern uint8_t findregmsw(uint32_t regm);

extern uint8_t findreglsw(uint32_t regm);

extern int32_t clib_inited;

extern void searchfixlist(Symbol* s);

extern int32_t hasframe;

extern bool enforcealign;

extern targ_size_t spoff;

extern targ_size_t Foff;

extern targ_size_t CSoff;

extern targ_size_t NDPoff;

extern targ_size_t pushoff;

extern bool pushoffuse;

extern int32_t BPoff;

extern int32_t EBPtoESP;

extern const uint8_t dblreg[4LLU];

extern int32_t cdcmp_flag;

extern void regimmed_set(int32_t reg, targ_size_t e);

ENUM_CONSTANT_NUMERIC(int32_t, OEM, 66)

BEGIN_ANON_ENUM()
    ANON_ENUM_KEY(int32_t, S_COMPILE, 1)
    ANON_ENUM_KEY(int32_t, S_REGISTER, 2)
    ANON_ENUM_KEY(int32_t, S_CONST, 3)
    ANON_ENUM_KEY(int32_t, S_UDT, 4)
    ANON_ENUM_KEY(int32_t, S_SSEARCH, 5)
    ANON_ENUM_KEY(int32_t, S_END, 6)
    ANON_ENUM_KEY(int32_t, S_SKIP, 7)
    ANON_ENUM_KEY(int32_t, S_CVRESERVE, 8)
    ANON_ENUM_KEY(int32_t, S_OBJNAME, 9)
    ANON_ENUM_KEY(int32_t, S_ENDARG, 10)
    ANON_ENUM_KEY(int32_t, S_COBOLUDT, 11)
    ANON_ENUM_KEY(int32_t, S_MANYREG, 12)
    ANON_ENUM_KEY(int32_t, S_RETURN, 13)
    ANON_ENUM_KEY(int32_t, S_ENTRYTHIS, 14)
    ANON_ENUM_KEY(int32_t, S_TDBNAME, 15)
    ANON_ENUM_KEY(int32_t, S_BPREL16, 256)
    ANON_ENUM_KEY(int32_t, S_LDATA16, 257)
    ANON_ENUM_KEY(int32_t, S_GDATA16, 258)
    ANON_ENUM_KEY(int32_t, S_PUB16, 259)
    ANON_ENUM_KEY(int32_t, S_LPROC16, 260)
    ANON_ENUM_KEY(int32_t, S_GPROC16, 261)
    ANON_ENUM_KEY(int32_t, S_THUNK16, 262)
    ANON_ENUM_KEY(int32_t, S_BLOCK16, 263)
    ANON_ENUM_KEY(int32_t, S_WITH16, 264)
    ANON_ENUM_KEY(int32_t, S_LABEL16, 265)
    ANON_ENUM_KEY(int32_t, S_CEXMODEL16, 266)
    ANON_ENUM_KEY(int32_t, S_VFTPATH16, 267)
    ANON_ENUM_KEY(int32_t, S_BPREL32, 512)
    ANON_ENUM_KEY(int32_t, S_LDATA32, 513)
    ANON_ENUM_KEY(int32_t, S_GDATA32, 514)
    ANON_ENUM_KEY(int32_t, S_PUB32, 515)
    ANON_ENUM_KEY(int32_t, S_LPROC32, 516)
    ANON_ENUM_KEY(int32_t, S_GPROC32, 517)
    ANON_ENUM_KEY(int32_t, S_THUNK32, 518)
    ANON_ENUM_KEY(int32_t, S_BLOCK32, 519)
    ANON_ENUM_KEY(int32_t, S_WITH32, 520)
    ANON_ENUM_KEY(int32_t, S_LABEL32, 521)
    ANON_ENUM_KEY(int32_t, S_CEXMODEL32, 522)
    ANON_ENUM_KEY(int32_t, S_VFTPATH32, 523)
    ANON_ENUM_KEY(int32_t, S_REGISTER_V2, 4097)
    ANON_ENUM_KEY(int32_t, S_CONSTANT_V2, 4098)
    ANON_ENUM_KEY(int32_t, S_UDT_V2, 4099)
    ANON_ENUM_KEY(int32_t, S_COBOLUDT_V2, 4100)
    ANON_ENUM_KEY(int32_t, S_MANYREG_V2, 4101)
    ANON_ENUM_KEY(int32_t, S_BPREL_V2, 4102)
    ANON_ENUM_KEY(int32_t, S_LDATA_V2, 4103)
    ANON_ENUM_KEY(int32_t, S_GDATA_V2, 4104)
    ANON_ENUM_KEY(int32_t, S_PUB_V2, 4105)
    ANON_ENUM_KEY(int32_t, S_LPROC_V2, 4106)
    ANON_ENUM_KEY(int32_t, S_GPROC_V2, 4107)
    ANON_ENUM_KEY(int32_t, S_VFTTABLE_V2, 4108)
    ANON_ENUM_KEY(int32_t, S_REGREL_V2, 4109)
    ANON_ENUM_KEY(int32_t, S_LTHREAD_V2, 4110)
    ANON_ENUM_KEY(int32_t, S_GTHREAD_V2, 4111)
    ANON_ENUM_KEY(int32_t, S_FUNCINFO_V2, 4114)
    ANON_ENUM_KEY(int32_t, S_COMPILAND_V2, 4115)
    ANON_ENUM_KEY(int32_t, S_COMPILAND_V3, 4353)
    ANON_ENUM_KEY(int32_t, S_THUNK_V3, 4354)
    ANON_ENUM_KEY(int32_t, S_BLOCK_V3, 4355)
    ANON_ENUM_KEY(int32_t, S_LABEL_V3, 4357)
    ANON_ENUM_KEY(int32_t, S_REGISTER_V3, 4358)
    ANON_ENUM_KEY(int32_t, S_CONSTANT_V3, 4359)
    ANON_ENUM_KEY(int32_t, S_UDT_V3, 4360)
    ANON_ENUM_KEY(int32_t, S_BPREL_V3, 4363)
    ANON_ENUM_KEY(int32_t, S_LDATA_V3, 4364)
    ANON_ENUM_KEY(int32_t, S_GDATA_V3, 4365)
    ANON_ENUM_KEY(int32_t, S_PUB_V3, 4366)
    ANON_ENUM_KEY(int32_t, S_LPROC_V3, 4367)
    ANON_ENUM_KEY(int32_t, S_GPROC_V3, 4368)
    ANON_ENUM_KEY(int32_t, S_BPREL_XXXX_V3, 4369)
    ANON_ENUM_KEY(int32_t, S_MSTOOL_V3, 4374)
    ANON_ENUM_KEY(int32_t, S_PUB_FUNC1_V3, 4389)
    ANON_ENUM_KEY(int32_t, S_PUB_FUNC2_V3, 4391)
    ANON_ENUM_KEY(int32_t, S_SECTINFO_V3, 4406)
    ANON_ENUM_KEY(int32_t, S_SUBSECTINFO_V3, 4407)
    ANON_ENUM_KEY(int32_t, S_ENTRYPOINT_V3, 4408)
    ANON_ENUM_KEY(int32_t, S_SECUCOOKIE_V3, 4410)
    ANON_ENUM_KEY(int32_t, S_MSTOOLINFO_V3, 4412)
    ANON_ENUM_KEY(int32_t, S_MSTOOLENV_V3, 4413)
END_ANON_ENUM()

BEGIN_ANON_ENUM()
    ANON_ENUM_KEY(int32_t, LF_MODIFIER, 1)
    ANON_ENUM_KEY(int32_t, LF_POINTER, 2)
    ANON_ENUM_KEY(int32_t, LF_ARRAY, 3)
    ANON_ENUM_KEY(int32_t, LF_CLASS, 4)
    ANON_ENUM_KEY(int32_t, LF_STRUCTURE, 5)
    ANON_ENUM_KEY(int32_t, LF_UNION, 6)
    ANON_ENUM_KEY(int32_t, LF_ENUM, 7)
    ANON_ENUM_KEY(int32_t, LF_PROCEDURE, 8)
    ANON_ENUM_KEY(int32_t, LF_MFUNCTION, 9)
    ANON_ENUM_KEY(int32_t, LF_VTSHAPE, 10)
    ANON_ENUM_KEY(int32_t, LF_COBOL0, 11)
    ANON_ENUM_KEY(int32_t, LF_COBOL1, 12)
    ANON_ENUM_KEY(int32_t, LF_BARRAY, 13)
    ANON_ENUM_KEY(int32_t, LF_LABEL, 14)
    ANON_ENUM_KEY(int32_t, LF_NULL, 15)
    ANON_ENUM_KEY(int32_t, LF_NOTTRAN, 16)
    ANON_ENUM_KEY(int32_t, LF_DIMARRAY, 17)
    ANON_ENUM_KEY(int32_t, LF_VFTPATH, 18)
    ANON_ENUM_KEY(int32_t, LF_PRECOMP, 19)
    ANON_ENUM_KEY(int32_t, LF_ENDPRECOMP, 20)
    ANON_ENUM_KEY(int32_t, LF_OEM, 21)
    ANON_ENUM_KEY(int32_t, LF_TYPESERVER, 22)
    ANON_ENUM_KEY(int32_t, LF_DYN_ARRAY, 23)
    ANON_ENUM_KEY(int32_t, LF_ASSOC_ARRAY, 24)
    ANON_ENUM_KEY(int32_t, LF_DELEGATE, 25)
    ANON_ENUM_KEY(int32_t, LF_SKIP, 512)
    ANON_ENUM_KEY(int32_t, LF_ARGLIST, 513)
    ANON_ENUM_KEY(int32_t, LF_DEFARG, 514)
    ANON_ENUM_KEY(int32_t, LF_LIST, 515)
    ANON_ENUM_KEY(int32_t, LF_FIELDLIST, 516)
    ANON_ENUM_KEY(int32_t, LF_DERIVED, 517)
    ANON_ENUM_KEY(int32_t, LF_BITFIELD, 518)
    ANON_ENUM_KEY(int32_t, LF_METHODLIST, 519)
    ANON_ENUM_KEY(int32_t, LF_DIMCONU, 520)
    ANON_ENUM_KEY(int32_t, LF_DIMCONLU, 521)
    ANON_ENUM_KEY(int32_t, LF_DIMVARU, 522)
    ANON_ENUM_KEY(int32_t, LF_DIMVARLU, 523)
    ANON_ENUM_KEY(int32_t, LF_REFSYM, 524)
    ANON_ENUM_KEY(int32_t, LF_BCLASS, 1024)
    ANON_ENUM_KEY(int32_t, LF_VBCLASS, 1025)
    ANON_ENUM_KEY(int32_t, LF_IVBCLASS, 1026)
    ANON_ENUM_KEY(int32_t, LF_ENUMERATE, 1027)
    ANON_ENUM_KEY(int32_t, LF_FRIENDFCN, 1028)
    ANON_ENUM_KEY(int32_t, LF_INDEX, 1029)
    ANON_ENUM_KEY(int32_t, LF_MEMBER, 1030)
    ANON_ENUM_KEY(int32_t, LF_STMEMBER, 1031)
    ANON_ENUM_KEY(int32_t, LF_METHOD, 1032)
    ANON_ENUM_KEY(int32_t, LF_NESTTYPE, 1033)
    ANON_ENUM_KEY(int32_t, LF_VFUNCTAB, 1034)
    ANON_ENUM_KEY(int32_t, LF_FRIENDCLS, 1035)
    ANON_ENUM_KEY(int32_t, LF_NUMERIC, 32768)
    ANON_ENUM_KEY(int32_t, LF_CHAR, 32768)
    ANON_ENUM_KEY(int32_t, LF_SHORT, 32769)
    ANON_ENUM_KEY(int32_t, LF_USHORT, 32770)
    ANON_ENUM_KEY(int32_t, LF_LONG, 32771)
    ANON_ENUM_KEY(int32_t, LF_ULONG, 32772)
    ANON_ENUM_KEY(int32_t, LF_REAL32, 32773)
    ANON_ENUM_KEY(int32_t, LF_REAL64, 32774)
    ANON_ENUM_KEY(int32_t, LF_REAL80, 32775)
    ANON_ENUM_KEY(int32_t, LF_REAL128, 32776)
    ANON_ENUM_KEY(int32_t, LF_QUADWORD, 32777)
    ANON_ENUM_KEY(int32_t, LF_UQUADWORD, 32778)
    ANON_ENUM_KEY(int32_t, LF_REAL48, 32779)
    ANON_ENUM_KEY(int32_t, LF_COMPLEX32, 32780)
    ANON_ENUM_KEY(int32_t, LF_COMPLEX64, 32781)
    ANON_ENUM_KEY(int32_t, LF_COMPLEX80, 32782)
    ANON_ENUM_KEY(int32_t, LF_COMPLEX128, 32783)
    ANON_ENUM_KEY(int32_t, LF_VARSTRING, 32784)
    ANON_ENUM_KEY(int32_t, LF_MODIFIER_V2, 4097)
    ANON_ENUM_KEY(int32_t, LF_POINTER_V2, 4098)
    ANON_ENUM_KEY(int32_t, LF_ARRAY_V2, 4099)
    ANON_ENUM_KEY(int32_t, LF_CLASS_V2, 4100)
    ANON_ENUM_KEY(int32_t, LF_STRUCTURE_V2, 4101)
    ANON_ENUM_KEY(int32_t, LF_UNION_V2, 4102)
    ANON_ENUM_KEY(int32_t, LF_ENUM_V2, 4103)
    ANON_ENUM_KEY(int32_t, LF_PROCEDURE_V2, 4104)
    ANON_ENUM_KEY(int32_t, LF_MFUNCTION_V2, 4105)
    ANON_ENUM_KEY(int32_t, LF_COBOL0_V2, 4106)
    ANON_ENUM_KEY(int32_t, LF_BARRAY_V2, 4107)
    ANON_ENUM_KEY(int32_t, LF_DIMARRAY_V2, 4108)
    ANON_ENUM_KEY(int32_t, LF_VFTPATH_V2, 4109)
    ANON_ENUM_KEY(int32_t, LF_PRECOMP_V2, 4110)
    ANON_ENUM_KEY(int32_t, LF_OEM_V2, 4111)
    ANON_ENUM_KEY(int32_t, LF_SKIP_V2, 4608)
    ANON_ENUM_KEY(int32_t, LF_ARGLIST_V2, 4609)
    ANON_ENUM_KEY(int32_t, LF_DEFARG_V2, 4610)
    ANON_ENUM_KEY(int32_t, LF_FIELDLIST_V2, 4611)
    ANON_ENUM_KEY(int32_t, LF_DERIVED_V2, 4612)
    ANON_ENUM_KEY(int32_t, LF_BITFIELD_V2, 4613)
    ANON_ENUM_KEY(int32_t, LF_METHODLIST_V2, 4614)
    ANON_ENUM_KEY(int32_t, LF_DIMCONU_V2, 4615)
    ANON_ENUM_KEY(int32_t, LF_DIMCONLU_V2, 4616)
    ANON_ENUM_KEY(int32_t, LF_DIMVARU_V2, 4617)
    ANON_ENUM_KEY(int32_t, LF_DIMVARLU_V2, 4618)
    ANON_ENUM_KEY(int32_t, LF_BCLASS_V2, 5120)
    ANON_ENUM_KEY(int32_t, LF_VBCLASS_V2, 5121)
    ANON_ENUM_KEY(int32_t, LF_IVBCLASS_V2, 5122)
    ANON_ENUM_KEY(int32_t, LF_FRIENDFCN_V2, 5123)
    ANON_ENUM_KEY(int32_t, LF_INDEX_V2, 5124)
    ANON_ENUM_KEY(int32_t, LF_MEMBER_V2, 5125)
    ANON_ENUM_KEY(int32_t, LF_STMEMBER_V2, 5126)
    ANON_ENUM_KEY(int32_t, LF_METHOD_V2, 5127)
    ANON_ENUM_KEY(int32_t, LF_NESTTYPE_V2, 5128)
    ANON_ENUM_KEY(int32_t, LF_VFUNCTAB_V2, 5129)
    ANON_ENUM_KEY(int32_t, LF_FRIENDCLS_V2, 5130)
    ANON_ENUM_KEY(int32_t, LF_ONEMETHOD_V2, 5131)
    ANON_ENUM_KEY(int32_t, LF_VFUNCOFF_V2, 5132)
    ANON_ENUM_KEY(int32_t, LF_NESTTYPEEX_V2, 5133)
    ANON_ENUM_KEY(int32_t, LF_ENUMERATE_V3, 5378)
    ANON_ENUM_KEY(int32_t, LF_ARRAY_V3, 5379)
    ANON_ENUM_KEY(int32_t, LF_CLASS_V3, 5380)
    ANON_ENUM_KEY(int32_t, LF_STRUCTURE_V3, 5381)
    ANON_ENUM_KEY(int32_t, LF_UNION_V3, 5382)
    ANON_ENUM_KEY(int32_t, LF_ENUM_V3, 5383)
    ANON_ENUM_KEY(int32_t, LF_MEMBER_V3, 5389)
    ANON_ENUM_KEY(int32_t, LF_STMEMBER_V3, 5390)
    ANON_ENUM_KEY(int32_t, LF_METHOD_V3, 5391)
    ANON_ENUM_KEY(int32_t, LF_NESTTYPE_V3, 5392)
    ANON_ENUM_KEY(int32_t, LF_ONEMETHOD_V3, 5393)
END_ANON_ENUM()

extern void dt_free(dt_t* dt);

extern void dt_term();

extern dt_t** dtend(dt_t** pdtend);

extern void dtpatchoffset(dt_t* dt, uint32_t offset);

extern void init_common(Symbol* s);

extern uint32_t dt_size(const dt_t* dtstart);

extern bool dtallzeros(const dt_t* dt);

extern bool dtpointers(const dt_t* dtstart);

extern void dt2common(dt_t** pdt);

struct DtBuilder
{
    dt_t* head;
    dt_t** pTail;
    DtBuilder(int32_t dummy);
    dt_t* finish();
    void nbytes(uint32_t size, const char* ptr);
    void abytes(uint32_t ty, uint32_t offset, uint32_t size, const char* ptr, uint32_t nzeros, uint8_t _align);
    void abytes(uint32_t offset, uint32_t size, const char* ptr, uint32_t nzeros, uint8_t _align);
    void dword(int32_t value);
    void size(uint64_t value);
    void nzeros(uint32_t size);
    void xoff(Symbol* s, uint32_t offset, uint32_t ty);
    void xoff(Symbol* s, uint32_t offset);
    dt_t* xoffpatch(Symbol* s, uint32_t offset, uint32_t ty);
    Symbol* dtoff(dt_t* dt, uint32_t offset);
    void coff(uint32_t offset);
    void cat(dt_t* dt);
    void cat(DtBuilder& dtb);
    void repeat(dt_t* dt, size_t count);
    uint32_t length();
    bool isZeroLength();
    DtBuilder() {}
};

extern dt_t* dt_get_nzeros(uint32_t n);

typedef uint8_t eflags_t;

BEGIN_ANON_ENUM()
    ANON_ENUM_KEY(int32_t, EFLAGS_variadic, 1)
END_ANON_ENUM()

typedef uint32_t pef_flags_t;

BEGIN_ANON_ENUM()
    ANON_ENUM_KEY(int32_t, PEFnotlvalue, 1)
    ANON_ENUM_KEY(int32_t, PEFtemplate_id, 16)
    ANON_ENUM_KEY(int32_t, PEFparentheses, 32)
    ANON_ENUM_KEY(int32_t, PEFaddrmem, 64)
    ANON_ENUM_KEY(int32_t, PEFdependent, 128)
    ANON_ENUM_KEY(int32_t, PEFmember, 256)
END_ANON_ENUM()

typedef uint8_t nflags_t;

BEGIN_ANON_ENUM()
    ANON_ENUM_KEY(int32_t, NFLli, 1)
    ANON_ENUM_KEY(int32_t, NFLnogoal, 2)
    ANON_ENUM_KEY(int32_t, NFLassign, 8)
    ANON_ENUM_KEY(int32_t, NFLdelcse, 64)
    ANON_ENUM_KEY(int32_t, NFLtouns, 128)
END_ANON_ENUM()

struct elem
{
    ENUM_CONSTANT_NUMERIC(int32_t, IDelem, 19525)

    eve EV;
    uint8_t Eoper;
    uint8_t Ecount;
    uint8_t Eflags;
    union
    {
        struct
        {
            uint32_t PEFflags;
        };
        struct
        {
            uint32_t Ety;
            uint32_t Eexp;
            uint32_t Edef;
            uint8_t Nflags;
            uint8_t Ejty;
        };
        struct
        {
            uint32_t Ety2;
            uint8_t Ecomsub;
        };
    };
    TYPE* ET;
    Srcpos Esrcpos;
    elem() : Eoper(), Ecount(), Eflags(), ET(), Esrcpos() {}
};

extern void elem_debug(const elem* const e);

extern uint32_t typemask(const elem* const e);

extern int32_t el_fl(const elem* const e);

extern elem* list_elem(LIST* list);

extern void list_setelem(LIST* list, void* ptr);

extern char debuga;

extern char debugb;

extern char debugc;

extern char debugd;

extern char debuge;

extern char debugf;

extern char debugg;

extern char debugo;

extern char debugr;

extern char debugs;

extern char debugt;

extern char debugu;

extern char debugw;

extern char debugx;

extern char debugy;

ENUM_CONSTANT_NUMERIC(char, CR, 13u)

ENUM_CONSTANT_NUMERIC(char, LF, 10u)

ENUM_CONSTANT(const char*, CR_STR, "\x0d")

ENUM_CONSTANT(const char*, LF_STR, "\x0a")

extern const uint32_t mask[32LLU];

extern const uint32_t maskl[32LLU];

extern char* argv0;

extern char* finname;

extern char* foutname;

extern char* foutdir;

extern char OPTIMIZER;

extern char PARSER;

extern symtab_t globsym;

extern char sytab[43LLU];

extern "C" int32_t controlc_saw;

extern uint32_t maxblks;

extern uint32_t numblks;

extern block* startblock;

extern Barray<block*> dfo;

extern block* curblock;

extern block* block_last;

extern int32_t errcnt;

extern uint32_t fregsaved;

extern uint32_t pointertype;

extern Symbol* localgot;

extern Symbol* tls_get_addr_sym;

extern Configv configv;

extern void* util_malloc(uint32_t n, uint32_t size);

extern void* util_calloc(uint32_t n, uint32_t size);

extern void util_free(void* p);

extern void* util_realloc(void* oldp, uint32_t n, uint32_t size);

extern int32_t errmsgs_tx86idx;

extern uint8_t pseudoreg[24LLU];

extern uint32_t pseudomask[24LLU];

extern void symbol_keep(Symbol* s);

extern uint32_t bc_goal[20LLU];

extern const char* regstring[32LLU];

class Obj
{
public:
    static Obj* init(Outbuffer* objbuf, const char* filename, const char* csegname);
    static void initfile(const char* filename, const char* csegname, const char* modname);
    static void termfile();
    static void term(const char* objfilename);
    static void linnum(Srcpos srcpos, int32_t seg, targ_size_t offset);
    static int32_t codeseg(const char* const name, int32_t suffix);
    static void startaddress(Symbol* s);
    static bool includelib(const char* name);
    static bool linkerdirective(const char* p);
    static bool allowZeroSize();
    static void exestr(const char* p);
    static void user(const char* p);
    static void compiler();
    static void wkext(Symbol* s1, Symbol* s2);
    static void _alias(const char* n1, const char* n2);
    static void staticctor(Symbol* s, int32_t dtor, int32_t seg);
    static void staticdtor(Symbol* s);
    static void setModuleCtorDtor(Symbol* s, bool isCtor);
    static void ehtables(Symbol* sfunc, uint32_t size, Symbol* ehsym);
    static void ehsections();
    static void moduleinfo(Symbol* scc);
    static int32_t comdat(Symbol* s);
    static int32_t comdatsize(Symbol* s, targ_size_t symsize);
    static int32_t readonly_comdat(Symbol* s);
    static void setcodeseg(int32_t seg);
    static seg_data* tlsseg();
    static seg_data* tlsseg_bss();
    static seg_data* tlsseg_data();
    static void export_symbol(Symbol* s, uint32_t argsize);
    static void pubdef(int32_t seg, Symbol* s, targ_size_t offset);
    static void pubdefsize(int32_t seg, Symbol* s, targ_size_t offset, targ_size_t symsize);
    static int32_t external_def(const char* name);
    static int32_t data_start(Symbol* sdata, targ_size_t datasize, int32_t seg);
    static int32_t external(Symbol* s);
    static int32_t common_block(Symbol* s, targ_size_t size, targ_size_t count);
    static int32_t common_block(Symbol* s, int32_t flag, targ_size_t size, targ_size_t count);
    static void lidata(int32_t seg, targ_size_t offset, targ_size_t count);
    static void write_zeros(seg_data* pseg, targ_size_t count);
    static void write_byte(seg_data* pseg, uint32_t _byte);
    static void write_bytes(seg_data* pseg, uint32_t nbytes, void* p);
    static void _byte(int32_t seg, targ_size_t offset, uint32_t _byte);
    static uint32_t bytes(int32_t seg, targ_size_t offset, uint32_t nbytes, void* p);
    static void reftodatseg(int32_t seg, targ_size_t offset, targ_size_t val, uint32_t targetdatum, int32_t flags);
    static void reftocodeseg(int32_t seg, targ_size_t offset, targ_size_t val);
    static int32_t reftoident(int32_t seg, targ_size_t offset, Symbol* s, targ_size_t val, int32_t flags);
    static void far16thunk(Symbol* s);
    static void fltused();
    static int32_t data_readonly(char* p, int32_t len, int32_t* pseg);
    static int32_t data_readonly(char* p, int32_t len);
    static int32_t string_literal_segment(uint32_t sz);
    static Symbol* sym_cdata(uint32_t ty, char* p, int32_t len);
    static void func_start(Symbol* sfunc);
    static void func_term(Symbol* sfunc);
    static void write_pointerRef(Symbol* s, uint32_t off);
    static int32_t jmpTableSegment(Symbol* s);
    static Symbol* tlv_bootstrap();
    static void gotref(Symbol* s);
    static uint32_t addstr(Outbuffer* strtab, const char* p);
    static Symbol* getGOTsym();
    static void refGOTsym();
    static int32_t getsegment(const char* name, const char* suffix, int32_t type, int32_t flags, int32_t align_);
    static void addrel(int32_t seg, targ_size_t offset, uint32_t type, uint32_t symidx, targ_size_t val);
    static size_t writerel(int32_t targseg, size_t offset, uint32_t type, uint32_t symidx, targ_size_t val);
};

extern Obj* objmod;

typedef int32_t OPER;

BEGIN_ANON_ENUM()
    ANON_ENUM_KEY(int32_t, OPunde, 0)
    ANON_ENUM_KEY(int32_t, OPadd, 1)
    ANON_ENUM_KEY(int32_t, OPmin, 2)
    ANON_ENUM_KEY(int32_t, OPmul, 3)
    ANON_ENUM_KEY(int32_t, OPdiv, 4)
    ANON_ENUM_KEY(int32_t, OPmod, 5)
    ANON_ENUM_KEY(int32_t, OPshr, 6)
    ANON_ENUM_KEY(int32_t, OPshl, 7)
    ANON_ENUM_KEY(int32_t, OPand, 8)
    ANON_ENUM_KEY(int32_t, OPxor, 9)
    ANON_ENUM_KEY(int32_t, OPor, 10)
    ANON_ENUM_KEY(int32_t, OPashr, 11)
    ANON_ENUM_KEY(int32_t, OPnot, 12)
    ANON_ENUM_KEY(int32_t, OPbool, 13)
    ANON_ENUM_KEY(int32_t, OPcom, 14)
    ANON_ENUM_KEY(int32_t, OPcond, 15)
    ANON_ENUM_KEY(int32_t, OPcomma, 16)
    ANON_ENUM_KEY(int32_t, OPoror, 17)
    ANON_ENUM_KEY(int32_t, OPandand, 18)
    ANON_ENUM_KEY(int32_t, OPbit, 19)
    ANON_ENUM_KEY(int32_t, OPind, 20)
    ANON_ENUM_KEY(int32_t, OPaddr, 21)
    ANON_ENUM_KEY(int32_t, OPneg, 22)
    ANON_ENUM_KEY(int32_t, OPuadd, 23)
    ANON_ENUM_KEY(int32_t, OPvoid, 24)
    ANON_ENUM_KEY(int32_t, OPabs, 25)
    ANON_ENUM_KEY(int32_t, OPtoprec, 26)
    ANON_ENUM_KEY(int32_t, OPrndtol, 27)
    ANON_ENUM_KEY(int32_t, OPrint, 28)
    ANON_ENUM_KEY(int32_t, OPsqrt, 29)
    ANON_ENUM_KEY(int32_t, OPsin, 30)
    ANON_ENUM_KEY(int32_t, OPcos, 31)
    ANON_ENUM_KEY(int32_t, OPscale, 32)
    ANON_ENUM_KEY(int32_t, OPyl2x, 33)
    ANON_ENUM_KEY(int32_t, OPyl2xp1, 34)
    ANON_ENUM_KEY(int32_t, OPcmpxchg, 35)
    ANON_ENUM_KEY(int32_t, OPstrlen, 36)
    ANON_ENUM_KEY(int32_t, OPstrcpy, 37)
    ANON_ENUM_KEY(int32_t, OPstrcat, 38)
    ANON_ENUM_KEY(int32_t, OPstrcmp, 39)
    ANON_ENUM_KEY(int32_t, OPmemcpy, 40)
    ANON_ENUM_KEY(int32_t, OPmemcmp, 41)
    ANON_ENUM_KEY(int32_t, OPmemset, 42)
    ANON_ENUM_KEY(int32_t, OPsetjmp, 43)
    ANON_ENUM_KEY(int32_t, OPremquo, 44)
    ANON_ENUM_KEY(int32_t, OPbsf, 45)
    ANON_ENUM_KEY(int32_t, OPbsr, 46)
    ANON_ENUM_KEY(int32_t, OPbt, 47)
    ANON_ENUM_KEY(int32_t, OPbtc, 48)
    ANON_ENUM_KEY(int32_t, OPbtr, 49)
    ANON_ENUM_KEY(int32_t, OPbts, 50)
    ANON_ENUM_KEY(int32_t, OPbswap, 51)
    ANON_ENUM_KEY(int32_t, OProl, 52)
    ANON_ENUM_KEY(int32_t, OPror, 53)
    ANON_ENUM_KEY(int32_t, OPbtst, 54)
    ANON_ENUM_KEY(int32_t, OPpopcnt, 55)
    ANON_ENUM_KEY(int32_t, OPstreq, 56)
    ANON_ENUM_KEY(int32_t, OPnegass, 57)
    ANON_ENUM_KEY(int32_t, OPpostinc, 58)
    ANON_ENUM_KEY(int32_t, OPpostdec, 59)
    ANON_ENUM_KEY(int32_t, OPeq, 60)
    ANON_ENUM_KEY(int32_t, OPaddass, 61)
    ANON_ENUM_KEY(int32_t, OPminass, 62)
    ANON_ENUM_KEY(int32_t, OPmulass, 63)
    ANON_ENUM_KEY(int32_t, OPdivass, 64)
    ANON_ENUM_KEY(int32_t, OPmodass, 65)
    ANON_ENUM_KEY(int32_t, OPshrass, 66)
    ANON_ENUM_KEY(int32_t, OPshlass, 67)
    ANON_ENUM_KEY(int32_t, OPandass, 68)
    ANON_ENUM_KEY(int32_t, OPxorass, 69)
    ANON_ENUM_KEY(int32_t, OPorass, 70)
    ANON_ENUM_KEY(int32_t, OPashrass, 71)
    ANON_ENUM_KEY(int32_t, RELOPMIN, 72)
    ANON_ENUM_KEY(int32_t, OPle, 72)
    ANON_ENUM_KEY(int32_t, OPgt, 73)
    ANON_ENUM_KEY(int32_t, OPlt, 74)
    ANON_ENUM_KEY(int32_t, OPge, 75)
    ANON_ENUM_KEY(int32_t, OPeqeq, 76)
    ANON_ENUM_KEY(int32_t, OPne, 77)
    ANON_ENUM_KEY(int32_t, OPunord, 78)
    ANON_ENUM_KEY(int32_t, OPlg, 79)
    ANON_ENUM_KEY(int32_t, OPleg, 80)
    ANON_ENUM_KEY(int32_t, OPule, 81)
    ANON_ENUM_KEY(int32_t, OPul, 82)
    ANON_ENUM_KEY(int32_t, OPuge, 83)
    ANON_ENUM_KEY(int32_t, OPug, 84)
    ANON_ENUM_KEY(int32_t, OPue, 85)
    ANON_ENUM_KEY(int32_t, OPngt, 86)
    ANON_ENUM_KEY(int32_t, OPnge, 87)
    ANON_ENUM_KEY(int32_t, OPnlt, 88)
    ANON_ENUM_KEY(int32_t, OPnle, 89)
    ANON_ENUM_KEY(int32_t, OPord, 90)
    ANON_ENUM_KEY(int32_t, OPnlg, 91)
    ANON_ENUM_KEY(int32_t, OPnleg, 92)
    ANON_ENUM_KEY(int32_t, OPnule, 93)
    ANON_ENUM_KEY(int32_t, OPnul, 94)
    ANON_ENUM_KEY(int32_t, OPnuge, 95)
    ANON_ENUM_KEY(int32_t, OPnug, 96)
    ANON_ENUM_KEY(int32_t, RELOPMAX, 97)
    ANON_ENUM_KEY(int32_t, OPnue, 97)
    ANON_ENUM_KEY(int32_t, CNVOPMIN, 98)
    ANON_ENUM_KEY(int32_t, OPb_8, 98)
    ANON_ENUM_KEY(int32_t, OPd_s32, 99)
    ANON_ENUM_KEY(int32_t, OPs32_d, 100)
    ANON_ENUM_KEY(int32_t, OPd_s16, 101)
    ANON_ENUM_KEY(int32_t, OPs16_d, 102)
    ANON_ENUM_KEY(int32_t, OPd_u16, 103)
    ANON_ENUM_KEY(int32_t, OPu16_d, 104)
    ANON_ENUM_KEY(int32_t, OPd_u32, 105)
    ANON_ENUM_KEY(int32_t, OPu32_d, 106)
    ANON_ENUM_KEY(int32_t, OPd_s64, 107)
    ANON_ENUM_KEY(int32_t, OPs64_d, 108)
    ANON_ENUM_KEY(int32_t, OPd_u64, 109)
    ANON_ENUM_KEY(int32_t, OPu64_d, 110)
    ANON_ENUM_KEY(int32_t, OPd_f, 111)
    ANON_ENUM_KEY(int32_t, OPf_d, 112)
    ANON_ENUM_KEY(int32_t, OPs16_32, 113)
    ANON_ENUM_KEY(int32_t, OPu16_32, 114)
    ANON_ENUM_KEY(int32_t, OP32_16, 115)
    ANON_ENUM_KEY(int32_t, OPu8_16, 116)
    ANON_ENUM_KEY(int32_t, OPs8_16, 117)
    ANON_ENUM_KEY(int32_t, OP16_8, 118)
    ANON_ENUM_KEY(int32_t, OPu32_64, 119)
    ANON_ENUM_KEY(int32_t, OPs32_64, 120)
    ANON_ENUM_KEY(int32_t, OP64_32, 121)
    ANON_ENUM_KEY(int32_t, OPu64_128, 122)
    ANON_ENUM_KEY(int32_t, OPs64_128, 123)
    ANON_ENUM_KEY(int32_t, OP128_64, 124)
    ANON_ENUM_KEY(int32_t, OPvp_fp, 125)
    ANON_ENUM_KEY(int32_t, OPcvp_fp, 126)
    ANON_ENUM_KEY(int32_t, OPoffset, 127)
    ANON_ENUM_KEY(int32_t, OPnp_fp, 128)
    ANON_ENUM_KEY(int32_t, OPnp_f16p, 129)
    ANON_ENUM_KEY(int32_t, OPf16p_np, 130)
    ANON_ENUM_KEY(int32_t, OPld_d, 131)
    ANON_ENUM_KEY(int32_t, OPd_ld, 132)
    ANON_ENUM_KEY(int32_t, CNVOPMAX, 133)
    ANON_ENUM_KEY(int32_t, OPld_u64, 133)
    ANON_ENUM_KEY(int32_t, OPc_r, 134)
    ANON_ENUM_KEY(int32_t, OPc_i, 135)
    ANON_ENUM_KEY(int32_t, OPmsw, 136)
    ANON_ENUM_KEY(int32_t, OPparam, 137)
    ANON_ENUM_KEY(int32_t, OPcall, 138)
    ANON_ENUM_KEY(int32_t, OPucall, 139)
    ANON_ENUM_KEY(int32_t, OPcallns, 140)
    ANON_ENUM_KEY(int32_t, OPucallns, 141)
    ANON_ENUM_KEY(int32_t, OPsizeof, 142)
    ANON_ENUM_KEY(int32_t, OPstrctor, 143)
    ANON_ENUM_KEY(int32_t, OPstrthis, 144)
    ANON_ENUM_KEY(int32_t, OPstrpar, 145)
    ANON_ENUM_KEY(int32_t, OPconst, 146)
    ANON_ENUM_KEY(int32_t, OPrelconst, 147)
    ANON_ENUM_KEY(int32_t, OPvar, 148)
    ANON_ENUM_KEY(int32_t, OPreg, 149)
    ANON_ENUM_KEY(int32_t, OPcolon, 150)
    ANON_ENUM_KEY(int32_t, OPcolon2, 151)
    ANON_ENUM_KEY(int32_t, OPstring, 152)
    ANON_ENUM_KEY(int32_t, OPnullptr, 153)
    ANON_ENUM_KEY(int32_t, OPasm, 154)
    ANON_ENUM_KEY(int32_t, OPinfo, 155)
    ANON_ENUM_KEY(int32_t, OPhalt, 156)
    ANON_ENUM_KEY(int32_t, OPctor, 157)
    ANON_ENUM_KEY(int32_t, OPdtor, 158)
    ANON_ENUM_KEY(int32_t, OPmark, 159)
    ANON_ENUM_KEY(int32_t, OPdctor, 160)
    ANON_ENUM_KEY(int32_t, OPddtor, 161)
    ANON_ENUM_KEY(int32_t, OPpair, 162)
    ANON_ENUM_KEY(int32_t, OPrpair, 163)
    ANON_ENUM_KEY(int32_t, OPframeptr, 164)
    ANON_ENUM_KEY(int32_t, OPgot, 165)
    ANON_ENUM_KEY(int32_t, OPvector, 166)
    ANON_ENUM_KEY(int32_t, OPvecsto, 167)
    ANON_ENUM_KEY(int32_t, OPvecfill, 168)
    ANON_ENUM_KEY(int32_t, OPinp, 169)
    ANON_ENUM_KEY(int32_t, OPoutp, 170)
    ANON_ENUM_KEY(int32_t, OPnew, 171)
    ANON_ENUM_KEY(int32_t, OPanew, 172)
    ANON_ENUM_KEY(int32_t, OPdelete, 173)
    ANON_ENUM_KEY(int32_t, OPadelete, 174)
    ANON_ENUM_KEY(int32_t, OPbrack, 175)
    ANON_ENUM_KEY(int32_t, OParrow, 176)
    ANON_ENUM_KEY(int32_t, OParrowstar, 177)
    ANON_ENUM_KEY(int32_t, OPpreinc, 178)
    ANON_ENUM_KEY(int32_t, OPpredec, 179)
    ANON_ENUM_KEY(int32_t, OPva_start, 180)
    ANON_ENUM_KEY(int32_t, OPprefetch, 181)
    ANON_ENUM_KEY(int32_t, OPMAX, 182)
END_ANON_ENUM()

extern int32_t rel_not(int32_t op);

extern int32_t rel_swap(int32_t op);

extern int32_t rel_integral(int32_t op);

extern int32_t rel_exception(int32_t op);

extern int32_t rel_unord(int32_t op);

extern int32_t convidx(int32_t op);

BEGIN_ANON_ENUM()
    ANON_ENUM_KEY(int32_t, _OTbinary, 1)
    ANON_ENUM_KEY(int32_t, _OTunary, 2)
    ANON_ENUM_KEY(int32_t, _OTcommut, 4)
    ANON_ENUM_KEY(int32_t, _OTassoc, 8)
    ANON_ENUM_KEY(int32_t, _OTsideff, 16)
    ANON_ENUM_KEY(int32_t, _OTeop0e, 32)
    ANON_ENUM_KEY(int32_t, _OTeop00, 64)
    ANON_ENUM_KEY(int32_t, _OTeop1e, 128)
END_ANON_ENUM()

BEGIN_ANON_ENUM()
    ANON_ENUM_KEY(int32_t, _OTlogical, 1)
    ANON_ENUM_KEY(int32_t, _OTwid, 2)
    ANON_ENUM_KEY(int32_t, _OTcall, 4)
    ANON_ENUM_KEY(int32_t, _OTrtol, 8)
    ANON_ENUM_KEY(int32_t, _OTassign, 16)
    ANON_ENUM_KEY(int32_t, _OTdef, 32)
    ANON_ENUM_KEY(int32_t, _OTae, 64)
END_ANON_ENUM()

BEGIN_ANON_ENUM()
    ANON_ENUM_KEY(int32_t, _OTboolnop, 1)
END_ANON_ENUM()

extern uint8_t OTbinary(int32_t op);

extern uint8_t OTunary(int32_t op);

extern bool OTleaf(int32_t op);

extern uint8_t OTcommut(int32_t op);

extern uint8_t OTassoc(int32_t op);

extern uint8_t OTassign(int32_t op);

extern bool OTpost(int32_t op);

extern uint8_t OTeop0e(int32_t op);

extern uint8_t OTeop00(int32_t op);

extern uint8_t OTeop1e(int32_t op);

extern uint8_t OTsideff(int32_t op);

extern bool OTconv(int32_t op);

extern uint8_t OTlogical(int32_t op);

extern uint8_t OTwid(int32_t op);

extern bool OTopeq(int32_t op);

extern bool OTop(int32_t op);

extern uint8_t OTcall(int32_t op);

extern uint8_t OTrtol(int32_t op);

extern bool OTrel(int32_t op);

extern bool OTrel2(int32_t op);

extern uint8_t OTdef(int32_t op);

extern uint8_t OTae(int32_t op);

extern uint8_t OTboolnop(int32_t op);

extern bool OTcalldef(int32_t op);

extern int32_t opeqtoop(int32_t opx);

extern int32_t optoopeq(int32_t opx);

struct Outbuffer
{
    uint8_t* buf;
    uint8_t* pend;
    uint8_t* p;
    Outbuffer(size_t initialSize);
    void dtor();
    void reset();
    void reserve(size_t nbytes);
    void enlarge(size_t nbytes);
    void* writezeros(size_t n);
    void position(size_t offset, size_t nbytes);
    void writen(const void* const b, size_t len);
    void write(const void* b, size_t len);
    void writeByten(uint8_t v);
    void writeByte(int32_t v);
    void write16n(int32_t v);
    void write16(int32_t v);
    void write32(int32_t v);
    void write64(int64_t v);
    void writeFloat(float v);
    void writeDouble(double v);
    void write(const char* s);
    void writeString(const char* s);
    void prependBytes(const char* s);
    void prepend(const void* b, size_t len);
    void bracket(char c1, char c2);
    size_t length() const;
    void setsize(size_t size);
    void writesLEB128(int32_t value);
    void writeuLEB128(uint32_t value);
    Outbuffer() : buf(), pend() {}
};

BEGIN_ANON_ENUM()
    ANON_ENUM_KEY(int32_t, RTLSYM_THROW, 0)
    ANON_ENUM_KEY(int32_t, RTLSYM_THROWC, 1)
    ANON_ENUM_KEY(int32_t, RTLSYM_THROWDWARF, 2)
    ANON_ENUM_KEY(int32_t, RTLSYM_MONITOR_HANDLER, 3)
    ANON_ENUM_KEY(int32_t, RTLSYM_MONITOR_PROLOG, 4)
    ANON_ENUM_KEY(int32_t, RTLSYM_MONITOR_EPILOG, 5)
    ANON_ENUM_KEY(int32_t, RTLSYM_DCOVER, 6)
    ANON_ENUM_KEY(int32_t, RTLSYM_DCOVER2, 7)
    ANON_ENUM_KEY(int32_t, RTLSYM_DASSERT, 8)
    ANON_ENUM_KEY(int32_t, RTLSYM_DASSERTP, 9)
    ANON_ENUM_KEY(int32_t, RTLSYM_DASSERT_MSG, 10)
    ANON_ENUM_KEY(int32_t, RTLSYM_DUNITTEST, 11)
    ANON_ENUM_KEY(int32_t, RTLSYM_DUNITTESTP, 12)
    ANON_ENUM_KEY(int32_t, RTLSYM_DUNITTEST_MSG, 13)
    ANON_ENUM_KEY(int32_t, RTLSYM_DARRAY, 14)
    ANON_ENUM_KEY(int32_t, RTLSYM_DARRAYP, 15)
    ANON_ENUM_KEY(int32_t, RTLSYM_DINVARIANT, 16)
    ANON_ENUM_KEY(int32_t, RTLSYM_MEMCPY, 17)
    ANON_ENUM_KEY(int32_t, RTLSYM_MEMSET8, 18)
    ANON_ENUM_KEY(int32_t, RTLSYM_MEMSET16, 19)
    ANON_ENUM_KEY(int32_t, RTLSYM_MEMSET32, 20)
    ANON_ENUM_KEY(int32_t, RTLSYM_MEMSET64, 21)
    ANON_ENUM_KEY(int32_t, RTLSYM_MEMSET128, 22)
    ANON_ENUM_KEY(int32_t, RTLSYM_MEMSET128ii, 23)
    ANON_ENUM_KEY(int32_t, RTLSYM_MEMSET80, 24)
    ANON_ENUM_KEY(int32_t, RTLSYM_MEMSET160, 25)
    ANON_ENUM_KEY(int32_t, RTLSYM_MEMSETFLOAT, 26)
    ANON_ENUM_KEY(int32_t, RTLSYM_MEMSETDOUBLE, 27)
    ANON_ENUM_KEY(int32_t, RTLSYM_MEMSETSIMD, 28)
    ANON_ENUM_KEY(int32_t, RTLSYM_MEMSETN, 29)
    ANON_ENUM_KEY(int32_t, RTLSYM_MODULO, 30)
    ANON_ENUM_KEY(int32_t, RTLSYM_MONITORENTER, 31)
    ANON_ENUM_KEY(int32_t, RTLSYM_MONITOREXIT, 32)
    ANON_ENUM_KEY(int32_t, RTLSYM_CRITICALENTER, 33)
    ANON_ENUM_KEY(int32_t, RTLSYM_CRITICALEXIT, 34)
    ANON_ENUM_KEY(int32_t, RTLSYM_SWITCH_STRING, 35)
    ANON_ENUM_KEY(int32_t, RTLSYM_SWITCH_USTRING, 36)
    ANON_ENUM_KEY(int32_t, RTLSYM_SWITCH_DSTRING, 37)
    ANON_ENUM_KEY(int32_t, RTLSYM_DSWITCHERR, 38)
    ANON_ENUM_KEY(int32_t, RTLSYM_DHIDDENFUNC, 39)
    ANON_ENUM_KEY(int32_t, RTLSYM_NEWCLASS, 40)
    ANON_ENUM_KEY(int32_t, RTLSYM_NEWTHROW, 41)
    ANON_ENUM_KEY(int32_t, RTLSYM_NEWARRAYT, 42)
    ANON_ENUM_KEY(int32_t, RTLSYM_NEWARRAYIT, 43)
    ANON_ENUM_KEY(int32_t, RTLSYM_NEWITEMT, 44)
    ANON_ENUM_KEY(int32_t, RTLSYM_NEWITEMIT, 45)
    ANON_ENUM_KEY(int32_t, RTLSYM_NEWARRAYMTX, 46)
    ANON_ENUM_KEY(int32_t, RTLSYM_NEWARRAYMITX, 47)
    ANON_ENUM_KEY(int32_t, RTLSYM_ARRAYLITERALTX, 48)
    ANON_ENUM_KEY(int32_t, RTLSYM_ASSOCARRAYLITERALTX, 49)
    ANON_ENUM_KEY(int32_t, RTLSYM_CALLFINALIZER, 50)
    ANON_ENUM_KEY(int32_t, RTLSYM_CALLINTERFACEFINALIZER, 51)
    ANON_ENUM_KEY(int32_t, RTLSYM_DELCLASS, 52)
    ANON_ENUM_KEY(int32_t, RTLSYM_DELINTERFACE, 53)
    ANON_ENUM_KEY(int32_t, RTLSYM_DELSTRUCT, 54)
    ANON_ENUM_KEY(int32_t, RTLSYM_ALLOCMEMORY, 55)
    ANON_ENUM_KEY(int32_t, RTLSYM_DELARRAYT, 56)
    ANON_ENUM_KEY(int32_t, RTLSYM_DELMEMORY, 57)
    ANON_ENUM_KEY(int32_t, RTLSYM_INTERFACE, 58)
    ANON_ENUM_KEY(int32_t, RTLSYM_DYNAMIC_CAST, 59)
    ANON_ENUM_KEY(int32_t, RTLSYM_INTERFACE_CAST, 60)
    ANON_ENUM_KEY(int32_t, RTLSYM_FATEXIT, 61)
    ANON_ENUM_KEY(int32_t, RTLSYM_ARRAYCATT, 62)
    ANON_ENUM_KEY(int32_t, RTLSYM_ARRAYCATNTX, 63)
    ANON_ENUM_KEY(int32_t, RTLSYM_ARRAYAPPENDT, 64)
    ANON_ENUM_KEY(int32_t, RTLSYM_ARRAYAPPENDCTX, 65)
    ANON_ENUM_KEY(int32_t, RTLSYM_ARRAYAPPENDCD, 66)
    ANON_ENUM_KEY(int32_t, RTLSYM_ARRAYAPPENDWD, 67)
    ANON_ENUM_KEY(int32_t, RTLSYM_ARRAYSETLENGTHT, 68)
    ANON_ENUM_KEY(int32_t, RTLSYM_ARRAYSETLENGTHIT, 69)
    ANON_ENUM_KEY(int32_t, RTLSYM_ARRAYCOPY, 70)
    ANON_ENUM_KEY(int32_t, RTLSYM_ARRAYASSIGN, 71)
    ANON_ENUM_KEY(int32_t, RTLSYM_ARRAYASSIGN_R, 72)
    ANON_ENUM_KEY(int32_t, RTLSYM_ARRAYASSIGN_L, 73)
    ANON_ENUM_KEY(int32_t, RTLSYM_ARRAYCTOR, 74)
    ANON_ENUM_KEY(int32_t, RTLSYM_ARRAYSETASSIGN, 75)
    ANON_ENUM_KEY(int32_t, RTLSYM_ARRAYSETCTOR, 76)
    ANON_ENUM_KEY(int32_t, RTLSYM_ARRAYCAST, 77)
    ANON_ENUM_KEY(int32_t, RTLSYM_ARRAYEQ, 78)
    ANON_ENUM_KEY(int32_t, RTLSYM_ARRAYEQ2, 79)
    ANON_ENUM_KEY(int32_t, RTLSYM_ARRAYCMP, 80)
    ANON_ENUM_KEY(int32_t, RTLSYM_ARRAYCMP2, 81)
    ANON_ENUM_KEY(int32_t, RTLSYM_ARRAYCMPCHAR, 82)
    ANON_ENUM_KEY(int32_t, RTLSYM_OBJ_EQ, 83)
    ANON_ENUM_KEY(int32_t, RTLSYM_OBJ_CMP, 84)
    ANON_ENUM_KEY(int32_t, RTLSYM_EXCEPT_HANDLER2, 85)
    ANON_ENUM_KEY(int32_t, RTLSYM_EXCEPT_HANDLER3, 86)
    ANON_ENUM_KEY(int32_t, RTLSYM_CPP_HANDLER, 87)
    ANON_ENUM_KEY(int32_t, RTLSYM_D_HANDLER, 88)
    ANON_ENUM_KEY(int32_t, RTLSYM_D_LOCAL_UNWIND2, 89)
    ANON_ENUM_KEY(int32_t, RTLSYM_LOCAL_UNWIND2, 90)
    ANON_ENUM_KEY(int32_t, RTLSYM_UNWIND_RESUME, 91)
    ANON_ENUM_KEY(int32_t, RTLSYM_PERSONALITY, 92)
    ANON_ENUM_KEY(int32_t, RTLSYM_BEGIN_CATCH, 93)
    ANON_ENUM_KEY(int32_t, RTLSYM_CXA_BEGIN_CATCH, 94)
    ANON_ENUM_KEY(int32_t, RTLSYM_CXA_END_CATCH, 95)
    ANON_ENUM_KEY(int32_t, RTLSYM_TLS_INDEX, 96)
    ANON_ENUM_KEY(int32_t, RTLSYM_TLS_ARRAY, 97)
    ANON_ENUM_KEY(int32_t, RTLSYM_AHSHIFT, 98)
    ANON_ENUM_KEY(int32_t, RTLSYM_HDIFFN, 99)
    ANON_ENUM_KEY(int32_t, RTLSYM_HDIFFF, 100)
    ANON_ENUM_KEY(int32_t, RTLSYM_INTONLY, 101)
    ANON_ENUM_KEY(int32_t, RTLSYM_EXCEPT_LIST, 102)
    ANON_ENUM_KEY(int32_t, RTLSYM_SETJMP3, 103)
    ANON_ENUM_KEY(int32_t, RTLSYM_LONGJMP, 104)
    ANON_ENUM_KEY(int32_t, RTLSYM_ALLOCA, 105)
    ANON_ENUM_KEY(int32_t, RTLSYM_CPP_LONGJMP, 106)
    ANON_ENUM_KEY(int32_t, RTLSYM_PTRCHK, 107)
    ANON_ENUM_KEY(int32_t, RTLSYM_CHKSTK, 108)
    ANON_ENUM_KEY(int32_t, RTLSYM_TRACE_PRO_N, 109)
    ANON_ENUM_KEY(int32_t, RTLSYM_TRACE_PRO_F, 110)
    ANON_ENUM_KEY(int32_t, RTLSYM_TRACE_EPI_N, 111)
    ANON_ENUM_KEY(int32_t, RTLSYM_TRACE_EPI_F, 112)
    ANON_ENUM_KEY(int32_t, RTLSYM_TRACE_CPRO, 113)
    ANON_ENUM_KEY(int32_t, RTLSYM_TRACE_CEPI, 114)
    ANON_ENUM_KEY(int32_t, RTLSYM_TRACENEWCLASS, 115)
    ANON_ENUM_KEY(int32_t, RTLSYM_TRACENEWARRAYT, 116)
    ANON_ENUM_KEY(int32_t, RTLSYM_TRACENEWARRAYIT, 117)
    ANON_ENUM_KEY(int32_t, RTLSYM_TRACENEWARRAYMTX, 118)
    ANON_ENUM_KEY(int32_t, RTLSYM_TRACENEWARRAYMITX, 119)
    ANON_ENUM_KEY(int32_t, RTLSYM_TRACENEWITEMT, 120)
    ANON_ENUM_KEY(int32_t, RTLSYM_TRACENEWITEMIT, 121)
    ANON_ENUM_KEY(int32_t, RTLSYM_TRACECALLFINALIZER, 122)
    ANON_ENUM_KEY(int32_t, RTLSYM_TRACECALLINTERFACEFINALIZER, 123)
    ANON_ENUM_KEY(int32_t, RTLSYM_TRACEDELCLASS, 124)
    ANON_ENUM_KEY(int32_t, RTLSYM_TRACEDELINTERFACE, 125)
    ANON_ENUM_KEY(int32_t, RTLSYM_TRACEDELSTRUCT, 126)
    ANON_ENUM_KEY(int32_t, RTLSYM_TRACEDELARRAYT, 127)
    ANON_ENUM_KEY(int32_t, RTLSYM_TRACEDELMEMORY, 128)
    ANON_ENUM_KEY(int32_t, RTLSYM_TRACEARRAYLITERALTX, 129)
    ANON_ENUM_KEY(int32_t, RTLSYM_TRACEASSOCARRAYLITERALTX, 130)
    ANON_ENUM_KEY(int32_t, RTLSYM_TRACEARRAYCATT, 131)
    ANON_ENUM_KEY(int32_t, RTLSYM_TRACEARRAYCATNTX, 132)
    ANON_ENUM_KEY(int32_t, RTLSYM_TRACEARRAYAPPENDT, 133)
    ANON_ENUM_KEY(int32_t, RTLSYM_TRACEARRAYAPPENDCTX, 134)
    ANON_ENUM_KEY(int32_t, RTLSYM_TRACEARRAYAPPENDCD, 135)
    ANON_ENUM_KEY(int32_t, RTLSYM_TRACEARRAYAPPENDWD, 136)
    ANON_ENUM_KEY(int32_t, RTLSYM_TRACEARRAYSETLENGTHT, 137)
    ANON_ENUM_KEY(int32_t, RTLSYM_TRACEARRAYSETLENGTHIT, 138)
    ANON_ENUM_KEY(int32_t, RTLSYM_TRACEALLOCMEMORY, 139)
    ANON_ENUM_KEY(int32_t, RTLSYM_C_ASSERT, 140)
    ANON_ENUM_KEY(int32_t, RTLSYM_C__ASSERT, 141)
    ANON_ENUM_KEY(int32_t, RTLSYM_C__ASSERT_FAIL, 142)
    ANON_ENUM_KEY(int32_t, RTLSYM_C__ASSERT_RTN, 143)
    ANON_ENUM_KEY(int32_t, RTLSYM_MAX, 144)
END_ANON_ENUM()

typedef uint32_t opcode_t;

ENUM_CONSTANT_NUMERIC(uint32_t, NoOpcode, 65535u)

BEGIN_ANON_ENUM()
    ANON_ENUM_KEY(int32_t, AX, 0)
    ANON_ENUM_KEY(int32_t, CX, 1)
    ANON_ENUM_KEY(int32_t, DX, 2)
    ANON_ENUM_KEY(int32_t, BX, 3)
    ANON_ENUM_KEY(int32_t, SP, 4)
    ANON_ENUM_KEY(int32_t, BP, 5)
    ANON_ENUM_KEY(int32_t, SI, 6)
    ANON_ENUM_KEY(int32_t, DI, 7)
    ANON_ENUM_KEY(int32_t, R8, 8)
    ANON_ENUM_KEY(int32_t, R9, 9)
    ANON_ENUM_KEY(int32_t, R10, 10)
    ANON_ENUM_KEY(int32_t, R11, 11)
    ANON_ENUM_KEY(int32_t, R12, 12)
    ANON_ENUM_KEY(int32_t, R13, 13)
    ANON_ENUM_KEY(int32_t, R14, 14)
    ANON_ENUM_KEY(int32_t, R15, 15)
    ANON_ENUM_KEY(int32_t, XMM0, 16)
    ANON_ENUM_KEY(int32_t, XMM1, 17)
    ANON_ENUM_KEY(int32_t, XMM2, 18)
    ANON_ENUM_KEY(int32_t, XMM3, 19)
    ANON_ENUM_KEY(int32_t, XMM4, 20)
    ANON_ENUM_KEY(int32_t, XMM5, 21)
    ANON_ENUM_KEY(int32_t, XMM6, 22)
    ANON_ENUM_KEY(int32_t, XMM7, 23)
    ANON_ENUM_KEY(int32_t, XMM15, 31)
END_ANON_ENUM()

ENUM_CONSTANT_NUMERIC(int32_t, PICREG, 3)

ENUM_CONSTANT_NUMERIC(int32_t, ES, 24)

ENUM_CONSTANT_NUMERIC(int32_t, NUMGENREGS, 16)

ENUM_CONSTANT_NUMERIC(int32_t, NUMREGS, 25)

ENUM_CONSTANT_NUMERIC(int32_t, PSW, 25)

ENUM_CONSTANT_NUMERIC(int32_t, STACK, 26)

ENUM_CONSTANT_NUMERIC(int32_t, ST0, 27)

ENUM_CONSTANT_NUMERIC(int32_t, ST01, 28)

ENUM_CONSTANT_NUMERIC(uint8_t, NOREG, 29u)

BEGIN_ANON_ENUM()
    ANON_ENUM_KEY(int32_t, AL, 0)
    ANON_ENUM_KEY(int32_t, CL, 1)
    ANON_ENUM_KEY(int32_t, DL, 2)
    ANON_ENUM_KEY(int32_t, BL, 3)
    ANON_ENUM_KEY(int32_t, AH, 4)
    ANON_ENUM_KEY(int32_t, CH, 5)
    ANON_ENUM_KEY(int32_t, DH, 6)
    ANON_ENUM_KEY(int32_t, BH, 7)
END_ANON_ENUM()

BEGIN_ANON_ENUM()
    ANON_ENUM_KEY(int32_t, mAX, 1)
    ANON_ENUM_KEY(int32_t, mCX, 2)
    ANON_ENUM_KEY(int32_t, mDX, 4)
    ANON_ENUM_KEY(int32_t, mBX, 8)
    ANON_ENUM_KEY(int32_t, mSP, 16)
    ANON_ENUM_KEY(int32_t, mBP, 32)
    ANON_ENUM_KEY(int32_t, mSI, 64)
    ANON_ENUM_KEY(int32_t, mDI, 128)
    ANON_ENUM_KEY(int32_t, mR8, 256)
    ANON_ENUM_KEY(int32_t, mR9, 512)
    ANON_ENUM_KEY(int32_t, mR10, 1024)
    ANON_ENUM_KEY(int32_t, mR11, 2048)
    ANON_ENUM_KEY(int32_t, mR12, 4096)
    ANON_ENUM_KEY(int32_t, mR13, 8192)
    ANON_ENUM_KEY(int32_t, mR14, 16384)
    ANON_ENUM_KEY(int32_t, mR15, 32768)
    ANON_ENUM_KEY(int32_t, mXMM0, 65536)
    ANON_ENUM_KEY(int32_t, mXMM1, 131072)
    ANON_ENUM_KEY(int32_t, mXMM2, 262144)
    ANON_ENUM_KEY(int32_t, mXMM3, 524288)
    ANON_ENUM_KEY(int32_t, mXMM4, 1048576)
    ANON_ENUM_KEY(int32_t, mXMM5, 2097152)
    ANON_ENUM_KEY(int32_t, mXMM6, 4194304)
    ANON_ENUM_KEY(int32_t, mXMM7, 8388608)
    ANON_ENUM_KEY(int32_t, XMMREGS, 16711680)
    ANON_ENUM_KEY(int32_t, mES, 16777216)
    ANON_ENUM_KEY(int32_t, mPSW, 33554432)
    ANON_ENUM_KEY(int32_t, mSTACK, 67108864)
    ANON_ENUM_KEY(int32_t, mST0, 134217728)
    ANON_ENUM_KEY(int32_t, mST01, 268435456)
END_ANON_ENUM()

ENUM_CONSTANT_NUMERIC(int32_t, RMload, 1073741824)

ENUM_CONSTANT_NUMERIC(int32_t, RMstore, -2147483648)

extern uint32_t ALLREGS;

extern uint32_t BYTEREGS;

ENUM_CONSTANT_NUMERIC(int32_t, ALLREGS_INIT, 207)

ENUM_CONSTANT_NUMERIC(int32_t, ALLREGS_INIT_PIC, 199)

ENUM_CONSTANT_NUMERIC(int32_t, BYTEREGS_INIT, 15)

ENUM_CONSTANT_NUMERIC(int32_t, BYTEREGS_INIT_PIC, 7)

ENUM_CONSTANT_NUMERIC(int32_t, IDXREGS, 200)

ENUM_CONSTANT_NUMERIC(int32_t, FLOATREGS_64, 1)

ENUM_CONSTANT_NUMERIC(int32_t, FLOATREGS2_64, 4)

ENUM_CONSTANT_NUMERIC(int32_t, DOUBLEREGS_64, 1)

ENUM_CONSTANT_NUMERIC(int32_t, DOUBLEREGS2_64, 4)

ENUM_CONSTANT_NUMERIC(int32_t, FLOATREGS_32, 1)

ENUM_CONSTANT_NUMERIC(int32_t, FLOATREGS2_32, 4)

ENUM_CONSTANT_NUMERIC(int32_t, DOUBLEREGS_32, 5)

ENUM_CONSTANT_NUMERIC(int32_t, DOUBLEREGS2_32, 10)

ENUM_CONSTANT_NUMERIC(int32_t, FLOATREGS_16, 5)

ENUM_CONSTANT_NUMERIC(int32_t, FLOATREGS2_16, 10)

ENUM_CONSTANT_NUMERIC(int32_t, DOUBLEREGS_16, 15)

BEGIN_ANON_ENUM()
    ANON_ENUM_KEY(int32_t, SEG_ES, 0)
    ANON_ENUM_KEY(int32_t, SEG_CS, 1)
    ANON_ENUM_KEY(int32_t, SEG_SS, 2)
    ANON_ENUM_KEY(int32_t, SEG_DS, 3)
END_ANON_ENUM()

ENUM_CONSTANT_NUMERIC(int32_t, mMSW, 16777222)

ENUM_CONSTANT_NUMERIC(int32_t, mLSW, 201)

BEGIN_ENUM(CLIB, CLIB, clib)
    ENUM_KEY(int32_t, lcmp, 0, CLIB, CLIB, clib, CLIB)
    ENUM_KEY(int32_t, lmul, 1, CLIB, CLIB, clib, CLIB)
    ENUM_KEY(int32_t, ldiv, 2, CLIB, CLIB, clib, CLIB)
    ENUM_KEY(int32_t, lmod, 3, CLIB, CLIB, clib, CLIB)
    ENUM_KEY(int32_t, uldiv, 4, CLIB, CLIB, clib, CLIB)
    ENUM_KEY(int32_t, ulmod, 5, CLIB, CLIB, clib, CLIB)
    ENUM_KEY(int32_t, dmul, 6, CLIB, CLIB, clib, CLIB)
    ENUM_KEY(int32_t, ddiv, 7, CLIB, CLIB, clib, CLIB)
    ENUM_KEY(int32_t, dtst0, 8, CLIB, CLIB, clib, CLIB)
    ENUM_KEY(int32_t, dtst0exc, 9, CLIB, CLIB, clib, CLIB)
    ENUM_KEY(int32_t, dcmp, 10, CLIB, CLIB, clib, CLIB)
    ENUM_KEY(int32_t, dcmpexc, 11, CLIB, CLIB, clib, CLIB)
    ENUM_KEY(int32_t, dneg, 12, CLIB, CLIB, clib, CLIB)
    ENUM_KEY(int32_t, dadd, 13, CLIB, CLIB, clib, CLIB)
    ENUM_KEY(int32_t, dsub, 14, CLIB, CLIB, clib, CLIB)
    ENUM_KEY(int32_t, fmul, 15, CLIB, CLIB, clib, CLIB)
    ENUM_KEY(int32_t, fdiv, 16, CLIB, CLIB, clib, CLIB)
    ENUM_KEY(int32_t, ftst0, 17, CLIB, CLIB, clib, CLIB)
    ENUM_KEY(int32_t, ftst0exc, 18, CLIB, CLIB, clib, CLIB)
    ENUM_KEY(int32_t, fcmp, 19, CLIB, CLIB, clib, CLIB)
    ENUM_KEY(int32_t, fcmpexc, 20, CLIB, CLIB, clib, CLIB)
    ENUM_KEY(int32_t, fneg, 21, CLIB, CLIB, clib, CLIB)
    ENUM_KEY(int32_t, fadd, 22, CLIB, CLIB, clib, CLIB)
    ENUM_KEY(int32_t, fsub, 23, CLIB, CLIB, clib, CLIB)
    ENUM_KEY(int32_t, dbllng, 24, CLIB, CLIB, clib, CLIB)
    ENUM_KEY(int32_t, lngdbl, 25, CLIB, CLIB, clib, CLIB)
    ENUM_KEY(int32_t, dblint, 26, CLIB, CLIB, clib, CLIB)
    ENUM_KEY(int32_t, intdbl, 27, CLIB, CLIB, clib, CLIB)
    ENUM_KEY(int32_t, dbluns, 28, CLIB, CLIB, clib, CLIB)
    ENUM_KEY(int32_t, unsdbl, 29, CLIB, CLIB, clib, CLIB)
    ENUM_KEY(int32_t, dblulng, 30, CLIB, CLIB, clib, CLIB)
    ENUM_KEY(int32_t, ulngdbl, 31, CLIB, CLIB, clib, CLIB)
    ENUM_KEY(int32_t, dblflt, 32, CLIB, CLIB, clib, CLIB)
    ENUM_KEY(int32_t, fltdbl, 33, CLIB, CLIB, clib, CLIB)
    ENUM_KEY(int32_t, dblllng, 34, CLIB, CLIB, clib, CLIB)
    ENUM_KEY(int32_t, llngdbl, 35, CLIB, CLIB, clib, CLIB)
    ENUM_KEY(int32_t, dblullng, 36, CLIB, CLIB, clib, CLIB)
    ENUM_KEY(int32_t, ullngdbl, 37, CLIB, CLIB, clib, CLIB)
    ENUM_KEY(int32_t, dtst, 38, CLIB, CLIB, clib, CLIB)
    ENUM_KEY(int32_t, vptrfptr, 39, CLIB, CLIB, clib, CLIB)
    ENUM_KEY(int32_t, cvptrfptr, 40, CLIB, CLIB, clib, CLIB)
    ENUM_KEY(int32_t, _87topsw, 41, CLIB, CLIB, clib, CLIB)
    ENUM_KEY(int32_t, fltto87, 42, CLIB, CLIB, clib, CLIB)
    ENUM_KEY(int32_t, dblto87, 43, CLIB, CLIB, clib, CLIB)
    ENUM_KEY(int32_t, dblint87, 44, CLIB, CLIB, clib, CLIB)
    ENUM_KEY(int32_t, dbllng87, 45, CLIB, CLIB, clib, CLIB)
    ENUM_KEY(int32_t, ftst, 46, CLIB, CLIB, clib, CLIB)
    ENUM_KEY(int32_t, fcompp, 47, CLIB, CLIB, clib, CLIB)
    ENUM_KEY(int32_t, ftest, 48, CLIB, CLIB, clib, CLIB)
    ENUM_KEY(int32_t, ftest0, 49, CLIB, CLIB, clib, CLIB)
    ENUM_KEY(int32_t, fdiv87, 50, CLIB, CLIB, clib, CLIB)
    ENUM_KEY(int32_t, cmul, 51, CLIB, CLIB, clib, CLIB)
    ENUM_KEY(int32_t, cdiv, 52, CLIB, CLIB, clib, CLIB)
    ENUM_KEY(int32_t, ccmp, 53, CLIB, CLIB, clib, CLIB)
    ENUM_KEY(int32_t, u64_ldbl, 54, CLIB, CLIB, clib, CLIB)
    ENUM_KEY(int32_t, ld_u64, 55, CLIB, CLIB, clib, CLIB)
    ENUM_KEY(int32_t, MAX, 56, CLIB, CLIB, clib, CLIB)
END_ENUM(CLIB, CLIB, clib)

typedef uint32_t code_flags_t;

BEGIN_ANON_ENUM()
    ANON_ENUM_KEY(int32_t, CFes, 1)
    ANON_ENUM_KEY(int32_t, CFjmp16, 2)
    ANON_ENUM_KEY(int32_t, CFtarg, 4)
    ANON_ENUM_KEY(int32_t, CFseg, 8)
    ANON_ENUM_KEY(int32_t, CFoff, 16)
    ANON_ENUM_KEY(int32_t, CFss, 32)
    ANON_ENUM_KEY(int32_t, CFpsw, 64)
    ANON_ENUM_KEY(int32_t, CFopsize, 128)
    ANON_ENUM_KEY(int32_t, CFaddrsize, 256)
    ANON_ENUM_KEY(int32_t, CFds, 512)
    ANON_ENUM_KEY(int32_t, CFcs, 1024)
    ANON_ENUM_KEY(int32_t, CFfs, 2048)
    ANON_ENUM_KEY(int32_t, CFgs, 3072)
    ANON_ENUM_KEY(int32_t, CFwait, 4096)
    ANON_ENUM_KEY(int32_t, CFselfrel, 8192)
    ANON_ENUM_KEY(int32_t, CFunambig, 16384)
    ANON_ENUM_KEY(int32_t, CFtarg2, 32768)
    ANON_ENUM_KEY(int32_t, CFvolatile, 65536)
    ANON_ENUM_KEY(int32_t, CFclassinit, 131072)
    ANON_ENUM_KEY(int32_t, CFoffset64, 262144)
    ANON_ENUM_KEY(int32_t, CFpc32, 524288)
    ANON_ENUM_KEY(int32_t, CFvex, 1048576)
    ANON_ENUM_KEY(int32_t, CFvex3, 2097152)
    ANON_ENUM_KEY(int32_t, CFjmp5, 4194304)
    ANON_ENUM_KEY(int32_t, CFswitch, 8388608)
    ANON_ENUM_KEY(int32_t, CFindirect, 16777216)
    ANON_ENUM_KEY(int32_t, CFREL, 117440512)
    ANON_ENUM_KEY(int32_t, CFSEG, 3617)
    ANON_ENUM_KEY(int32_t, CFPREFIX, 4001)
END_ANON_ENUM()

BEGIN_ANON_ENUM()
    ANON_ENUM_KEY(int32_t, SEGES, 38)
    ANON_ENUM_KEY(int32_t, SEGCS, 46)
    ANON_ENUM_KEY(int32_t, SEGSS, 54)
    ANON_ENUM_KEY(int32_t, SEGDS, 62)
    ANON_ENUM_KEY(int32_t, SEGFS, 100)
    ANON_ENUM_KEY(int32_t, SEGGS, 101)
    ANON_ENUM_KEY(int32_t, CMP, 59)
    ANON_ENUM_KEY(int32_t, CALL, 232)
    ANON_ENUM_KEY(int32_t, JMP, 233)
    ANON_ENUM_KEY(int32_t, JMPS, 235)
    ANON_ENUM_KEY(int32_t, JCXZ, 227)
    ANON_ENUM_KEY(int32_t, LOOP, 226)
    ANON_ENUM_KEY(int32_t, LES, 196)
    ANON_ENUM_KEY(int32_t, LEA, 141)
    ANON_ENUM_KEY(int32_t, LOCK, 240)
    ANON_ENUM_KEY(int32_t, INT3, 204)
    ANON_ENUM_KEY(int32_t, HLT, 244)
    ANON_ENUM_KEY(int32_t, ENTER, 200)
    ANON_ENUM_KEY(int32_t, LEAVE, 201)
    ANON_ENUM_KEY(int32_t, MOVSXb, 4030)
    ANON_ENUM_KEY(int32_t, MOVSXw, 4031)
    ANON_ENUM_KEY(int32_t, MOVZXb, 4022)
    ANON_ENUM_KEY(int32_t, MOVZXw, 4023)
    ANON_ENUM_KEY(int32_t, STOSB, 170)
    ANON_ENUM_KEY(int32_t, STOS, 171)
    ANON_ENUM_KEY(int32_t, STO, 137)
    ANON_ENUM_KEY(int32_t, LOD, 139)
    ANON_ENUM_KEY(int32_t, JO, 112)
    ANON_ENUM_KEY(int32_t, JNO, 113)
    ANON_ENUM_KEY(int32_t, JC, 114)
    ANON_ENUM_KEY(int32_t, JB, 114)
    ANON_ENUM_KEY(int32_t, JNC, 115)
    ANON_ENUM_KEY(int32_t, JAE, 115)
    ANON_ENUM_KEY(int32_t, JE, 116)
    ANON_ENUM_KEY(int32_t, JNE, 117)
    ANON_ENUM_KEY(int32_t, JBE, 118)
    ANON_ENUM_KEY(int32_t, JA, 119)
    ANON_ENUM_KEY(int32_t, JS, 120)
    ANON_ENUM_KEY(int32_t, JNS, 121)
    ANON_ENUM_KEY(int32_t, JP, 122)
    ANON_ENUM_KEY(int32_t, JNP, 123)
    ANON_ENUM_KEY(int32_t, JL, 124)
    ANON_ENUM_KEY(int32_t, JGE, 125)
    ANON_ENUM_KEY(int32_t, JLE, 126)
    ANON_ENUM_KEY(int32_t, JG, 127)
    ANON_ENUM_KEY(int32_t, UD2, 3851)
    ANON_ENUM_KEY(int32_t, PAUSE, 62352)
    ANON_ENUM_KEY(int32_t, NOP, 46)
    ANON_ENUM_KEY(int32_t, ASM, 54)
    ANON_ENUM_KEY(int32_t, ESCAPE, 62)
END_ANON_ENUM()

ENUM_CONSTANT_NUMERIC(int32_t, ESCAPEmask, 255)

BEGIN_ANON_ENUM()
    ANON_ENUM_KEY(int32_t, ESClinnum, 256)
    ANON_ENUM_KEY(int32_t, ESCctor, 512)
    ANON_ENUM_KEY(int32_t, ESCdtor, 768)
    ANON_ENUM_KEY(int32_t, ESCmark, 1024)
    ANON_ENUM_KEY(int32_t, ESCrelease, 1280)
    ANON_ENUM_KEY(int32_t, ESCoffset, 1536)
    ANON_ENUM_KEY(int32_t, ESCadjesp, 1792)
    ANON_ENUM_KEY(int32_t, ESCmark2, 2048)
    ANON_ENUM_KEY(int32_t, ESCrelease2, 2304)
    ANON_ENUM_KEY(int32_t, ESCframeptr, 2560)
    ANON_ENUM_KEY(int32_t, ESCdctor, 2816)
    ANON_ENUM_KEY(int32_t, ESCddtor, 3072)
    ANON_ENUM_KEY(int32_t, ESCadjfpu, 3328)
    ANON_ENUM_KEY(int32_t, ESCfixesp, 3584)
END_ANON_ENUM()

BEGIN_ANON_ENUM()
    ANON_ENUM_KEY(int32_t, REX, 64)
    ANON_ENUM_KEY(int32_t, REX_W, 8)
    ANON_ENUM_KEY(int32_t, REX_R, 4)
    ANON_ENUM_KEY(int32_t, REX_X, 2)
    ANON_ENUM_KEY(int32_t, REX_B, 1)
END_ANON_ENUM()

struct NDP
{
    elem* e;
    uint32_t offset;
    NDP() : e(), offset() {}
};

struct Globals87
{
    NDP stack[8LLU];
    int32_t stackused;
    Barray<NDP> save;
    Globals87() : stackused(0), save() {}
};

extern Globals87 global87;

ENUM_CONSTANT_NUMERIC(int32_t, _modrm, 16)

BEGIN_ANON_ENUM()
    ANON_ENUM_KEY(int32_t, NUM_MASK, 7)
    ANON_ENUM_KEY(int32_t, NUM_MASKR, 8)
    ANON_ENUM_KEY(int32_t, _0, 16)
    ANON_ENUM_KEY(int32_t, _1, 1)
    ANON_ENUM_KEY(int32_t, _2, 2)
    ANON_ENUM_KEY(int32_t, _3, 3)
    ANON_ENUM_KEY(int32_t, _4, 4)
    ANON_ENUM_KEY(int32_t, _5, 5)
    ANON_ENUM_KEY(int32_t, _6, 6)
    ANON_ENUM_KEY(int32_t, _7, 7)
END_ANON_ENUM()

BEGIN_ANON_ENUM()
    ANON_ENUM_KEY(int32_t, _r, 16)
    ANON_ENUM_KEY(int32_t, _cb, 16)
    ANON_ENUM_KEY(int32_t, _cw, 16)
    ANON_ENUM_KEY(int32_t, _cd, 16)
    ANON_ENUM_KEY(int32_t, _cq, 16)
    ANON_ENUM_KEY(int32_t, _cp, 16)
    ANON_ENUM_KEY(int32_t, _ib, 0)
    ANON_ENUM_KEY(int32_t, _iw, 0)
    ANON_ENUM_KEY(int32_t, _id, 0)
    ANON_ENUM_KEY(int32_t, _rb, 0)
    ANON_ENUM_KEY(int32_t, _rw, 0)
    ANON_ENUM_KEY(int32_t, _rd, 0)
    ANON_ENUM_KEY(int32_t, _16_bit, 32)
    ANON_ENUM_KEY(int32_t, _32_bit, 64)
    ANON_ENUM_KEY(int32_t, _64_bit, 65536)
    ANON_ENUM_KEY(int32_t, _i64_bit, 131072)
    ANON_ENUM_KEY(int32_t, _I386, 128)
    ANON_ENUM_KEY(int32_t, _16_bit_addr, 256)
    ANON_ENUM_KEY(int32_t, _32_bit_addr, 512)
    ANON_ENUM_KEY(int32_t, _fwait, 1024)
    ANON_ENUM_KEY(int32_t, _nfwait, 2048)
END_ANON_ENUM()

BEGIN_ANON_ENUM()
    ANON_ENUM_KEY(int32_t, MOD_MASK, 61440)
    ANON_ENUM_KEY(int32_t, _modsi, 4096)
    ANON_ENUM_KEY(int32_t, _moddx, 8192)
    ANON_ENUM_KEY(int32_t, _mod2, 12288)
    ANON_ENUM_KEY(int32_t, _modax, 16384)
    ANON_ENUM_KEY(int32_t, _modnot1, 20480)
    ANON_ENUM_KEY(int32_t, _modaxdx, 24576)
    ANON_ENUM_KEY(int32_t, _moddi, 28672)
    ANON_ENUM_KEY(int32_t, _modsidi, 32768)
    ANON_ENUM_KEY(int32_t, _modcx, 36864)
    ANON_ENUM_KEY(int32_t, _modes, 40960)
    ANON_ENUM_KEY(int32_t, _modall, 45056)
    ANON_ENUM_KEY(int32_t, _modsiax, 49152)
    ANON_ENUM_KEY(int32_t, _modsinot1, 53248)
    ANON_ENUM_KEY(int32_t, _modcxr11, 57344)
    ANON_ENUM_KEY(int32_t, _modxmm0, 61440)
END_ANON_ENUM()

extern uint32_t VEX_128_W0(uint32_t op);

extern uint32_t VEX_128_W1(uint32_t op);

extern uint32_t VEX_128_WIG(uint32_t op);

extern uint32_t VEX_256_W0(uint32_t op);

extern uint32_t VEX_256_W1(uint32_t op);

extern uint32_t VEX_256_WIG(uint32_t op);

extern uint32_t VEX_NDS_128_W0(uint32_t op);

extern uint32_t VEX_NDS_128_W1(uint32_t op);

extern uint32_t VEX_NDS_128_WIG(uint32_t op);

extern uint32_t VEX_NDS_256_W0(uint32_t op);

extern uint32_t VEX_NDS_256_W1(uint32_t op);

extern uint32_t VEX_NDS_256_WIG(uint32_t op);

extern uint32_t VEX_NDD_128_W0(uint32_t op);

extern uint32_t VEX_NDD_128_W1(uint32_t op);

extern uint32_t VEX_NDD_128_WIG(uint32_t op);

extern uint32_t VEX_NDD_256_W0(uint32_t op);

extern uint32_t VEX_NDD_256_W1(uint32_t op);

extern uint32_t VEX_NDD_256_WIG(uint32_t op);

extern uint32_t VEX_DDS_128_W0(uint32_t op);

extern uint32_t VEX_DDS_128_W1(uint32_t op);

extern uint32_t VEX_DDS_128_WIG(uint32_t op);

extern uint32_t VEX_DDS_256_W0(uint32_t op);

extern uint32_t VEX_DDS_256_W1(uint32_t op);

extern uint32_t VEX_DDS_256_WIG(uint32_t op);

ENUM_CONSTANT_NUMERIC(int32_t, _VEX_W, 32768)

ENUM_CONSTANT_NUMERIC(int32_t, _VEX_L, 1024)

BEGIN_ANON_ENUM()
    ANON_ENUM_KEY(int32_t, VEX_NOO, 0)
    ANON_ENUM_KEY(int32_t, VEX_NDS, 1)
    ANON_ENUM_KEY(int32_t, VEX_NDD, 2)
    ANON_ENUM_KEY(int32_t, VEX_DDS, 3)
    ANON_ENUM_KEY(int32_t, _VEX_NOO, 0)
    ANON_ENUM_KEY(int32_t, _VEX_NDS, 2048)
    ANON_ENUM_KEY(int32_t, _VEX_NDD, 4096)
    ANON_ENUM_KEY(int32_t, _VEX_DDS, 6144)
END_ANON_ENUM()

extern uint32_t _VEX(uint32_t op);

extern uint32_t _VEX_MM(uint32_t op);

extern uint32_t _VEX_PP(uint32_t op);

extern uint32_t _VEX_ASSERT0();

typedef uint32_t opflag_t;

BEGIN_ANON_ENUM_NUMERIC(uint32_t)
    ANON_ENUM_KEY_NUMERIC(uint32_t, _r8, 1u)
    ANON_ENUM_KEY_NUMERIC(uint32_t, _r16, 2u)
    ANON_ENUM_KEY_NUMERIC(uint32_t, _r32, 3u)
    ANON_ENUM_KEY_NUMERIC(uint32_t, _r64, 5u)
    ANON_ENUM_KEY_NUMERIC(uint32_t, _m8, 33u)
    ANON_ENUM_KEY_NUMERIC(uint32_t, _m16, 34u)
    ANON_ENUM_KEY_NUMERIC(uint32_t, _m32, 35u)
    ANON_ENUM_KEY_NUMERIC(uint32_t, _m48, 36u)
    ANON_ENUM_KEY_NUMERIC(uint32_t, _m64, 37u)
    ANON_ENUM_KEY_NUMERIC(uint32_t, _m128, 38u)
    ANON_ENUM_KEY_NUMERIC(uint32_t, _m256, 50u)
    ANON_ENUM_KEY_NUMERIC(uint32_t, _m48_32_16_8, 44u)
    ANON_ENUM_KEY_NUMERIC(uint32_t, _m64_48_32_16_8, 49u)
    ANON_ENUM_KEY_NUMERIC(uint32_t, _rm8, 193u)
    ANON_ENUM_KEY_NUMERIC(uint32_t, _rm16, 194u)
    ANON_ENUM_KEY_NUMERIC(uint32_t, _rm32, 195u)
    ANON_ENUM_KEY_NUMERIC(uint32_t, _rm64, 197u)
    ANON_ENUM_KEY_NUMERIC(uint32_t, _r32m8, 200u)
    ANON_ENUM_KEY_NUMERIC(uint32_t, _r32m16, 201u)
    ANON_ENUM_KEY_NUMERIC(uint32_t, _regm8, 206u)
    ANON_ENUM_KEY_NUMERIC(uint32_t, _imm8, 65u)
    ANON_ENUM_KEY_NUMERIC(uint32_t, _imm16, 66u)
    ANON_ENUM_KEY_NUMERIC(uint32_t, _imm32, 67u)
    ANON_ENUM_KEY_NUMERIC(uint32_t, _imm64, 69u)
    ANON_ENUM_KEY_NUMERIC(uint32_t, _rel8, 97u)
    ANON_ENUM_KEY_NUMERIC(uint32_t, _rel16, 98u)
    ANON_ENUM_KEY_NUMERIC(uint32_t, _rel32, 99u)
    ANON_ENUM_KEY_NUMERIC(uint32_t, _p1616, 163u)
    ANON_ENUM_KEY_NUMERIC(uint32_t, _m1616, 131u)
    ANON_ENUM_KEY_NUMERIC(uint32_t, _p1632, 164u)
    ANON_ENUM_KEY_NUMERIC(uint32_t, _m1632, 132u)
    ANON_ENUM_KEY_NUMERIC(uint32_t, _special, 512u)
    ANON_ENUM_KEY_NUMERIC(uint32_t, _seg, 256u)
    ANON_ENUM_KEY_NUMERIC(uint32_t, _a16, 768u)
    ANON_ENUM_KEY_NUMERIC(uint32_t, _a32, 1024u)
    ANON_ENUM_KEY_NUMERIC(uint32_t, _f16, 1280u)
    ANON_ENUM_KEY_NUMERIC(uint32_t, _f32, 1536u)
    ANON_ENUM_KEY_NUMERIC(uint32_t, _lbl, 1792u)
    ANON_ENUM_KEY_NUMERIC(uint32_t, _mmm32, 6176u)
    ANON_ENUM_KEY_NUMERIC(uint32_t, _mmm64, 8229u)
    ANON_ENUM_KEY_NUMERIC(uint32_t, _mmm128, 65568u)
    ANON_ENUM_KEY_NUMERIC(uint32_t, _xmm_m16, 33314u)
    ANON_ENUM_KEY_NUMERIC(uint32_t, _xmm_m32, 33315u)
    ANON_ENUM_KEY_NUMERIC(uint32_t, _xmm_m64, 33330u)
    ANON_ENUM_KEY_NUMERIC(uint32_t, _xmm_m128, 33318u)
    ANON_ENUM_KEY_NUMERIC(uint32_t, _ymm_m256, 131634u)
    ANON_ENUM_KEY_NUMERIC(uint32_t, _moffs8, 97u)
    ANON_ENUM_KEY_NUMERIC(uint32_t, _moffs16, 98u)
    ANON_ENUM_KEY_NUMERIC(uint32_t, _moffs32, 99u)
END_ANON_ENUM_NUMERIC(uint32_t)

ENUM_CONSTANT_NUMERIC(uint32_t, _fm80, 16416u)
ENUM_CONSTANT_NUMERIC(uint32_t, _fm64, 8224u)
ENUM_CONSTANT_NUMERIC(uint32_t, _fm128, 65568u)
ENUM_CONSTANT_NUMERIC(int32_t, _fanysize, 28)
ENUM_CONSTANT_NUMERIC(uint32_t, _float_m, 57586u)
ENUM_CONSTANT_NUMERIC(uint32_t, _st, 2272u)
ENUM_CONSTANT_NUMERIC(uint32_t, _m112, 32800u)
ENUM_CONSTANT_NUMERIC(uint32_t, _m224, 32800u)
ENUM_CONSTANT_NUMERIC(uint32_t, _m512, 32800u)
ENUM_CONSTANT_NUMERIC(uint32_t, _sti, 4320u)


extern uint32_t CONSTRUCT_FLAGS(uint32_t uSizemask, uint32_t aopty, uint32_t amod, uint32_t uRegmask);

extern uint32_t ASM_GET_aopty(uint32_t us);

extern uint32_t ASM_GET_amod(uint32_t us);

extern uint32_t ASM_GET_uRegmask(uint32_t us);

BEGIN_ENUM_NUMERIC(uint8_t, OpndSize, OPNDSIZE, opndsize)
    ENUM_KEY_NUMERIC(uint8_t, none, 0u, OpndSize, OPNDSIZE, opndsize, OS)
    ENUM_KEY_NUMERIC(uint8_t, _8, 1u, OpndSize, OPNDSIZE, opndsize, OS)
    ENUM_KEY_NUMERIC(uint8_t, _16, 2u, OpndSize, OPNDSIZE, opndsize, OS)
    ENUM_KEY_NUMERIC(uint8_t, _32, 3u, OpndSize, OPNDSIZE, opndsize, OS)
    ENUM_KEY_NUMERIC(uint8_t, _48, 4u, OpndSize, OPNDSIZE, opndsize, OS)
    ENUM_KEY_NUMERIC(uint8_t, _64, 5u, OpndSize, OPNDSIZE, opndsize, OS)
    ENUM_KEY_NUMERIC(uint8_t, _128, 6u, OpndSize, OPNDSIZE, opndsize, OS)
    ENUM_KEY_NUMERIC(uint8_t, _16_8, 7u, OpndSize, OPNDSIZE, opndsize, OS)
    ENUM_KEY_NUMERIC(uint8_t, _32_8, 8u, OpndSize, OPNDSIZE, opndsize, OS)
    ENUM_KEY_NUMERIC(uint8_t, _32_16, 9u, OpndSize, OPNDSIZE, opndsize, OS)
    ENUM_KEY_NUMERIC(uint8_t, _32_16_8, 10u, OpndSize, OPNDSIZE, opndsize, OS)
    ENUM_KEY_NUMERIC(uint8_t, _48_32, 11u, OpndSize, OPNDSIZE, opndsize, OS)
    ENUM_KEY_NUMERIC(uint8_t, _48_32_16_8, 12u, OpndSize, OPNDSIZE, opndsize, OS)
    ENUM_KEY_NUMERIC(uint8_t, _64_32, 13u, OpndSize, OPNDSIZE, opndsize, OS)
    ENUM_KEY_NUMERIC(uint8_t, _64_32_8, 14u, OpndSize, OPNDSIZE, opndsize, OS)
    ENUM_KEY_NUMERIC(uint8_t, _64_32_16, 15u, OpndSize, OPNDSIZE, opndsize, OS)
    ENUM_KEY_NUMERIC(uint8_t, _64_32_16_8, 16u, OpndSize, OPNDSIZE, opndsize, OS)
    ENUM_KEY_NUMERIC(uint8_t, _64_48_32_16_8, 17u, OpndSize, OPNDSIZE, opndsize, OS)
    ENUM_KEY_NUMERIC(uint8_t, _anysize, 18u, OpndSize, OPNDSIZE, opndsize, OS)
END_ENUM_NUMERIC(uint8_t, OpndSize, OPNDSIZE, opndsize)

extern OpndSize getOpndSize(uint32_t us);

typedef uint32_t ASM_OPERAND_TYPE;

BEGIN_ANON_ENUM()
    ANON_ENUM_KEY(int32_t, _reg, 0)
    ANON_ENUM_KEY(int32_t, _m, 1)
    ANON_ENUM_KEY(int32_t, _imm, 2)
    ANON_ENUM_KEY(int32_t, _rel, 3)
    ANON_ENUM_KEY(int32_t, _mnoi, 4)
    ANON_ENUM_KEY(int32_t, _p, 5)
    ANON_ENUM_KEY(int32_t, _rm, 6)
    ANON_ENUM_KEY(int32_t, _float, 7)
END_ANON_ENUM()

typedef uint32_t ASM_MODIFIERS;

BEGIN_ANON_ENUM()
    ANON_ENUM_KEY(int32_t, _normal, 0)
    ANON_ENUM_KEY(int32_t, _rseg, 1)
    ANON_ENUM_KEY(int32_t, _rspecial, 2)
    ANON_ENUM_KEY(int32_t, _addr16, 3)
    ANON_ENUM_KEY(int32_t, _addr32, 4)
    ANON_ENUM_KEY(int32_t, _fn16, 5)
    ANON_ENUM_KEY(int32_t, _fn32, 6)
    ANON_ENUM_KEY(int32_t, _flbl, 7)
END_ANON_ENUM()

BEGIN_ANON_ENUM()
    ANON_ENUM_KEY(int32_t, _rst, 1)
    ANON_ENUM_KEY(int32_t, _rsti, 2)
    ANON_ENUM_KEY(int32_t, _f64, 4)
    ANON_ENUM_KEY(int32_t, _f80, 8)
    ANON_ENUM_KEY(int32_t, _f112, 16)
    ANON_ENUM_KEY(int32_t, _f128, 32)
END_ANON_ENUM()

BEGIN_ANON_ENUM_NUMERIC(uint32_t)
    ANON_ENUM_KEY_NUMERIC(uint32_t, _ds, 2304u)
    ANON_ENUM_KEY_NUMERIC(uint32_t, _es, 4352u)
    ANON_ENUM_KEY_NUMERIC(uint32_t, _ss, 8448u)
    ANON_ENUM_KEY_NUMERIC(uint32_t, _fs, 16640u)
    ANON_ENUM_KEY_NUMERIC(uint32_t, _gs, 33024u)
    ANON_ENUM_KEY_NUMERIC(uint32_t, _cs, 65792u)
END_ANON_ENUM_NUMERIC(uint32_t)

BEGIN_ANON_ENUM_NUMERIC(uint32_t)
    ANON_ENUM_KEY_NUMERIC(uint32_t, _crn, 2560u)
    ANON_ENUM_KEY_NUMERIC(uint32_t, _drn, 4608u)
    ANON_ENUM_KEY_NUMERIC(uint32_t, _trn, 8704u)
    ANON_ENUM_KEY_NUMERIC(uint32_t, _mm, 16896u)
    ANON_ENUM_KEY_NUMERIC(uint32_t, _xmm, 33280u)
    ANON_ENUM_KEY_NUMERIC(uint32_t, _xmm0, 66048u)
    ANON_ENUM_KEY_NUMERIC(uint32_t, _ymm, 131584u)
END_ANON_ENUM_NUMERIC(uint32_t)

BEGIN_ANON_ENUM_NUMERIC(uint32_t)
    ANON_ENUM_KEY_NUMERIC(uint32_t, _al, 2048u)
    ANON_ENUM_KEY_NUMERIC(uint32_t, _ax, 4096u)
    ANON_ENUM_KEY_NUMERIC(uint32_t, _eax, 8192u)
    ANON_ENUM_KEY_NUMERIC(uint32_t, _dx, 16384u)
    ANON_ENUM_KEY_NUMERIC(uint32_t, _cl, 32768u)
    ANON_ENUM_KEY_NUMERIC(uint32_t, _rax, 131072u)
END_ANON_ENUM_NUMERIC(uint32_t)

ENUM_CONSTANT_NUMERIC(int32_t, _rplus_r, 32)

ENUM_CONSTANT_NUMERIC(uint32_t, _plus_r, 65536u)

BEGIN_ANON_ENUM()
    ANON_ENUM_KEY(int32_t, ITprefix, 16)
    ANON_ENUM_KEY(int32_t, ITjump, 32)
    ANON_ENUM_KEY(int32_t, ITimmed, 48)
    ANON_ENUM_KEY(int32_t, ITopt, 64)
    ANON_ENUM_KEY(int32_t, ITshift, 80)
    ANON_ENUM_KEY(int32_t, ITfloat, 96)
    ANON_ENUM_KEY(int32_t, ITdata, 112)
    ANON_ENUM_KEY(int32_t, ITaddr, 128)
    ANON_ENUM_KEY(int32_t, ITMASK, 240)
    ANON_ENUM_KEY(int32_t, ITSIZE, 15)
END_ANON_ENUM()

typedef int32_t OP_DB;

BEGIN_ANON_ENUM()
    ANON_ENUM_KEY(int32_t, OPdb, 0)
    ANON_ENUM_KEY(int32_t, OPds, 1)
    ANON_ENUM_KEY(int32_t, OPdi, 2)
    ANON_ENUM_KEY(int32_t, OPdl, 3)
    ANON_ENUM_KEY(int32_t, OPdf, 4)
    ANON_ENUM_KEY(int32_t, OPdd, 5)
    ANON_ENUM_KEY(int32_t, OPde, 6)
    ANON_ENUM_KEY(int32_t, OPdw, 1)
    ANON_ENUM_KEY(int32_t, OPdq, 3)
    ANON_ENUM_KEY(int32_t, OPdt, 6)
END_ANON_ENUM()

struct PTRNTAB4
{
    uint32_t opcode;
    uint32_t usFlags;
    uint32_t usOp1;
    uint32_t usOp2;
    uint32_t usOp3;
    uint32_t usOp4;
    PTRNTAB4() : opcode(), usFlags(), usOp1(), usOp2(), usOp3(), usOp4() {}
};

struct PTRNTAB3
{
    uint32_t opcode;
    uint32_t usFlags;
    uint32_t usOp1;
    uint32_t usOp2;
    uint32_t usOp3;
    PTRNTAB3() : opcode(), usFlags(), usOp1(), usOp2(), usOp3() {}
};

struct PTRNTAB2
{
    uint32_t opcode;
    uint32_t usFlags;
    uint32_t usOp1;
    uint32_t usOp2;
    PTRNTAB2() : opcode(), usFlags(), usOp1(), usOp2() {}
};

struct PTRNTAB1
{
    uint32_t opcode;
    uint32_t usFlags;
    uint32_t usOp1;
    PTRNTAB1() : opcode(), usFlags(), usOp1() {}
};

ENUM_CONSTANT_NUMERIC(int32_t, ASM_END, 65535)

struct PTRNTAB0
{
    uint32_t opcode;
    uint32_t usFlags;
    PTRNTAB0() : opcode(), usFlags() {}
};

union PTRNTAB
{
    void* ppt;
    PTRNTAB0* pptb0;
    PTRNTAB1* pptb1;
    PTRNTAB2* pptb2;
    PTRNTAB3* pptb3;
    PTRNTAB4* pptb4;
    PTRNTAB() : ppt(), pptb0(), pptb1(), pptb2(), pptb3(), pptb4() {}
};

struct OP
{
    const char* str;
    uint8_t usNumops;
    PTRNTAB ptb;
    OP() : str(), usNumops(), ptb() {}
};

struct CodeBuilder
{
    code* head;
    code** pTail;
    void ctor();
    void ctor(code* c);
    code* finish();
    code* peek();
    void reset();
    void append(CodeBuilder& cdb);
    void append(CodeBuilder& cdb1, CodeBuilder& cdb2);
    void append(CodeBuilder& cdb1, CodeBuilder& cdb2, CodeBuilder& cdb3);
    void append(CodeBuilder& cdb1, CodeBuilder& cdb2, CodeBuilder& cdb3, CodeBuilder& cdb4);
    void append(CodeBuilder& cdb1, CodeBuilder& cdb2, CodeBuilder& cdb3, CodeBuilder& cdb4, CodeBuilder& cdb5);
    void append(code* c);
    void gen(code* cs);
    void gen1(uint32_t op);
    void gen2(uint32_t op, uint32_t rm);
    void genf2(uint32_t op, uint32_t rm);
    void gen2sib(uint32_t op, uint32_t rm, uint32_t sib);
    void genasm(char* s, uint32_t slen);
    void genasm(_LabelDsymbol* label);
    void genasm(block* label);
    void gencs(uint32_t op, uint32_t ea, uint32_t FL2, Symbol* s);
    void genc2(uint32_t op, uint32_t ea, targ_size_t EV2);
    void genc1(uint32_t op, uint32_t ea, uint32_t FL1, targ_size_t EV1);
    void genc(uint32_t op, uint32_t ea, uint32_t FL1, targ_size_t EV1, uint32_t FL2, targ_size_t EV2);
    void genlinnum(Srcpos srcpos);
    void genadjesp(int32_t offset);
    void genadjfpu(int32_t offset);
    void gennop();
    void genfltreg(uint32_t opcode, uint32_t reg, targ_size_t offset);
    void genxmmreg(uint32_t opcode, uint8_t xreg, targ_size_t offset, uint32_t tym);
    code* last();
    static void ccheck(code* cs);
    CodeBuilder() {}
};

typedef uint32_t tym_t;

BEGIN_ANON_ENUM()
    ANON_ENUM_KEY(int32_t, TYbool, 0)
    ANON_ENUM_KEY(int32_t, TYchar, 1)
    ANON_ENUM_KEY(int32_t, TYschar, 2)
    ANON_ENUM_KEY(int32_t, TYuchar, 3)
    ANON_ENUM_KEY(int32_t, TYchar8, 4)
    ANON_ENUM_KEY(int32_t, TYchar16, 5)
    ANON_ENUM_KEY(int32_t, TYshort, 6)
    ANON_ENUM_KEY(int32_t, TYwchar_t, 7)
    ANON_ENUM_KEY(int32_t, TYushort, 8)
    ANON_ENUM_KEY(int32_t, TYenum, 9)
    ANON_ENUM_KEY(int32_t, TYint, 10)
    ANON_ENUM_KEY(int32_t, TYuint, 11)
    ANON_ENUM_KEY(int32_t, TYlong, 12)
    ANON_ENUM_KEY(int32_t, TYulong, 13)
    ANON_ENUM_KEY(int32_t, TYdchar, 14)
    ANON_ENUM_KEY(int32_t, TYllong, 15)
    ANON_ENUM_KEY(int32_t, TYullong, 16)
    ANON_ENUM_KEY(int32_t, TYfloat, 17)
    ANON_ENUM_KEY(int32_t, TYdouble, 18)
    ANON_ENUM_KEY(int32_t, TYdouble_alias, 19)
    ANON_ENUM_KEY(int32_t, TYldouble, 20)
    ANON_ENUM_KEY(int32_t, TYifloat, 21)
    ANON_ENUM_KEY(int32_t, TYidouble, 22)
    ANON_ENUM_KEY(int32_t, TYildouble, 23)
    ANON_ENUM_KEY(int32_t, TYcfloat, 24)
    ANON_ENUM_KEY(int32_t, TYcdouble, 25)
    ANON_ENUM_KEY(int32_t, TYcldouble, 26)
    ANON_ENUM_KEY(int32_t, TYnullptr, 28)
    ANON_ENUM_KEY(int32_t, TYnptr, 29)
    ANON_ENUM_KEY(int32_t, TYref, 36)
    ANON_ENUM_KEY(int32_t, TYvoid, 37)
    ANON_ENUM_KEY(int32_t, TYstruct, 38)
    ANON_ENUM_KEY(int32_t, TYarray, 39)
    ANON_ENUM_KEY(int32_t, TYnfunc, 40)
    ANON_ENUM_KEY(int32_t, TYnpfunc, 42)
    ANON_ENUM_KEY(int32_t, TYnsfunc, 44)
    ANON_ENUM_KEY(int32_t, TYifunc, 46)
    ANON_ENUM_KEY(int32_t, TYptr, 51)
    ANON_ENUM_KEY(int32_t, TYmfunc, 55)
    ANON_ENUM_KEY(int32_t, TYjfunc, 56)
    ANON_ENUM_KEY(int32_t, TYhfunc, 57)
    ANON_ENUM_KEY(int32_t, TYnref, 58)
    ANON_ENUM_KEY(int32_t, TYcent, 60)
    ANON_ENUM_KEY(int32_t, TYucent, 61)
    ANON_ENUM_KEY(int32_t, TYsptr, 30)
    ANON_ENUM_KEY(int32_t, TYcptr, 31)
    ANON_ENUM_KEY(int32_t, TYf16ptr, 32)
    ANON_ENUM_KEY(int32_t, TYfptr, 33)
    ANON_ENUM_KEY(int32_t, TYhptr, 34)
    ANON_ENUM_KEY(int32_t, TYvptr, 35)
    ANON_ENUM_KEY(int32_t, TYffunc, 41)
    ANON_ENUM_KEY(int32_t, TYfpfunc, 43)
    ANON_ENUM_KEY(int32_t, TYfsfunc, 45)
    ANON_ENUM_KEY(int32_t, TYf16func, 52)
    ANON_ENUM_KEY(int32_t, TYnsysfunc, 53)
    ANON_ENUM_KEY(int32_t, TYfsysfunc, 54)
    ANON_ENUM_KEY(int32_t, TYfref, 59)
    ANON_ENUM_KEY(int32_t, TYmemptr, 47)
    ANON_ENUM_KEY(int32_t, TYident, 48)
    ANON_ENUM_KEY(int32_t, TYtemplate, 49)
    ANON_ENUM_KEY(int32_t, TYvtshape, 50)
    ANON_ENUM_KEY(int32_t, TYfloat4, 62)
    ANON_ENUM_KEY(int32_t, TYdouble2, 63)
    ANON_ENUM_KEY(int32_t, TYschar16, 64)
    ANON_ENUM_KEY(int32_t, TYuchar16, 65)
    ANON_ENUM_KEY(int32_t, TYshort8, 66)
    ANON_ENUM_KEY(int32_t, TYushort8, 67)
    ANON_ENUM_KEY(int32_t, TYlong4, 68)
    ANON_ENUM_KEY(int32_t, TYulong4, 69)
    ANON_ENUM_KEY(int32_t, TYllong2, 70)
    ANON_ENUM_KEY(int32_t, TYullong2, 71)
    ANON_ENUM_KEY(int32_t, TYfloat8, 72)
    ANON_ENUM_KEY(int32_t, TYdouble4, 73)
    ANON_ENUM_KEY(int32_t, TYschar32, 74)
    ANON_ENUM_KEY(int32_t, TYuchar32, 75)
    ANON_ENUM_KEY(int32_t, TYshort16, 76)
    ANON_ENUM_KEY(int32_t, TYushort16, 77)
    ANON_ENUM_KEY(int32_t, TYlong8, 78)
    ANON_ENUM_KEY(int32_t, TYulong8, 79)
    ANON_ENUM_KEY(int32_t, TYllong4, 80)
    ANON_ENUM_KEY(int32_t, TYullong4, 81)
    ANON_ENUM_KEY(int32_t, TYfloat16, 82)
    ANON_ENUM_KEY(int32_t, TYdouble8, 83)
    ANON_ENUM_KEY(int32_t, TYschar64, 84)
    ANON_ENUM_KEY(int32_t, TYuchar64, 85)
    ANON_ENUM_KEY(int32_t, TYshort32, 86)
    ANON_ENUM_KEY(int32_t, TYushort32, 87)
    ANON_ENUM_KEY(int32_t, TYlong16, 88)
    ANON_ENUM_KEY(int32_t, TYulong16, 89)
    ANON_ENUM_KEY(int32_t, TYllong8, 90)
    ANON_ENUM_KEY(int32_t, TYullong8, 91)
    ANON_ENUM_KEY(int32_t, TYsharePtr, 92)
    ANON_ENUM_KEY(int32_t, TYimmutPtr, 93)
    ANON_ENUM_KEY(int32_t, TYfgPtr, 94)
    ANON_ENUM_KEY(int32_t, TYrestrictPtr, 95)
    ANON_ENUM_KEY(int32_t, TYMAX, 96)
END_ANON_ENUM()

extern int32_t TYaarray;

extern int32_t TYdelegate;

extern int32_t TYdarray;

extern int32_t TYptrdiff;

extern int32_t TYsize;

extern int32_t TYsize_t;

ENUM_CONSTANT_NUMERIC(int32_t, mTYbasic, 255)
ENUM_CONSTANT_NUMERIC(int32_t, mTYnear, 2048)
ENUM_CONSTANT_NUMERIC(int32_t, mTYfar, 4096)
ENUM_CONSTANT_NUMERIC(int32_t, mTYcs, 8192)
ENUM_CONSTANT_NUMERIC(int32_t, mTYthread, 16384)
ENUM_CONSTANT_NUMERIC(int32_t, mTYthreadData, 20480)
ENUM_CONSTANT_NUMERIC(int32_t, mTYLINK, 30720)
ENUM_CONSTANT_NUMERIC(int32_t, mTYloadds, 32768)
ENUM_CONSTANT_NUMERIC(int32_t, mTYexport, 65536)
ENUM_CONSTANT_NUMERIC(int32_t, mTYweak, 0)
ENUM_CONSTANT_NUMERIC(int32_t, mTYimport, 131072)
ENUM_CONSTANT_NUMERIC(int32_t, mTYnaked, 262144)
ENUM_CONSTANT_NUMERIC(int32_t, mTYMOD, 491520)
ENUM_CONSTANT_NUMERIC(int32_t, mTYarrayhandle, 0)
ENUM_CONSTANT_NUMERIC(int32_t, mTYconst, 256)
ENUM_CONSTANT_NUMERIC(int32_t, mTYvolatile, 512)
ENUM_CONSTANT_NUMERIC(int32_t, mTYrestrict, 0)
ENUM_CONSTANT_NUMERIC(int32_t, mTYmutable, 0)
ENUM_CONSTANT_NUMERIC(int32_t, mTYunaligned, 0)
ENUM_CONSTANT_NUMERIC(int32_t, mTYimmutable, 524288)
ENUM_CONSTANT_NUMERIC(int32_t, mTYshared, 1048576)
ENUM_CONSTANT_NUMERIC(int32_t, mTYnothrow, 2097152)
ENUM_CONSTANT_NUMERIC(int32_t, mTYxmmgpr, 4194304)
ENUM_CONSTANT_NUMERIC(int32_t, mTYgprxmm, 8388608)
ENUM_CONSTANT_NUMERIC(int32_t, mTYnoret, 16777216)
ENUM_CONSTANT_NUMERIC(int32_t, mTYtransu, 16777216)
ENUM_CONSTANT_NUMERIC(int32_t, mTYfar16, 16777216)
ENUM_CONSTANT_NUMERIC(int32_t, mTYstdcall, 33554432)
ENUM_CONSTANT_NUMERIC(int32_t, mTYfastcall, 67108864)
ENUM_CONSTANT_NUMERIC(int32_t, mTYinterrupt, 134217728)
ENUM_CONSTANT_NUMERIC(int32_t, mTYcdecl, 268435456)
ENUM_CONSTANT_NUMERIC(int32_t, mTYpascal, 536870912)
ENUM_CONSTANT_NUMERIC(int32_t, mTYsyscall, 1073741824)
ENUM_CONSTANT_NUMERIC(uint32_t, mTYjava, 2147483648u)
ENUM_CONSTANT_NUMERIC(uint32_t, mTYTFF, 4278190080u)


extern uint32_t tybasic(uint32_t ty);

extern uint32_t tytab[256LLU];

BEGIN_ANON_ENUM()
    ANON_ENUM_KEY(int32_t, TYFLptr, 1)
    ANON_ENUM_KEY(int32_t, TYFLreal, 2)
    ANON_ENUM_KEY(int32_t, TYFLintegral, 4)
    ANON_ENUM_KEY(int32_t, TYFLcomplex, 8)
    ANON_ENUM_KEY(int32_t, TYFLimaginary, 16)
    ANON_ENUM_KEY(int32_t, TYFLuns, 32)
    ANON_ENUM_KEY(int32_t, TYFLmptr, 64)
    ANON_ENUM_KEY(int32_t, TYFLfv, 128)
    ANON_ENUM_KEY(int32_t, TYFLpascal, 512)
    ANON_ENUM_KEY(int32_t, TYFLrevparam, 1024)
    ANON_ENUM_KEY(int32_t, TYFLnullptr, 2048)
    ANON_ENUM_KEY(int32_t, TYFLshort, 4096)
    ANON_ENUM_KEY(int32_t, TYFLaggregate, 8192)
    ANON_ENUM_KEY(int32_t, TYFLfunc, 16384)
    ANON_ENUM_KEY(int32_t, TYFLref, 32768)
    ANON_ENUM_KEY(int32_t, TYFLsimd, 131072)
    ANON_ENUM_KEY(int32_t, TYFLfarfunc, 256)
    ANON_ENUM_KEY(int32_t, TYFLxmmreg, 65536)
END_ANON_ENUM()

extern int8_t _tysize[256LLU];

extern int8_t _tyalignsize[256LLU];

extern int8_t tysize(uint32_t ty);

extern int8_t tyalignsize(uint32_t ty);

extern uint32_t tyintegral(uint32_t ty);

extern uint32_t tyarithmetic(uint32_t ty);

extern uint32_t tyaggregate(uint32_t ty);

extern uint32_t tyscalar(uint32_t ty);

extern uint32_t tyfloating(uint32_t ty);

extern uint32_t tyimaginary(uint32_t ty);

extern uint32_t tycomplex(uint32_t ty);

extern uint32_t tyreal(uint32_t ty);

extern bool ty64reg(uint32_t ty);

extern uint32_t tyxmmreg(uint32_t ty);

extern bool tyvector(uint32_t ty);

extern uint32_t tyshort(uint32_t ty);

extern bool tylong(uint32_t ty);

extern uint32_t typtr(uint32_t ty);

extern uint32_t tyref(uint32_t ty);

extern uint32_t tymptr(uint32_t ty);

extern uint32_t tynullptr(uint32_t ty);

extern uint32_t tyfv(uint32_t ty);

extern bool tybyte(uint32_t ty);

extern bool tyreg(uint32_t ty);

extern uint32_t tyfunc(uint32_t ty);

extern uint32_t tyrevfunc(uint32_t ty);

extern uint32_t tyuns(uint32_t ty);

extern uint32_t typfunc(uint32_t ty);

extern uint32_t tytouns[256LLU];

extern uint32_t touns(uint32_t ty);

extern uint32_t tyfarfunc(uint32_t ty);

extern uint32_t tysimd(uint32_t ty);

extern uint8_t _tyrelax[96LLU];

extern uint32_t tyrelax(uint32_t ty);

extern uint8_t tyequiv[96LLU];

extern "C" const char* tystring[96LLU];

extern uint8_t dttab[96LLU];

extern uint16_t dttab4[96LLU];

extern bool I16();

extern bool I32();

extern bool I64();

typedef uint8_t mangle_t;

BEGIN_ANON_ENUM()
    ANON_ENUM_KEY(int32_t, mTYman_c, 1)
    ANON_ENUM_KEY(int32_t, mTYman_cpp, 2)
    ANON_ENUM_KEY(int32_t, mTYman_pas, 3)
    ANON_ENUM_KEY(int32_t, mTYman_for, 4)
    ANON_ENUM_KEY(int32_t, mTYman_sys, 5)
    ANON_ENUM_KEY(int32_t, mTYman_std, 6)
    ANON_ENUM_KEY(int32_t, mTYman_d, 7)
END_ANON_ENUM()

typedef uint16_t type_flags_t;

BEGIN_ANON_ENUM()
    ANON_ENUM_KEY(int32_t, TFprototype, 1)
    ANON_ENUM_KEY(int32_t, TFfixed, 2)
    ANON_ENUM_KEY(int32_t, TFgenerated, 4)
    ANON_ENUM_KEY(int32_t, TFdependent, 4)
    ANON_ENUM_KEY(int32_t, TFforward, 8)
    ANON_ENUM_KEY(int32_t, TFsizeunknown, 16)
    ANON_ENUM_KEY(int32_t, TFfuncret, 32)
    ANON_ENUM_KEY(int32_t, TFfuncparam, 32)
    ANON_ENUM_KEY(int32_t, TFhydrated, 32)
    ANON_ENUM_KEY(int32_t, TFstatic, 64)
    ANON_ENUM_KEY(int32_t, TFvla, 128)
    ANON_ENUM_KEY(int32_t, TFemptyexc, 256)
END_ANON_ENUM()

typedef TYPE type;

extern bool type_struct(const TYPE* const t);

struct TYPE
{
    ENUM_CONSTANT_NUMERIC(int32_t, IDtype, 4660)

    uint32_t Tty;
    uint16_t Tflags;
    uint8_t Tmangle;
    uint32_t Tcount;
    char* Tident;
    TYPE* Tnext;
    union
    {
        targ_size_t Tdim;
        elem* Tel;
        param_t* Tparamtypes;
        Symbol* Ttag;
        TYPE* Talternate;
        TYPE* Tkey;
    };
    LIST* Texcspec;
    Symbol* Ttypedef;
    TYPE() : Tty(), Tflags(), Tmangle(), Tcount(), Tident(), Tnext(), Texcspec(), Ttypedef() {}
};

struct typetemp_t
{
    TYPE Ttype;
    Symbol* Tsym;
    typetemp_t() : Ttype(), Tsym() {}
};

extern void type_debug(const TYPE* const t);

extern uint8_t type_mangle(const TYPE* const t);

extern bool variadic(const TYPE* const t);

extern TYPE* tstypes[96LLU];

extern TYPE* tsptr2types[96LLU];

extern TYPE* tslogical;

extern TYPE* chartype;

extern TYPE* tsclib;

extern TYPE* tsdlib;

extern TYPE* tspvoid;

extern TYPE* tspcvoid;

extern TYPE* tsptrdiff;

extern TYPE* tssize;

extern TYPE* tstrace;

struct Aobject
{
    Symbol* AOsym;
    targ_size_t AOoffset;
    Symbol* AOfunc;
    Aobject() : AOsym(), AOoffset(), AOfunc() {}
};

typedef int32_t cpu_type_t;

typedef int32_t cpu_subtype_t;

typedef int32_t vm_prot_t;

ENUM_CONSTANT_NUMERIC(uint32_t, MH_MAGIC, 4277009102u)
ENUM_CONSTANT_NUMERIC(uint32_t, MH_CIGAM, 3472551422u)
ENUM_CONSTANT_NUMERIC(int32_t, CPU_TYPE_I386, 7)
ENUM_CONSTANT_NUMERIC(int32_t, CPU_TYPE_X86_64, 16777223)
ENUM_CONSTANT_NUMERIC(int32_t, CPU_TYPE_POWERPC, 18)
ENUM_CONSTANT_NUMERIC(int32_t, CPU_TYPE_POWERPC64, 16777234)
ENUM_CONSTANT_NUMERIC(int32_t, CPU_SUBTYPE_POWERPC_ALL, 0)
ENUM_CONSTANT_NUMERIC(int32_t, CPU_SUBTYPE_I386_ALL, 3)
ENUM_CONSTANT_NUMERIC(int32_t, MH_OBJECT, 1)
ENUM_CONSTANT_NUMERIC(int32_t, MH_EXECUTE, 2)
ENUM_CONSTANT_NUMERIC(int32_t, MH_BUNDLE, 8)
ENUM_CONSTANT_NUMERIC(int32_t, MH_DYLIB, 6)
ENUM_CONSTANT_NUMERIC(int32_t, MH_PRELOAD, 5)
ENUM_CONSTANT_NUMERIC(int32_t, MH_CORE, 4)
ENUM_CONSTANT_NUMERIC(int32_t, MH_DYLINKER, 7)
ENUM_CONSTANT_NUMERIC(int32_t, MH_DSYM, 10)
ENUM_CONSTANT_NUMERIC(int32_t, MH_NOUNDEFS, 1)
ENUM_CONSTANT_NUMERIC(int32_t, MH_INCRLINK, 2)
ENUM_CONSTANT_NUMERIC(int32_t, MH_DYLDLINK, 4)
ENUM_CONSTANT_NUMERIC(int32_t, MH_TWOLEVEL, 128)
ENUM_CONSTANT_NUMERIC(int32_t, MH_BINDATLOAD, 8)
ENUM_CONSTANT_NUMERIC(int32_t, MH_PREBOUND, 16)
ENUM_CONSTANT_NUMERIC(int32_t, MH_PREBINDABLE, 2048)
ENUM_CONSTANT_NUMERIC(int32_t, MH_NOFIXPREBINDING, 1024)
ENUM_CONSTANT_NUMERIC(int32_t, MH_ALLMODSBOUND, 4096)
ENUM_CONSTANT_NUMERIC(int32_t, MH_CANONICAL, 16384)
ENUM_CONSTANT_NUMERIC(int32_t, MH_SPLIT_SEGS, 32)
ENUM_CONSTANT_NUMERIC(int32_t, MH_FORCE_FLAT, 256)
ENUM_CONSTANT_NUMERIC(int32_t, MH_SUBSECTIONS_VIA_SYMBOLS, 8192)
ENUM_CONSTANT_NUMERIC(int32_t, MH_NOMULTIDEFS, 512)


BEGIN_ANON_ENUM_NUMERIC(uint32_t)
    ANON_ENUM_KEY_NUMERIC(uint32_t, MH_MAGIC_64, 4277009103u)
    ANON_ENUM_KEY_NUMERIC(uint32_t, MH_CIGAM_64, 3489328638u)
END_ANON_ENUM_NUMERIC(uint32_t)

BEGIN_ANON_ENUM()
    ANON_ENUM_KEY(int32_t, LC_SEGMENT, 1)
    ANON_ENUM_KEY(int32_t, LC_SYMTAB, 2)
    ANON_ENUM_KEY(int32_t, LC_DYSYMTAB, 11)
    ANON_ENUM_KEY(int32_t, LC_SEGMENT_64, 25)
END_ANON_ENUM()

BEGIN_ANON_ENUM()
    ANON_ENUM_KEY(int32_t, SG_HIGHVM, 1)
    ANON_ENUM_KEY(int32_t, SG_FVMLIB, 2)
    ANON_ENUM_KEY(int32_t, SG_NORELOC, 4)
    ANON_ENUM_KEY(int32_t, SG_PROTECTED_VERSION_1, 8)
END_ANON_ENUM()

ENUM_CONSTANT_NUMERIC(int32_t, SECTION_TYPE, 255)
ENUM_CONSTANT_NUMERIC(uint32_t, SECTION_ATTRIBUTES, 4294967040u)
ENUM_CONSTANT_NUMERIC(int32_t, S_REGULAR, 0)
ENUM_CONSTANT_NUMERIC(int32_t, S_ZEROFILL, 1)
ENUM_CONSTANT_NUMERIC(int32_t, S_CSTRING_LITERALS, 2)
ENUM_CONSTANT_NUMERIC(int32_t, S_4BYTE_LITERALS, 3)
ENUM_CONSTANT_NUMERIC(int32_t, S_8BYTE_LITERALS, 4)
ENUM_CONSTANT_NUMERIC(int32_t, S_LITERAL_POINTERS, 5)
ENUM_CONSTANT_NUMERIC(int32_t, S_NON_LAZY_SYMBOL_POINTERS, 6)
ENUM_CONSTANT_NUMERIC(int32_t, S_LAZY_SYMBOL_POINTERS, 7)
ENUM_CONSTANT_NUMERIC(int32_t, S_SYMBOL_STUBS, 8)
ENUM_CONSTANT_NUMERIC(int32_t, S_MOD_INIT_FUNC_POINTERS, 9)
ENUM_CONSTANT_NUMERIC(int32_t, S_MOD_TERM_FUNC_POINTERS, 10)
ENUM_CONSTANT_NUMERIC(int32_t, S_COALESCED, 11)
ENUM_CONSTANT_NUMERIC(int32_t, S_GB_ZEROFILL, 12)
ENUM_CONSTANT_NUMERIC(int32_t, S_INTERPOSING, 13)
ENUM_CONSTANT_NUMERIC(int32_t, S_16BYTE_LITERALS, 14)
ENUM_CONSTANT_NUMERIC(int32_t, S_DTRACE_DOF, 15)
ENUM_CONSTANT_NUMERIC(int32_t, S_THREAD_LOCAL_REGULAR, 17)
ENUM_CONSTANT_NUMERIC(int32_t, S_THREAD_LOCAL_ZEROFILL, 18)
ENUM_CONSTANT_NUMERIC(int32_t, S_THREAD_LOCAL_VARIABLES, 19)
ENUM_CONSTANT_NUMERIC(uint32_t, SECTION_ATTRIBUTES_USR, 4278190080u)
ENUM_CONSTANT_NUMERIC(uint32_t, S_ATTR_PURE_INSTRUCTIONS, 2147483648u)
ENUM_CONSTANT_NUMERIC(int32_t, S_ATTR_NO_TOC, 1073741824)
ENUM_CONSTANT_NUMERIC(int32_t, S_ATTR_STRIP_STATIC_SYMS, 536870912)
ENUM_CONSTANT_NUMERIC(int32_t, S_ATTR_NO_DEAD_STRIP, 268435456)
ENUM_CONSTANT_NUMERIC(int32_t, S_ATTR_LIVE_SUPPORT, 134217728)
ENUM_CONSTANT_NUMERIC(int32_t, S_ATTR_SELF_MODIFYING_CODE, 67108864)
ENUM_CONSTANT_NUMERIC(int32_t, S_ATTR_DEBUG, 33554432)
ENUM_CONSTANT_NUMERIC(int32_t, SECTION_ATTRIBUTES_SYS, 16776960)
ENUM_CONSTANT_NUMERIC(int32_t, S_ATTR_SOME_INSTRUCTIONS, 1024)
ENUM_CONSTANT_NUMERIC(int32_t, S_ATTR_EXT_RELOC, 512)
ENUM_CONSTANT_NUMERIC(int32_t, S_ATTR_LOC_RELOC, 256)


BEGIN_ANON_ENUM()
    ANON_ENUM_KEY(int32_t, N_EXT, 1)
    ANON_ENUM_KEY(int32_t, N_STAB, 224)
    ANON_ENUM_KEY(int32_t, N_PEXT, 16)
    ANON_ENUM_KEY(int32_t, N_TYPE, 14)
    ANON_ENUM_KEY(int32_t, N_UNDF, 0)
    ANON_ENUM_KEY(int32_t, N_ABS, 2)
    ANON_ENUM_KEY(int32_t, N_INDR, 10)
    ANON_ENUM_KEY(int32_t, N_PBUD, 12)
    ANON_ENUM_KEY(int32_t, N_SECT, 14)
END_ANON_ENUM()

BEGIN_ANON_ENUM()
    ANON_ENUM_KEY(int32_t, N_ARM_THUMB_DEF, 8)
    ANON_ENUM_KEY(int32_t, N_NO_DEAD_STRIP, 32)
    ANON_ENUM_KEY(int32_t, N_DESC_DISCARDED, 32)
    ANON_ENUM_KEY(int32_t, N_WEAK_REF, 64)
    ANON_ENUM_KEY(int32_t, N_WEAK_DEF, 128)
    ANON_ENUM_KEY(int32_t, N_REF_TO_WEAK, 128)
    ANON_ENUM_KEY(int32_t, N_SYMBOL_RESOLVER, 256)
END_ANON_ENUM()

BEGIN_ANON_ENUM()
    ANON_ENUM_KEY(int32_t, REFERENCE_FLAG_UNDEFINED_NON_LAZY, 0)
    ANON_ENUM_KEY(int32_t, REFERENCE_FLAG_UNDEFINED_LAZY, 1)
    ANON_ENUM_KEY(int32_t, REFERENCE_FLAG_DEFINED, 2)
    ANON_ENUM_KEY(int32_t, REFERENCE_FLAG_PRIVATE_DEFINED, 3)
    ANON_ENUM_KEY(int32_t, REFERENCE_FLAG_PRIVATE_UNDEFINED_NON_LAZY, 4)
    ANON_ENUM_KEY(int32_t, REFERENCE_FLAG_PRIVATE_UNDEFINED_LAZY, 5)
END_ANON_ENUM()

ENUM_CONSTANT_NUMERIC(uint32_t, R_SCATTERED, 2147483648u)
ENUM_CONSTANT_NUMERIC(int32_t, GENERIC_RELOC_VANILLA, 0)
ENUM_CONSTANT_NUMERIC(int32_t, GENERIC_RELOC_PAIR, 1)
ENUM_CONSTANT_NUMERIC(int32_t, GENERIC_RELOC_SECTDIFF, 2)
ENUM_CONSTANT_NUMERIC(int32_t, GENERIC_RELOC_PB_LA_PTR, 3)
ENUM_CONSTANT_NUMERIC(int32_t, GENERIC_RELOC_LOCAL_SECTDIFF, 4)
ENUM_CONSTANT_NUMERIC(int32_t, X86_64_RELOC_UNSIGNED, 0)
ENUM_CONSTANT_NUMERIC(int32_t, X86_64_RELOC_SIGNED, 1)
ENUM_CONSTANT_NUMERIC(int32_t, X86_64_RELOC_BRANCH, 2)
ENUM_CONSTANT_NUMERIC(int32_t, X86_64_RELOC_GOT_LOAD, 3)
ENUM_CONSTANT_NUMERIC(int32_t, X86_64_RELOC_GOT, 4)
ENUM_CONSTANT_NUMERIC(int32_t, X86_64_RELOC_SUBTRACTOR, 5)
ENUM_CONSTANT_NUMERIC(int32_t, X86_64_RELOC_SIGNED_1, 6)
ENUM_CONSTANT_NUMERIC(int32_t, X86_64_RELOC_SIGNED_2, 7)
ENUM_CONSTANT_NUMERIC(int32_t, X86_64_RELOC_SIGNED_4, 8)
ENUM_CONSTANT_NUMERIC(int32_t, X86_64_RELOC_TLV, 9)


ENUM_CONSTANT_NUMERIC(int32_t, DWARF_VERSION, 3)

BEGIN_ANON_ENUM()
    ANON_ENUM_KEY(int32_t, DW_TAG_array_type, 1)
    ANON_ENUM_KEY(int32_t, DW_TAG_class_type, 2)
    ANON_ENUM_KEY(int32_t, DW_TAG_entry_point, 3)
    ANON_ENUM_KEY(int32_t, DW_TAG_enumeration_type, 4)
    ANON_ENUM_KEY(int32_t, DW_TAG_formal_parameter, 5)
    ANON_ENUM_KEY(int32_t, DW_TAG_imported_declaration, 8)
    ANON_ENUM_KEY(int32_t, DW_TAG_label, 10)
    ANON_ENUM_KEY(int32_t, DW_TAG_lexical_block, 11)
    ANON_ENUM_KEY(int32_t, DW_TAG_member, 13)
    ANON_ENUM_KEY(int32_t, DW_TAG_pointer_type, 15)
    ANON_ENUM_KEY(int32_t, DW_TAG_reference_type, 16)
    ANON_ENUM_KEY(int32_t, DW_TAG_compile_unit, 17)
    ANON_ENUM_KEY(int32_t, DW_TAG_string_type, 18)
    ANON_ENUM_KEY(int32_t, DW_TAG_structure_type, 19)
    ANON_ENUM_KEY(int32_t, DW_TAG_subroutine_type, 21)
    ANON_ENUM_KEY(int32_t, DW_TAG_typedef, 22)
    ANON_ENUM_KEY(int32_t, DW_TAG_union_type, 23)
    ANON_ENUM_KEY(int32_t, DW_TAG_unspecified_parameters, 24)
    ANON_ENUM_KEY(int32_t, DW_TAG_variant, 25)
    ANON_ENUM_KEY(int32_t, DW_TAG_common_block, 26)
    ANON_ENUM_KEY(int32_t, DW_TAG_common_inclusion, 27)
    ANON_ENUM_KEY(int32_t, DW_TAG_inheritance, 28)
    ANON_ENUM_KEY(int32_t, DW_TAG_inlined_subroutine, 29)
    ANON_ENUM_KEY(int32_t, DW_TAG_module, 30)
    ANON_ENUM_KEY(int32_t, DW_TAG_ptr_to_member_type, 31)
    ANON_ENUM_KEY(int32_t, DW_TAG_set_type, 32)
    ANON_ENUM_KEY(int32_t, DW_TAG_subrange_type, 33)
    ANON_ENUM_KEY(int32_t, DW_TAG_with_stmt, 34)
    ANON_ENUM_KEY(int32_t, DW_TAG_access_declaration, 35)
    ANON_ENUM_KEY(int32_t, DW_TAG_base_type, 36)
    ANON_ENUM_KEY(int32_t, DW_TAG_catch_block, 37)
    ANON_ENUM_KEY(int32_t, DW_TAG_const_type, 38)
    ANON_ENUM_KEY(int32_t, DW_TAG_constant, 39)
    ANON_ENUM_KEY(int32_t, DW_TAG_enumerator, 40)
    ANON_ENUM_KEY(int32_t, DW_TAG_file_type, 41)
    ANON_ENUM_KEY(int32_t, DW_TAG_friend, 42)
    ANON_ENUM_KEY(int32_t, DW_TAG_namelist, 43)
    ANON_ENUM_KEY(int32_t, DW_TAG_namelist_item, 44)
    ANON_ENUM_KEY(int32_t, DW_TAG_packed_type, 45)
    ANON_ENUM_KEY(int32_t, DW_TAG_subprogram, 46)
    ANON_ENUM_KEY(int32_t, DW_TAG_template_type_param, 47)
    ANON_ENUM_KEY(int32_t, DW_TAG_template_value_param, 48)
    ANON_ENUM_KEY(int32_t, DW_TAG_thrown_type, 49)
    ANON_ENUM_KEY(int32_t, DW_TAG_try_block, 50)
    ANON_ENUM_KEY(int32_t, DW_TAG_variant_part, 51)
    ANON_ENUM_KEY(int32_t, DW_TAG_variable, 52)
    ANON_ENUM_KEY(int32_t, DW_TAG_volatile_type, 53)
    ANON_ENUM_KEY(int32_t, DW_TAG_dwarf_procedure, 54)
    ANON_ENUM_KEY(int32_t, DW_TAG_restrict_type, 55)
    ANON_ENUM_KEY(int32_t, DW_TAG_interface_type, 56)
    ANON_ENUM_KEY(int32_t, DW_TAG_namespace, 57)
    ANON_ENUM_KEY(int32_t, DW_TAG_imported_module, 58)
    ANON_ENUM_KEY(int32_t, DW_TAG_unspecified_type, 59)
    ANON_ENUM_KEY(int32_t, DW_TAG_partial_unit, 60)
    ANON_ENUM_KEY(int32_t, DW_TAG_imported_unit, 61)
    ANON_ENUM_KEY(int32_t, DW_TAG_condition, 63)
    ANON_ENUM_KEY(int32_t, DW_TAG_shared_type, 64)
    ANON_ENUM_KEY(int32_t, DW_TAG_type_unit, 65)
    ANON_ENUM_KEY(int32_t, DW_TAG_rvalue_reference_type, 66)
    ANON_ENUM_KEY(int32_t, DW_TAG_template_alias, 67)
    ANON_ENUM_KEY(int32_t, DW_TAG_lo_user, 16512)
    ANON_ENUM_KEY(int32_t, DW_TAG_hi_user, 65535)
END_ANON_ENUM()

BEGIN_ANON_ENUM()
    ANON_ENUM_KEY(int32_t, DW_CHILDREN_no, 0)
    ANON_ENUM_KEY(int32_t, DW_CHILDREN_yes, 1)
END_ANON_ENUM()

BEGIN_ANON_ENUM()
    ANON_ENUM_KEY(int32_t, DW_AT_sibling, 1)
    ANON_ENUM_KEY(int32_t, DW_AT_location, 2)
    ANON_ENUM_KEY(int32_t, DW_AT_name, 3)
    ANON_ENUM_KEY(int32_t, DW_AT_ordering, 9)
    ANON_ENUM_KEY(int32_t, DW_AT_byte_size, 11)
    ANON_ENUM_KEY(int32_t, DW_AT_bit_offset, 12)
    ANON_ENUM_KEY(int32_t, DW_AT_bit_size, 13)
    ANON_ENUM_KEY(int32_t, DW_AT_stmt_list, 16)
    ANON_ENUM_KEY(int32_t, DW_AT_low_pc, 17)
    ANON_ENUM_KEY(int32_t, DW_AT_high_pc, 18)
    ANON_ENUM_KEY(int32_t, DW_AT_language, 19)
    ANON_ENUM_KEY(int32_t, DW_AT_discr, 21)
    ANON_ENUM_KEY(int32_t, DW_AT_discr_value, 22)
    ANON_ENUM_KEY(int32_t, DW_AT_visibility, 23)
    ANON_ENUM_KEY(int32_t, DW_AT_import, 24)
    ANON_ENUM_KEY(int32_t, DW_AT_string_length, 25)
    ANON_ENUM_KEY(int32_t, DW_AT_common_reference, 26)
    ANON_ENUM_KEY(int32_t, DW_AT_comp_dir, 27)
    ANON_ENUM_KEY(int32_t, DW_AT_const_value, 28)
    ANON_ENUM_KEY(int32_t, DW_AT_containing_type, 29)
    ANON_ENUM_KEY(int32_t, DW_AT_default_value, 30)
    ANON_ENUM_KEY(int32_t, DW_AT_inline, 32)
    ANON_ENUM_KEY(int32_t, DW_AT_is_optional, 33)
    ANON_ENUM_KEY(int32_t, DW_AT_lower_bound, 34)
    ANON_ENUM_KEY(int32_t, DW_AT_producer, 37)
    ANON_ENUM_KEY(int32_t, DW_AT_prototyped, 39)
    ANON_ENUM_KEY(int32_t, DW_AT_return_addr, 42)
    ANON_ENUM_KEY(int32_t, DW_AT_start_scope, 44)
    ANON_ENUM_KEY(int32_t, DW_AT_stride_size, 46)
    ANON_ENUM_KEY(int32_t, DW_AT_upper_bound, 47)
    ANON_ENUM_KEY(int32_t, DW_AT_abstract_origin, 49)
    ANON_ENUM_KEY(int32_t, DW_AT_accessibility, 50)
    ANON_ENUM_KEY(int32_t, DW_AT_address_class, 51)
    ANON_ENUM_KEY(int32_t, DW_AT_artificial, 52)
    ANON_ENUM_KEY(int32_t, DW_AT_base_types, 53)
    ANON_ENUM_KEY(int32_t, DW_AT_calling_convention, 54)
    ANON_ENUM_KEY(int32_t, DW_AT_count, 55)
    ANON_ENUM_KEY(int32_t, DW_AT_data_member_location, 56)
    ANON_ENUM_KEY(int32_t, DW_AT_decl_column, 57)
    ANON_ENUM_KEY(int32_t, DW_AT_decl_file, 58)
    ANON_ENUM_KEY(int32_t, DW_AT_decl_line, 59)
    ANON_ENUM_KEY(int32_t, DW_AT_declaration, 60)
    ANON_ENUM_KEY(int32_t, DW_AT_discr_list, 61)
    ANON_ENUM_KEY(int32_t, DW_AT_encoding, 62)
    ANON_ENUM_KEY(int32_t, DW_AT_external, 63)
    ANON_ENUM_KEY(int32_t, DW_AT_frame_base, 64)
    ANON_ENUM_KEY(int32_t, DW_AT_friend, 65)
    ANON_ENUM_KEY(int32_t, DW_AT_identifier_case, 66)
    ANON_ENUM_KEY(int32_t, DW_AT_macro_info, 67)
    ANON_ENUM_KEY(int32_t, DW_AT_namelist_item, 68)
    ANON_ENUM_KEY(int32_t, DW_AT_priority, 69)
    ANON_ENUM_KEY(int32_t, DW_AT_segment, 70)
    ANON_ENUM_KEY(int32_t, DW_AT_specification, 71)
    ANON_ENUM_KEY(int32_t, DW_AT_static_link, 72)
    ANON_ENUM_KEY(int32_t, DW_AT_type, 73)
    ANON_ENUM_KEY(int32_t, DW_AT_use_location, 74)
    ANON_ENUM_KEY(int32_t, DW_AT_variable_parameter, 75)
    ANON_ENUM_KEY(int32_t, DW_AT_virtuality, 76)
    ANON_ENUM_KEY(int32_t, DW_AT_vtable_elem_location, 77)
    ANON_ENUM_KEY(int32_t, DW_AT_allocated, 78)
    ANON_ENUM_KEY(int32_t, DW_AT_associated, 79)
    ANON_ENUM_KEY(int32_t, DW_AT_data_location, 80)
    ANON_ENUM_KEY(int32_t, DW_AT_byte_stride, 81)
    ANON_ENUM_KEY(int32_t, DW_AT_entry_pc, 82)
    ANON_ENUM_KEY(int32_t, DW_AT_use_UTF8, 83)
    ANON_ENUM_KEY(int32_t, DW_AT_extension, 84)
    ANON_ENUM_KEY(int32_t, DW_AT_ranges, 85)
    ANON_ENUM_KEY(int32_t, DW_AT_trampoline, 86)
    ANON_ENUM_KEY(int32_t, DW_AT_call_column, 87)
    ANON_ENUM_KEY(int32_t, DW_AT_call_file, 88)
    ANON_ENUM_KEY(int32_t, DW_AT_call_line, 89)
    ANON_ENUM_KEY(int32_t, DW_AT_description, 90)
    ANON_ENUM_KEY(int32_t, DW_AT_binary_scale, 91)
    ANON_ENUM_KEY(int32_t, DW_AT_decimal_scale, 92)
    ANON_ENUM_KEY(int32_t, DW_AT_small, 93)
    ANON_ENUM_KEY(int32_t, DW_AT_decimal_sign, 94)
    ANON_ENUM_KEY(int32_t, DW_AT_digit_count, 95)
    ANON_ENUM_KEY(int32_t, DW_AT_picture_string, 96)
    ANON_ENUM_KEY(int32_t, DW_AT_mutable, 97)
    ANON_ENUM_KEY(int32_t, DW_AT_threads_scaled, 98)
    ANON_ENUM_KEY(int32_t, DW_AT_explicit, 99)
    ANON_ENUM_KEY(int32_t, DW_AT_object_pointer, 100)
    ANON_ENUM_KEY(int32_t, DW_AT_endianity, 101)
    ANON_ENUM_KEY(int32_t, DW_AT_elemental, 102)
    ANON_ENUM_KEY(int32_t, DW_AT_pure, 103)
    ANON_ENUM_KEY(int32_t, DW_AT_recursive, 104)
    ANON_ENUM_KEY(int32_t, DW_AT_signature, 105)
    ANON_ENUM_KEY(int32_t, DW_AT_main_subprogram, 106)
    ANON_ENUM_KEY(int32_t, DW_AT_data_bit_offset, 107)
    ANON_ENUM_KEY(int32_t, DW_AT_const_expr, 108)
    ANON_ENUM_KEY(int32_t, DW_AT_enum_class, 109)
    ANON_ENUM_KEY(int32_t, DW_AT_linkage_name, 110)
    ANON_ENUM_KEY(int32_t, DW_AT_lo_user, 8192)
    ANON_ENUM_KEY(int32_t, DW_AT_MIPS_linkage_name, 8199)
    ANON_ENUM_KEY(int32_t, DW_AT_GNU_vector, 8455)
    ANON_ENUM_KEY(int32_t, DW_AT_hi_user, 16383)
END_ANON_ENUM()

BEGIN_ANON_ENUM()
    ANON_ENUM_KEY(int32_t, DW_FORM_addr, 1)
    ANON_ENUM_KEY(int32_t, DW_FORM_block2, 3)
    ANON_ENUM_KEY(int32_t, DW_FORM_block4, 4)
    ANON_ENUM_KEY(int32_t, DW_FORM_data2, 5)
    ANON_ENUM_KEY(int32_t, DW_FORM_data4, 6)
    ANON_ENUM_KEY(int32_t, DW_FORM_data8, 7)
    ANON_ENUM_KEY(int32_t, DW_FORM_string, 8)
    ANON_ENUM_KEY(int32_t, DW_FORM_block, 9)
    ANON_ENUM_KEY(int32_t, DW_FORM_block1, 10)
    ANON_ENUM_KEY(int32_t, DW_FORM_data1, 11)
    ANON_ENUM_KEY(int32_t, DW_FORM_flag, 12)
    ANON_ENUM_KEY(int32_t, DW_FORM_sdata, 13)
    ANON_ENUM_KEY(int32_t, DW_FORM_strp, 14)
    ANON_ENUM_KEY(int32_t, DW_FORM_udata, 15)
    ANON_ENUM_KEY(int32_t, DW_FORM_ref_addr, 16)
    ANON_ENUM_KEY(int32_t, DW_FORM_ref1, 17)
    ANON_ENUM_KEY(int32_t, DW_FORM_ref2, 18)
    ANON_ENUM_KEY(int32_t, DW_FORM_ref4, 19)
    ANON_ENUM_KEY(int32_t, DW_FORM_ref8, 20)
    ANON_ENUM_KEY(int32_t, DW_FORM_ref_udata, 21)
    ANON_ENUM_KEY(int32_t, DW_FORM_indirect, 22)
    ANON_ENUM_KEY(int32_t, DW_FORM_sec_offset, 23)
    ANON_ENUM_KEY(int32_t, DW_FORM_exprloc, 24)
    ANON_ENUM_KEY(int32_t, DW_FORM_flag_present, 25)
    ANON_ENUM_KEY(int32_t, DW_FORM_ref_sig8, 32)
END_ANON_ENUM()

BEGIN_ANON_ENUM()
    ANON_ENUM_KEY(int32_t, DW_OP_addr, 3)
    ANON_ENUM_KEY(int32_t, DW_OP_deref, 6)
    ANON_ENUM_KEY(int32_t, DW_OP_const1u, 8)
    ANON_ENUM_KEY(int32_t, DW_OP_const1s, 9)
    ANON_ENUM_KEY(int32_t, DW_OP_const2u, 10)
    ANON_ENUM_KEY(int32_t, DW_OP_const2s, 11)
    ANON_ENUM_KEY(int32_t, DW_OP_const4u, 12)
    ANON_ENUM_KEY(int32_t, DW_OP_const4s, 13)
    ANON_ENUM_KEY(int32_t, DW_OP_const8u, 14)
    ANON_ENUM_KEY(int32_t, DW_OP_const8s, 15)
    ANON_ENUM_KEY(int32_t, DW_OP_constu, 16)
    ANON_ENUM_KEY(int32_t, DW_OP_consts, 17)
    ANON_ENUM_KEY(int32_t, DW_OP_dup, 18)
    ANON_ENUM_KEY(int32_t, DW_OP_drop, 19)
    ANON_ENUM_KEY(int32_t, DW_OP_over, 20)
    ANON_ENUM_KEY(int32_t, DW_OP_pick, 21)
    ANON_ENUM_KEY(int32_t, DW_OP_swap, 22)
    ANON_ENUM_KEY(int32_t, DW_OP_rot, 23)
    ANON_ENUM_KEY(int32_t, DW_OP_xderef, 24)
    ANON_ENUM_KEY(int32_t, DW_OP_abs, 25)
    ANON_ENUM_KEY(int32_t, DW_OP_and, 26)
    ANON_ENUM_KEY(int32_t, DW_OP_div, 27)
    ANON_ENUM_KEY(int32_t, DW_OP_minus, 28)
    ANON_ENUM_KEY(int32_t, DW_OP_mod, 29)
    ANON_ENUM_KEY(int32_t, DW_OP_mul, 30)
    ANON_ENUM_KEY(int32_t, DW_OP_neg, 31)
    ANON_ENUM_KEY(int32_t, DW_OP_not, 32)
    ANON_ENUM_KEY(int32_t, DW_OP_or, 33)
    ANON_ENUM_KEY(int32_t, DW_OP_plus, 34)
    ANON_ENUM_KEY(int32_t, DW_OP_plus_uconst, 35)
    ANON_ENUM_KEY(int32_t, DW_OP_shl, 36)
    ANON_ENUM_KEY(int32_t, DW_OP_shr, 37)
    ANON_ENUM_KEY(int32_t, DW_OP_shra, 38)
    ANON_ENUM_KEY(int32_t, DW_OP_xor, 39)
    ANON_ENUM_KEY(int32_t, DW_OP_skip, 47)
    ANON_ENUM_KEY(int32_t, DW_OP_bra, 40)
    ANON_ENUM_KEY(int32_t, DW_OP_eq, 41)
    ANON_ENUM_KEY(int32_t, DW_OP_ge, 42)
    ANON_ENUM_KEY(int32_t, DW_OP_gt, 43)
    ANON_ENUM_KEY(int32_t, DW_OP_le, 44)
    ANON_ENUM_KEY(int32_t, DW_OP_lt, 45)
    ANON_ENUM_KEY(int32_t, DW_OP_ne, 46)
    ANON_ENUM_KEY(int32_t, DW_OP_lit0, 48)
    ANON_ENUM_KEY(int32_t, DW_OP_lit1, 49)
    ANON_ENUM_KEY(int32_t, DW_OP_lit31, 79)
    ANON_ENUM_KEY(int32_t, DW_OP_reg0, 80)
    ANON_ENUM_KEY(int32_t, DW_OP_reg1, 81)
    ANON_ENUM_KEY(int32_t, DW_OP_reg31, 111)
    ANON_ENUM_KEY(int32_t, DW_OP_breg0, 112)
    ANON_ENUM_KEY(int32_t, DW_OP_breg1, 113)
    ANON_ENUM_KEY(int32_t, DW_OP_breg31, 143)
    ANON_ENUM_KEY(int32_t, DW_OP_regx, 144)
    ANON_ENUM_KEY(int32_t, DW_OP_fbreg, 145)
    ANON_ENUM_KEY(int32_t, DW_OP_bregx, 146)
    ANON_ENUM_KEY(int32_t, DW_OP_piece, 147)
    ANON_ENUM_KEY(int32_t, DW_OP_deref_size, 148)
    ANON_ENUM_KEY(int32_t, DW_OP_xderef_size, 149)
    ANON_ENUM_KEY(int32_t, DW_OP_nop, 150)
    ANON_ENUM_KEY(int32_t, DW_OP_push_object_address, 151)
    ANON_ENUM_KEY(int32_t, DW_OP_call2, 152)
    ANON_ENUM_KEY(int32_t, DW_OP_call4, 153)
    ANON_ENUM_KEY(int32_t, DW_OP_call_ref, 154)
    ANON_ENUM_KEY(int32_t, DW_OP_form_tls_address, 155)
    ANON_ENUM_KEY(int32_t, DW_OP_call_frame_cfa, 156)
    ANON_ENUM_KEY(int32_t, DW_OP_bit_piece, 157)
    ANON_ENUM_KEY(int32_t, DW_OP_implicit_value, 158)
    ANON_ENUM_KEY(int32_t, DW_OP_stack_value, 159)
    ANON_ENUM_KEY(int32_t, DW_OP_lo_user, 224)
    ANON_ENUM_KEY(int32_t, DW_OP_hi_user, 255)
    ANON_ENUM_KEY(int32_t, DW_OP_GNU_push_tls_address, 224)
END_ANON_ENUM()

BEGIN_ANON_ENUM()
    ANON_ENUM_KEY(int32_t, DW_ATE_address, 1)
    ANON_ENUM_KEY(int32_t, DW_ATE_boolean, 2)
    ANON_ENUM_KEY(int32_t, DW_ATE_complex_float, 3)
    ANON_ENUM_KEY(int32_t, DW_ATE_float, 4)
    ANON_ENUM_KEY(int32_t, DW_ATE_signed, 5)
    ANON_ENUM_KEY(int32_t, DW_ATE_signed_char, 6)
    ANON_ENUM_KEY(int32_t, DW_ATE_unsigned, 7)
    ANON_ENUM_KEY(int32_t, DW_ATE_unsigned_char, 8)
    ANON_ENUM_KEY(int32_t, DW_ATE_imaginary_float, 9)
    ANON_ENUM_KEY(int32_t, DW_ATE_packed_decimal, 10)
    ANON_ENUM_KEY(int32_t, DW_ATE_numeric_string, 11)
    ANON_ENUM_KEY(int32_t, DW_ATE_editted, 12)
    ANON_ENUM_KEY(int32_t, DW_ATE_signed_fixed, 13)
    ANON_ENUM_KEY(int32_t, DW_ATE_unsigned_fixed, 14)
    ANON_ENUM_KEY(int32_t, DW_ATE_decimal_float, 15)
    ANON_ENUM_KEY(int32_t, DW_ATE_UTF, 16)
    ANON_ENUM_KEY(int32_t, DW_ATE_lo_user, 128)
    ANON_ENUM_KEY(int32_t, DW_ATE_hi_user, 255)
END_ANON_ENUM()

BEGIN_ANON_ENUM()
    ANON_ENUM_KEY(int32_t, DW_DS_unsigned, 1)
    ANON_ENUM_KEY(int32_t, DW_DS_leading_overpunch, 2)
    ANON_ENUM_KEY(int32_t, DW_DS_trailing_overpunch, 3)
    ANON_ENUM_KEY(int32_t, DW_DS_leading_separate, 4)
    ANON_ENUM_KEY(int32_t, DW_DS_trailing_separate, 5)
END_ANON_ENUM()

BEGIN_ANON_ENUM()
    ANON_ENUM_KEY(int32_t, DW_END_default, 0)
    ANON_ENUM_KEY(int32_t, DW_END_big, 1)
    ANON_ENUM_KEY(int32_t, DW_END_little, 2)
    ANON_ENUM_KEY(int32_t, DW_END_lo_user, 64)
    ANON_ENUM_KEY(int32_t, DW_END_hi_user, 255)
END_ANON_ENUM()

BEGIN_ANON_ENUM()
    ANON_ENUM_KEY(int32_t, DW_ACCESS_public, 1)
    ANON_ENUM_KEY(int32_t, DW_ACCESS_protected, 2)
    ANON_ENUM_KEY(int32_t, DW_ACCESS_private, 3)
END_ANON_ENUM()

BEGIN_ANON_ENUM()
    ANON_ENUM_KEY(int32_t, DW_VIS_local, 1)
    ANON_ENUM_KEY(int32_t, DW_VIS_exported, 2)
    ANON_ENUM_KEY(int32_t, DW_VIS_qualified, 3)
END_ANON_ENUM()

BEGIN_ANON_ENUM()
    ANON_ENUM_KEY(int32_t, DW_VIRTUALITY_none, 0)
    ANON_ENUM_KEY(int32_t, DW_VIRTUALITY_virtual, 1)
    ANON_ENUM_KEY(int32_t, DW_VIRTUALITY_pure_virtual, 2)
END_ANON_ENUM()

BEGIN_ANON_ENUM()
    ANON_ENUM_KEY(int32_t, DW_LANG_C89, 1)
    ANON_ENUM_KEY(int32_t, DW_LANG_C, 2)
    ANON_ENUM_KEY(int32_t, DW_LANG_Ada83, 3)
    ANON_ENUM_KEY(int32_t, DW_LANG_C_plus_plus, 4)
    ANON_ENUM_KEY(int32_t, DW_LANG_Cobol74, 5)
    ANON_ENUM_KEY(int32_t, DW_LANG_Cobol85, 6)
    ANON_ENUM_KEY(int32_t, DW_LANG_Fortran77, 7)
    ANON_ENUM_KEY(int32_t, DW_LANG_Fortran90, 8)
    ANON_ENUM_KEY(int32_t, DW_LANG_Pascal83, 9)
    ANON_ENUM_KEY(int32_t, DW_LANG_Modula2, 10)
    ANON_ENUM_KEY(int32_t, DW_LANG_Java, 11)
    ANON_ENUM_KEY(int32_t, DW_LANG_C99, 12)
    ANON_ENUM_KEY(int32_t, DW_LANG_Ada95, 13)
    ANON_ENUM_KEY(int32_t, DW_LANG_Fortran95, 14)
    ANON_ENUM_KEY(int32_t, DW_LANG_PLI, 15)
    ANON_ENUM_KEY(int32_t, DW_LANG_ObjC, 16)
    ANON_ENUM_KEY(int32_t, DW_LANG_ObjC_plus_plus, 17)
    ANON_ENUM_KEY(int32_t, DW_LANG_UPC, 18)
    ANON_ENUM_KEY(int32_t, DW_LANG_D, 19)
    ANON_ENUM_KEY(int32_t, DW_LANG_lo_user, 32768)
    ANON_ENUM_KEY(int32_t, DW_LANG_hi_user, 65535)
END_ANON_ENUM()

BEGIN_ANON_ENUM()
    ANON_ENUM_KEY(int32_t, DW_ID_case_sensitive, 0)
    ANON_ENUM_KEY(int32_t, DW_ID_up_case, 1)
    ANON_ENUM_KEY(int32_t, DW_ID_down_case, 2)
    ANON_ENUM_KEY(int32_t, DW_ID_case_insensitive, 3)
END_ANON_ENUM()

BEGIN_ANON_ENUM()
    ANON_ENUM_KEY(int32_t, DW_CC_normal, 1)
    ANON_ENUM_KEY(int32_t, DW_CC_program, 2)
    ANON_ENUM_KEY(int32_t, DW_CC_nocall, 3)
    ANON_ENUM_KEY(int32_t, DW_CC_lo_user, 64)
    ANON_ENUM_KEY(int32_t, DW_CC_hi_user, 255)
END_ANON_ENUM()

BEGIN_ANON_ENUM()
    ANON_ENUM_KEY(int32_t, DW_INL_not_inlined, 0)
    ANON_ENUM_KEY(int32_t, DW_INL_inlined, 1)
    ANON_ENUM_KEY(int32_t, DW_INL_declared_not_inlined, 2)
    ANON_ENUM_KEY(int32_t, DW_INL_declared_inlined, 3)
END_ANON_ENUM()

BEGIN_ANON_ENUM()
    ANON_ENUM_KEY(int32_t, DW_ORD_row_major, 0)
    ANON_ENUM_KEY(int32_t, DW_ORD_col_major, 1)
END_ANON_ENUM()

BEGIN_ANON_ENUM()
    ANON_ENUM_KEY(int32_t, DW_DSC_label, 0)
    ANON_ENUM_KEY(int32_t, DW_DSC_range, 1)
END_ANON_ENUM()

BEGIN_ANON_ENUM()
    ANON_ENUM_KEY(int32_t, DW_LNS_copy, 1)
    ANON_ENUM_KEY(int32_t, DW_LNS_advance_pc, 2)
    ANON_ENUM_KEY(int32_t, DW_LNS_advance_line, 3)
    ANON_ENUM_KEY(int32_t, DW_LNS_set_file, 4)
    ANON_ENUM_KEY(int32_t, DW_LNS_set_column, 5)
    ANON_ENUM_KEY(int32_t, DW_LNS_negate_stmt, 6)
    ANON_ENUM_KEY(int32_t, DW_LNS_set_basic_block, 7)
    ANON_ENUM_KEY(int32_t, DW_LNS_const_add_pc, 8)
    ANON_ENUM_KEY(int32_t, DW_LNS_fixed_advance_pc, 9)
    ANON_ENUM_KEY(int32_t, DW_LNS_set_prologue_end, 10)
    ANON_ENUM_KEY(int32_t, DW_LNS_set_epilogue_begin, 11)
    ANON_ENUM_KEY(int32_t, DW_LNS_set_isa, 12)
END_ANON_ENUM()

BEGIN_ANON_ENUM()
    ANON_ENUM_KEY(int32_t, DW_LNE_end_sequence, 1)
    ANON_ENUM_KEY(int32_t, DW_LNE_set_address, 2)
    ANON_ENUM_KEY(int32_t, DW_LNE_define_file, 3)
    ANON_ENUM_KEY(int32_t, DW_LNE_lo_user, 128)
    ANON_ENUM_KEY(int32_t, DW_LNE_hi_user, 255)
END_ANON_ENUM()

BEGIN_ANON_ENUM()
    ANON_ENUM_KEY(int32_t, DW_MACINFO_define, 1)
    ANON_ENUM_KEY(int32_t, DW_MACINFO_undef, 2)
    ANON_ENUM_KEY(int32_t, DW_MACINFO_start_file, 3)
    ANON_ENUM_KEY(int32_t, DW_MACINFO_end_file, 4)
    ANON_ENUM_KEY(int32_t, DW_MACINFO_vendor_ext, 255)
END_ANON_ENUM()

BEGIN_ANON_ENUM()
    ANON_ENUM_KEY(int32_t, DW_CFA_advance_loc, 64)
    ANON_ENUM_KEY(int32_t, DW_CFA_offset, 128)
    ANON_ENUM_KEY(int32_t, DW_CFA_restore, 192)
    ANON_ENUM_KEY(int32_t, DW_CFA_nop, 0)
    ANON_ENUM_KEY(int32_t, DW_CFA_set_loc, 1)
    ANON_ENUM_KEY(int32_t, DW_CFA_advance_loc1, 2)
    ANON_ENUM_KEY(int32_t, DW_CFA_advance_loc2, 3)
    ANON_ENUM_KEY(int32_t, DW_CFA_advance_loc4, 4)
    ANON_ENUM_KEY(int32_t, DW_CFA_offset_extended, 5)
    ANON_ENUM_KEY(int32_t, DW_CFA_restore_extended, 6)
    ANON_ENUM_KEY(int32_t, DW_CFA_undefined, 7)
    ANON_ENUM_KEY(int32_t, DW_CFA_same_value, 8)
    ANON_ENUM_KEY(int32_t, DW_CFA_register, 9)
    ANON_ENUM_KEY(int32_t, DW_CFA_remember_state, 10)
    ANON_ENUM_KEY(int32_t, DW_CFA_restore_state, 11)
    ANON_ENUM_KEY(int32_t, DW_CFA_def_cfa, 12)
    ANON_ENUM_KEY(int32_t, DW_CFA_def_cfa_register, 13)
    ANON_ENUM_KEY(int32_t, DW_CFA_def_cfa_offset, 14)
    ANON_ENUM_KEY(int32_t, DW_CFA_def_cfa_expression, 15)
    ANON_ENUM_KEY(int32_t, DW_CFA_expression, 16)
    ANON_ENUM_KEY(int32_t, DW_CFA_offset_extended_sf, 17)
    ANON_ENUM_KEY(int32_t, DW_CFA_def_cfa_sf, 18)
    ANON_ENUM_KEY(int32_t, DW_CFA_def_cfa_offset_sf, 19)
    ANON_ENUM_KEY(int32_t, DW_CFA_val_offset, 20)
    ANON_ENUM_KEY(int32_t, DW_CFA_val_offset_sf, 21)
    ANON_ENUM_KEY(int32_t, DW_CFA_val_expression, 22)
    ANON_ENUM_KEY(int32_t, DW_CFA_GNU_window_save, 45)
    ANON_ENUM_KEY(int32_t, DW_CFA_GNU_args_size, 46)
    ANON_ENUM_KEY(int32_t, DW_CFA_GNU_negative_offset_extended, 47)
    ANON_ENUM_KEY(int32_t, DW_CFA_lo_user, 28)
    ANON_ENUM_KEY(int32_t, DW_CFA_hi_user, 63)
END_ANON_ENUM()

BEGIN_ANON_ENUM()
    ANON_ENUM_KEY(int32_t, DW_EH_PE_FORMAT_MASK, 15)
    ANON_ENUM_KEY(int32_t, DW_EH_PE_APPL_MASK, 112)
    ANON_ENUM_KEY(int32_t, DW_EH_PE_indirect, 128)
    ANON_ENUM_KEY(int32_t, DW_EH_PE_omit, 255)
    ANON_ENUM_KEY(int32_t, DW_EH_PE_ptr, 0)
    ANON_ENUM_KEY(int32_t, DW_EH_PE_uleb128, 1)
    ANON_ENUM_KEY(int32_t, DW_EH_PE_udata2, 2)
    ANON_ENUM_KEY(int32_t, DW_EH_PE_udata4, 3)
    ANON_ENUM_KEY(int32_t, DW_EH_PE_udata8, 4)
    ANON_ENUM_KEY(int32_t, DW_EH_PE_sleb128, 9)
    ANON_ENUM_KEY(int32_t, DW_EH_PE_sdata2, 10)
    ANON_ENUM_KEY(int32_t, DW_EH_PE_sdata4, 11)
    ANON_ENUM_KEY(int32_t, DW_EH_PE_sdata8, 12)
    ANON_ENUM_KEY(int32_t, DW_EH_PE_absptr, 0)
    ANON_ENUM_KEY(int32_t, DW_EH_PE_pcrel, 16)
    ANON_ENUM_KEY(int32_t, DW_EH_PE_textrel, 32)
    ANON_ENUM_KEY(int32_t, DW_EH_PE_datarel, 48)
    ANON_ENUM_KEY(int32_t, DW_EH_PE_funcrel, 64)
    ANON_ENUM_KEY(int32_t, DW_EH_PE_aligned, 80)
END_ANON_ENUM()

BEGIN_ANON_ENUM()
    ANON_ENUM_KEY(int32_t, ADDSS, 15929176)
    ANON_ENUM_KEY(int32_t, ADDSD, 15863640)
    ANON_ENUM_KEY(int32_t, ADDPS, 3928)
    ANON_ENUM_KEY(int32_t, ADDPD, 6688600)
    ANON_ENUM_KEY(int32_t, PADDB, 6688764)
    ANON_ENUM_KEY(int32_t, PADDW, 6688765)
    ANON_ENUM_KEY(int32_t, PADDD, 6688766)
    ANON_ENUM_KEY(int32_t, PADDQ, 6688724)
    ANON_ENUM_KEY(int32_t, SUBSS, 15929180)
    ANON_ENUM_KEY(int32_t, SUBSD, 15863644)
    ANON_ENUM_KEY(int32_t, SUBPS, 3932)
    ANON_ENUM_KEY(int32_t, SUBPD, 6688604)
    ANON_ENUM_KEY(int32_t, PSUBB, 6688760)
    ANON_ENUM_KEY(int32_t, PSUBW, 6688761)
    ANON_ENUM_KEY(int32_t, PSUBD, 6688762)
    ANON_ENUM_KEY(int32_t, PSUBQ, 6688763)
    ANON_ENUM_KEY(int32_t, MULSS, 15929177)
    ANON_ENUM_KEY(int32_t, MULSD, 15863641)
    ANON_ENUM_KEY(int32_t, MULPS, 3929)
    ANON_ENUM_KEY(int32_t, MULPD, 6688601)
    ANON_ENUM_KEY(int32_t, PMULLW, 6688725)
    ANON_ENUM_KEY(int32_t, DIVSS, 15929182)
    ANON_ENUM_KEY(int32_t, DIVSD, 15863646)
    ANON_ENUM_KEY(int32_t, DIVPS, 3934)
    ANON_ENUM_KEY(int32_t, DIVPD, 6688606)
    ANON_ENUM_KEY(int32_t, PAND, 6688731)
    ANON_ENUM_KEY(int32_t, POR, 6688747)
    ANON_ENUM_KEY(int32_t, UCOMISS, 3886)
    ANON_ENUM_KEY(int32_t, UCOMISD, 6688558)
    ANON_ENUM_KEY(int32_t, XORPS, 3927)
    ANON_ENUM_KEY(int32_t, XORPD, 6688599)
    ANON_ENUM_KEY(int32_t, STOSS, 15929105)
    ANON_ENUM_KEY(int32_t, STOSD, 15863569)
    ANON_ENUM_KEY(int32_t, STOAPS, 3881)
    ANON_ENUM_KEY(int32_t, STOAPD, 6688553)
    ANON_ENUM_KEY(int32_t, STODQA, 6688639)
    ANON_ENUM_KEY(int32_t, STOD, 6688638)
    ANON_ENUM_KEY(int32_t, STOQ, 6688726)
    ANON_ENUM_KEY(int32_t, LODSS, 15929104)
    ANON_ENUM_KEY(int32_t, LODSD, 15863568)
    ANON_ENUM_KEY(int32_t, LODAPS, 3880)
    ANON_ENUM_KEY(int32_t, LODAPD, 6688552)
    ANON_ENUM_KEY(int32_t, LODDQA, 6688623)
    ANON_ENUM_KEY(int32_t, LODD, 6688622)
    ANON_ENUM_KEY(int32_t, LODQ, 15929214)
    ANON_ENUM_KEY(int32_t, LODDQU, 15929199)
    ANON_ENUM_KEY(int32_t, STODQU, 15929215)
    ANON_ENUM_KEY(int32_t, MOVDQ2Q, 15863766)
    ANON_ENUM_KEY(int32_t, MOVHLPS, 3858)
    ANON_ENUM_KEY(int32_t, LODHPD, 6688534)
    ANON_ENUM_KEY(int32_t, STOHPD, 6688535)
    ANON_ENUM_KEY(int32_t, LODHPS, 3862)
    ANON_ENUM_KEY(int32_t, STOHPS, 3863)
    ANON_ENUM_KEY(int32_t, MOVLHPS, 3862)
    ANON_ENUM_KEY(int32_t, LODLPD, 6688530)
    ANON_ENUM_KEY(int32_t, STOLPD, 6688531)
    ANON_ENUM_KEY(int32_t, LODLPS, 3858)
    ANON_ENUM_KEY(int32_t, STOLPS, 3859)
    ANON_ENUM_KEY(int32_t, MOVMSKPD, 6688592)
    ANON_ENUM_KEY(int32_t, MOVMSKPS, 3920)
    ANON_ENUM_KEY(int32_t, MOVNTDQ, 6688743)
    ANON_ENUM_KEY(int32_t, MOVNTI, 4035)
    ANON_ENUM_KEY(int32_t, MOVNTPD, 6688555)
    ANON_ENUM_KEY(int32_t, MOVNTPS, 3883)
    ANON_ENUM_KEY(int32_t, MOVNTQ, 4071)
    ANON_ENUM_KEY(int32_t, MOVQ2DQ, 15929302)
    ANON_ENUM_KEY(int32_t, LODUPD, 6688528)
    ANON_ENUM_KEY(int32_t, STOUPD, 6688529)
    ANON_ENUM_KEY(int32_t, LODUPS, 3856)
    ANON_ENUM_KEY(int32_t, STOUPS, 3857)
    ANON_ENUM_KEY(int32_t, PACKSSDW, 6688619)
    ANON_ENUM_KEY(int32_t, PACKSSWB, 6688611)
    ANON_ENUM_KEY(int32_t, PACKUSWB, 6688615)
    ANON_ENUM_KEY(int32_t, PADDSB, 6688748)
    ANON_ENUM_KEY(int32_t, PADDSW, 6688749)
    ANON_ENUM_KEY(int32_t, PADDUSB, 6688732)
    ANON_ENUM_KEY(int32_t, PADDUSW, 6688733)
    ANON_ENUM_KEY(int32_t, PANDN, 6688735)
    ANON_ENUM_KEY(int32_t, PCMPEQB, 6688628)
    ANON_ENUM_KEY(int32_t, PCMPEQD, 6688630)
    ANON_ENUM_KEY(int32_t, PCMPEQW, 6688629)
    ANON_ENUM_KEY(int32_t, PCMPGTB, 6688612)
    ANON_ENUM_KEY(int32_t, PCMPGTD, 6688614)
    ANON_ENUM_KEY(int32_t, PCMPGTW, 6688613)
    ANON_ENUM_KEY(int32_t, PMADDWD, 6688757)
    ANON_ENUM_KEY(int32_t, PSLLW, 6688753)
    ANON_ENUM_KEY(int32_t, PSLLD, 6688754)
    ANON_ENUM_KEY(int32_t, PSLLQ, 6688755)
    ANON_ENUM_KEY(int32_t, PSRAW, 6688737)
    ANON_ENUM_KEY(int32_t, PSRAD, 6688738)
    ANON_ENUM_KEY(int32_t, PSRLW, 6688721)
    ANON_ENUM_KEY(int32_t, PSRLD, 6688722)
    ANON_ENUM_KEY(int32_t, PSRLQ, 6688723)
    ANON_ENUM_KEY(int32_t, PSUBSB, 6688744)
    ANON_ENUM_KEY(int32_t, PSUBSW, 6688745)
    ANON_ENUM_KEY(int32_t, PSUBUSB, 6688728)
    ANON_ENUM_KEY(int32_t, PSUBUSW, 6688729)
    ANON_ENUM_KEY(int32_t, PUNPCKHBW, 6688616)
    ANON_ENUM_KEY(int32_t, PUNPCKHDQ, 6688618)
    ANON_ENUM_KEY(int32_t, PUNPCKHWD, 6688617)
    ANON_ENUM_KEY(int32_t, PUNPCKLBW, 6688608)
    ANON_ENUM_KEY(int32_t, PUNPCKLDQ, 6688610)
    ANON_ENUM_KEY(int32_t, PUNPCKLWD, 6688609)
    ANON_ENUM_KEY(int32_t, PXOR, 6688751)
    ANON_ENUM_KEY(int32_t, ANDPD, 6688596)
    ANON_ENUM_KEY(int32_t, ANDPS, 3924)
    ANON_ENUM_KEY(int32_t, ANDNPD, 6688597)
    ANON_ENUM_KEY(int32_t, ANDNPS, 3925)
    ANON_ENUM_KEY(int32_t, CMPPS, 4034)
    ANON_ENUM_KEY(int32_t, CMPPD, 6688706)
    ANON_ENUM_KEY(int32_t, CMPSD, 15863746)
    ANON_ENUM_KEY(int32_t, CMPSS, 15929282)
    ANON_ENUM_KEY(int32_t, COMISD, 6688559)
    ANON_ENUM_KEY(int32_t, COMISS, 3887)
    ANON_ENUM_KEY(int32_t, CVTDQ2PD, 15929318)
    ANON_ENUM_KEY(int32_t, CVTDQ2PS, 3931)
    ANON_ENUM_KEY(int32_t, CVTPD2DQ, 15863782)
    ANON_ENUM_KEY(int32_t, CVTPD2PI, 6688557)
    ANON_ENUM_KEY(int32_t, CVTPD2PS, 6688602)
    ANON_ENUM_KEY(int32_t, CVTPI2PD, 6688554)
    ANON_ENUM_KEY(int32_t, CVTPI2PS, 3882)
    ANON_ENUM_KEY(int32_t, CVTPS2DQ, 6688603)
    ANON_ENUM_KEY(int32_t, CVTPS2PD, 3930)
    ANON_ENUM_KEY(int32_t, CVTPS2PI, 3885)
    ANON_ENUM_KEY(int32_t, CVTSD2SI, 15863597)
    ANON_ENUM_KEY(int32_t, CVTSD2SS, 15863642)
    ANON_ENUM_KEY(int32_t, CVTSI2SD, 15863594)
    ANON_ENUM_KEY(int32_t, CVTSI2SS, 15929130)
    ANON_ENUM_KEY(int32_t, CVTSS2SD, 15929178)
    ANON_ENUM_KEY(int32_t, CVTSS2SI, 15929133)
    ANON_ENUM_KEY(int32_t, CVTTPD2PI, 6688556)
    ANON_ENUM_KEY(int32_t, CVTTPD2DQ, 6688742)
    ANON_ENUM_KEY(int32_t, CVTTPS2DQ, 15929179)
    ANON_ENUM_KEY(int32_t, CVTTPS2PI, 3884)
    ANON_ENUM_KEY(int32_t, CVTTSD2SI, 15863596)
    ANON_ENUM_KEY(int32_t, CVTTSS2SI, 15929132)
    ANON_ENUM_KEY(int32_t, MASKMOVDQU, 6688759)
    ANON_ENUM_KEY(int32_t, MASKMOVQ, 4087)
    ANON_ENUM_KEY(int32_t, MAXPD, 6688607)
    ANON_ENUM_KEY(int32_t, MAXPS, 3935)
    ANON_ENUM_KEY(int32_t, MAXSD, 15863647)
    ANON_ENUM_KEY(int32_t, MAXSS, 15929183)
    ANON_ENUM_KEY(int32_t, MINPD, 6688605)
    ANON_ENUM_KEY(int32_t, MINPS, 3933)
    ANON_ENUM_KEY(int32_t, MINSD, 15863645)
    ANON_ENUM_KEY(int32_t, MINSS, 15929181)
    ANON_ENUM_KEY(int32_t, ORPD, 6688598)
    ANON_ENUM_KEY(int32_t, ORPS, 3926)
    ANON_ENUM_KEY(int32_t, PAVGB, 6688736)
    ANON_ENUM_KEY(int32_t, PAVGW, 6688739)
    ANON_ENUM_KEY(int32_t, PMAXSW, 6688750)
    ANON_ENUM_KEY(int32_t, PINSRW, 6688708)
    ANON_ENUM_KEY(int32_t, PMAXUB, 6688734)
    ANON_ENUM_KEY(int32_t, PMINSW, 6688746)
    ANON_ENUM_KEY(int32_t, PMINUB, 6688730)
    ANON_ENUM_KEY(int32_t, PMOVMSKB, 6688727)
    ANON_ENUM_KEY(int32_t, PMULHUW, 6688740)
    ANON_ENUM_KEY(int32_t, PMULHW, 6688741)
    ANON_ENUM_KEY(int32_t, PMULUDQ, 6688756)
    ANON_ENUM_KEY(int32_t, PSADBW, 6688758)
    ANON_ENUM_KEY(int32_t, PUNPCKHQDQ, 6688621)
    ANON_ENUM_KEY(int32_t, PUNPCKLQDQ, 6688620)
    ANON_ENUM_KEY(int32_t, RCPPS, 3923)
    ANON_ENUM_KEY(int32_t, RCPSS, 15929171)
    ANON_ENUM_KEY(int32_t, RSQRTPS, 3922)
    ANON_ENUM_KEY(int32_t, RSQRTSS, 15929170)
    ANON_ENUM_KEY(int32_t, SQRTPD, 6688593)
    ANON_ENUM_KEY(int32_t, SHUFPD, 6688710)
    ANON_ENUM_KEY(int32_t, SHUFPS, 4038)
    ANON_ENUM_KEY(int32_t, SQRTPS, 3921)
    ANON_ENUM_KEY(int32_t, SQRTSD, 15863633)
    ANON_ENUM_KEY(int32_t, SQRTSS, 15929169)
    ANON_ENUM_KEY(int32_t, UNPCKHPD, 6688533)
    ANON_ENUM_KEY(int32_t, UNPCKHPS, 3861)
    ANON_ENUM_KEY(int32_t, UNPCKLPD, 6688532)
    ANON_ENUM_KEY(int32_t, UNPCKLPS, 3860)
    ANON_ENUM_KEY(int32_t, PSHUFD, 6688624)
    ANON_ENUM_KEY(int32_t, PSHUFHW, 15929200)
    ANON_ENUM_KEY(int32_t, PSHUFLW, 15863664)
    ANON_ENUM_KEY(int32_t, PSHUFW, 3952)
    ANON_ENUM_KEY(int32_t, PSLLDQ, 124129139)
    ANON_ENUM_KEY(int32_t, PSRLDQ, 57020275)
    ANON_ENUM_KEY(int32_t, PREFETCH, 3864)
    ANON_ENUM_KEY(int32_t, PEXTRW, 6688709)
    ANON_ENUM_KEY(int32_t, STMXCSR, 4014)
    ANON_ENUM_KEY(int32_t, ADDSUBPD, 6688720)
    ANON_ENUM_KEY(int32_t, ADDSUBPS, 15863760)
    ANON_ENUM_KEY(int32_t, HADDPD, 6688636)
    ANON_ENUM_KEY(int32_t, HADDPS, 15863676)
    ANON_ENUM_KEY(int32_t, HSUBPD, 6688637)
    ANON_ENUM_KEY(int32_t, HSUBPS, 15863677)
    ANON_ENUM_KEY(int32_t, MOVDDUP, 15863570)
    ANON_ENUM_KEY(int32_t, MOVSHDUP, 15929110)
    ANON_ENUM_KEY(int32_t, MOVSLDUP, 15929106)
    ANON_ENUM_KEY(int32_t, LDDQU, 15863792)
    ANON_ENUM_KEY(int32_t, MONITOR, 983496)
    ANON_ENUM_KEY(int32_t, MWAIT, 983497)
    ANON_ENUM_KEY(int32_t, PALIGNR, 1712273935)
    ANON_ENUM_KEY(int32_t, PHADDD, 1712273410)
    ANON_ENUM_KEY(int32_t, PHADDW, 1712273409)
    ANON_ENUM_KEY(int32_t, PHADDSW, 1712273411)
    ANON_ENUM_KEY(int32_t, PABSB, 1712273436)
    ANON_ENUM_KEY(int32_t, PABSD, 1712273438)
    ANON_ENUM_KEY(int32_t, PABSW, 1712273437)
    ANON_ENUM_KEY(int32_t, PSIGNB, 1712273416)
    ANON_ENUM_KEY(int32_t, PSIGND, 1712273418)
    ANON_ENUM_KEY(int32_t, PSIGNW, 1712273417)
    ANON_ENUM_KEY(int32_t, PSHUFB, 1712273408)
    ANON_ENUM_KEY(int32_t, PMADDUBSW, 1712273412)
    ANON_ENUM_KEY(int32_t, PMULHRSW, 1712273419)
    ANON_ENUM_KEY(int32_t, PHSUBD, 1712273414)
    ANON_ENUM_KEY(int32_t, PHSUBW, 1712273413)
    ANON_ENUM_KEY(int32_t, PHSUBSW, 1712273415)
    ANON_ENUM_KEY(int32_t, BLENDPD, 1712273933)
    ANON_ENUM_KEY(int32_t, BLENDPS, 1712273932)
    ANON_ENUM_KEY(int32_t, BLENDVPD, 1712273429)
    ANON_ENUM_KEY(int32_t, BLENDVPS, 1712273428)
    ANON_ENUM_KEY(int32_t, DPPD, 1712273985)
    ANON_ENUM_KEY(int32_t, DPPS, 1712273984)
    ANON_ENUM_KEY(int32_t, EXTRACTPS, 1712273943)
    ANON_ENUM_KEY(int32_t, INSERTPS, 1712273953)
    ANON_ENUM_KEY(int32_t, MPSADBW, 1712273986)
    ANON_ENUM_KEY(int32_t, PBLENDVB, 1712273424)
    ANON_ENUM_KEY(int32_t, PBLENDW, 1712273934)
    ANON_ENUM_KEY(int32_t, PEXTRD, 1712273942)
    ANON_ENUM_KEY(int32_t, PEXTRQ, 1712273942)
    ANON_ENUM_KEY(int32_t, PINSRB, 1712273952)
    ANON_ENUM_KEY(int32_t, PINSRD, 1712273954)
    ANON_ENUM_KEY(int32_t, PINSRQ, 1712273954)
    ANON_ENUM_KEY(int32_t, MOVNTDQA, 1712273450)
    ANON_ENUM_KEY(int32_t, PACKUSDW, 1712273451)
    ANON_ENUM_KEY(int32_t, PCMPEQQ, 1712273449)
    ANON_ENUM_KEY(int32_t, PEXTRB, 1712273940)
    ANON_ENUM_KEY(int32_t, PHMINPOSUW, 1712273473)
    ANON_ENUM_KEY(int32_t, PMAXSB, 1712273468)
    ANON_ENUM_KEY(int32_t, PMAXSD, 1712273469)
    ANON_ENUM_KEY(int32_t, PMAXUD, 1712273471)
    ANON_ENUM_KEY(int32_t, PMAXUW, 1712273470)
    ANON_ENUM_KEY(int32_t, PMINSB, 1712273464)
    ANON_ENUM_KEY(int32_t, PMINSD, 1712273465)
    ANON_ENUM_KEY(int32_t, PMINUD, 1712273467)
    ANON_ENUM_KEY(int32_t, PMINUW, 1712273466)
    ANON_ENUM_KEY(int32_t, PMOVSXBW, 1712273440)
    ANON_ENUM_KEY(int32_t, PMOVSXBD, 1712273441)
    ANON_ENUM_KEY(int32_t, PMOVSXBQ, 1712273442)
    ANON_ENUM_KEY(int32_t, PMOVSXWD, 1712273443)
    ANON_ENUM_KEY(int32_t, PMOVSXWQ, 1712273444)
    ANON_ENUM_KEY(int32_t, PMOVSXDQ, 1712273445)
    ANON_ENUM_KEY(int32_t, PMOVZXBW, 1712273456)
    ANON_ENUM_KEY(int32_t, PMOVZXBD, 1712273457)
    ANON_ENUM_KEY(int32_t, PMOVZXBQ, 1712273458)
    ANON_ENUM_KEY(int32_t, PMOVZXWD, 1712273459)
    ANON_ENUM_KEY(int32_t, PMOVZXWQ, 1712273460)
    ANON_ENUM_KEY(int32_t, PMOVZXDQ, 1712273461)
    ANON_ENUM_KEY(int32_t, PMULDQ, 1712273448)
    ANON_ENUM_KEY(int32_t, PMULLD, 1712273472)
    ANON_ENUM_KEY(int32_t, PTEST, 1712273431)
    ANON_ENUM_KEY(int32_t, ROUNDPD, 1712273929)
    ANON_ENUM_KEY(int32_t, ROUNDPS, 1712273928)
    ANON_ENUM_KEY(int32_t, ROUNDSD, 1712273931)
    ANON_ENUM_KEY(int32_t, ROUNDSS, 1712273930)
    ANON_ENUM_KEY(int32_t, PCMPESTRI, 1712274017)
    ANON_ENUM_KEY(int32_t, PCMPESTRM, 1712274016)
    ANON_ENUM_KEY(int32_t, PCMPISTRI, 1712274019)
    ANON_ENUM_KEY(int32_t, PCMPISTRM, 1712274018)
    ANON_ENUM_KEY(int32_t, PCMPGTQ, 1712273463)
    ANON_ENUM_KEY(int32_t, POPCNT, 15929272)
    ANON_ENUM_KEY(int32_t, XGETBV, 983504)
    ANON_ENUM_KEY(int32_t, XSETBV, 983505)
    ANON_ENUM_KEY(int32_t, VBROADCASTSS, 1712273432)
    ANON_ENUM_KEY(int32_t, VBROADCASTSD, 1712273433)
    ANON_ENUM_KEY(int32_t, VBROADCASTF128, 1712273434)
    ANON_ENUM_KEY(int32_t, VINSERTF128, 1712273944)
    ANON_ENUM_KEY(int32_t, VPBROADCASTB, 1712273528)
    ANON_ENUM_KEY(int32_t, VPBROADCASTW, 1712273529)
    ANON_ENUM_KEY(int32_t, VPBROADCASTD, 1712273496)
    ANON_ENUM_KEY(int32_t, VPBROADCASTQ, 1712273497)
    ANON_ENUM_KEY(int32_t, VBROADCASTI128, 1712273498)
    ANON_ENUM_KEY(int32_t, VINSERTI128, 1712273976)
    ANON_ENUM_KEY(int32_t, AESENC, 1712273628)
    ANON_ENUM_KEY(int32_t, AESENCLAST, 1712273629)
    ANON_ENUM_KEY(int32_t, AESDEC, 1712273630)
    ANON_ENUM_KEY(int32_t, AESDECLAST, 1712273631)
    ANON_ENUM_KEY(int32_t, AESIMC, 1712273627)
    ANON_ENUM_KEY(int32_t, AESKEYGENASSIST, 1712274143)
END_ANON_ENUM()

struct LIST
{
    LIST* next;
    int32_t count;
    union
    {
        void* ptr;
        int32_t data;
    };
    LIST() : next(), count() {}
};

typedef LIST* list_t;

typedef void(*list_free_fp)(void* );

extern LIST* list_next(LIST* list);

extern void* list_ptr(LIST* list);

extern int32_t list_data(LIST* list);

extern void list_prependdata(LIST** plist, int32_t d);

extern LIST* list_alloc();

extern LIST* list_new();

extern void list_delete(LIST* list);

extern void list_free(LIST** plist, void(*freeptr)(void* ) );

extern void list_free(LIST** l);

extern void* list_subtract(LIST** plist, void* ptr);

extern void* list_pop(LIST** plist);

extern LIST* list_append(LIST** plist, void* ptr);

extern LIST* list_prepend(LIST** plist, void* ptr);

extern int32_t list_nitems(LIST* list);

extern LIST* list_nth(LIST* list, int32_t n);

extern int32_t list_equal(LIST* list1, LIST* list2);

extern LIST* list_inlist(LIST* list, void* ptr);

extern void list_apply(LIST** plist, void(*fp)(void* ) );

extern LIST* list_reverse(LIST* l);

struct ListRange
{
    ListRange(LIST* li);
    LIST* front();
    void popFront();
    bool empty() const;
    LIST* li;
    ListRange() {}
};

typedef uint16_t Elf32_Half;

typedef uint32_t Elf32_Word;

typedef int32_t Elf32_Sword;

typedef uint32_t Elf32_Addr;

typedef uint32_t Elf32_Off;

typedef uint32_t elf_u8_f32;

ENUM_CONSTANT_NUMERIC(int32_t, EI_NIDENT, 16)

ENUM_CONSTANT_NUMERIC(int32_t, EI_MAG0, 0)

ENUM_CONSTANT_NUMERIC(int32_t, EI_MAG1, 1)

ENUM_CONSTANT_NUMERIC(int32_t, EI_MAG2, 2)

ENUM_CONSTANT_NUMERIC(int32_t, EI_MAG3, 3)

ENUM_CONSTANT_NUMERIC(int32_t, ELFMAG0, 127)

ENUM_CONSTANT_NUMERIC(char, ELFMAG1, 'E')

ENUM_CONSTANT_NUMERIC(char, ELFMAG2, 'L')

ENUM_CONSTANT_NUMERIC(char, ELFMAG3, 'F')

ENUM_CONSTANT_NUMERIC(int32_t, EI_CLASS, 4)

ENUM_CONSTANT_NUMERIC(int32_t, ELFCLASSNONE, 0)

ENUM_CONSTANT_NUMERIC(int32_t, ELFCLASS32, 1)

ENUM_CONSTANT_NUMERIC(int32_t, ELFCLASS64, 2)

ENUM_CONSTANT_NUMERIC(int32_t, EI_DATA, 5)

ENUM_CONSTANT_NUMERIC(int32_t, ELFDATANONE, 0)

ENUM_CONSTANT_NUMERIC(int32_t, ELFDATA2LSB, 1)

ENUM_CONSTANT_NUMERIC(int32_t, ELFDATA2MSB, 2)

ENUM_CONSTANT_NUMERIC(int32_t, EI_VERSION, 6)

ENUM_CONSTANT_NUMERIC(int32_t, EI_OSABI, 7)

ENUM_CONSTANT_NUMERIC(int32_t, ELFOSABI_SYSV, 0)

ENUM_CONSTANT_NUMERIC(int32_t, ELFOSABI_HPUX, 1)

ENUM_CONSTANT_NUMERIC(int32_t, ELFOSABI_NETBSD, 2)

ENUM_CONSTANT_NUMERIC(int32_t, ELFOSABI_LINUX, 3)

ENUM_CONSTANT_NUMERIC(int32_t, ELFOSABI_FREEBSD, 9)

ENUM_CONSTANT_NUMERIC(int32_t, ELFOSABI_OPENBSD, 12)

ENUM_CONSTANT_NUMERIC(int32_t, ELFOSABI_ARM, 97)

ENUM_CONSTANT_NUMERIC(int32_t, ELFOSABI_STANDALONE, 255)

ENUM_CONSTANT_NUMERIC(int32_t, EI_ABIVERSION, 8)

ENUM_CONSTANT_NUMERIC(int32_t, EI_PAD, 9)

ENUM_CONSTANT_NUMERIC(int32_t, ET_NONE, 0)

ENUM_CONSTANT_NUMERIC(int32_t, ET_REL, 1)

ENUM_CONSTANT_NUMERIC(int32_t, ET_EXEC, 2)

ENUM_CONSTANT_NUMERIC(int32_t, ET_DYN, 3)

ENUM_CONSTANT_NUMERIC(int32_t, ET_CORE, 4)

ENUM_CONSTANT_NUMERIC(int32_t, ET_LOPROC, 65280)

ENUM_CONSTANT_NUMERIC(int32_t, ET_HIPROC, 65535)

ENUM_CONSTANT_NUMERIC(int32_t, EM_386, 3)

ENUM_CONSTANT_NUMERIC(int32_t, EM_486, 6)

ENUM_CONSTANT_NUMERIC(int32_t, EM_X86_64, 62)

ENUM_CONSTANT_NUMERIC(int32_t, EV_NONE, 0)

ENUM_CONSTANT_NUMERIC(int32_t, EV_CURRENT, 1)

ENUM_CONSTANT_NUMERIC(int32_t, EH_HEADER_SIZE, 52)

ENUM_CONSTANT_NUMERIC(int32_t, EH_PHTENT_SIZE, 32)

ENUM_CONSTANT_NUMERIC(int32_t, EH_SHTENT_SIZE, 40)

ENUM_CONSTANT_NUMERIC(int32_t, SHT_NULL, 0)

ENUM_CONSTANT_NUMERIC(int32_t, SHT_PROGBITS, 1)

ENUM_CONSTANT_NUMERIC(int32_t, SHT_SYMTAB, 2)

ENUM_CONSTANT_NUMERIC(int32_t, SHT_STRTAB, 3)

ENUM_CONSTANT_NUMERIC(int32_t, SHT_RELA, 4)

ENUM_CONSTANT_NUMERIC(int32_t, SHT_HASHTAB, 5)

ENUM_CONSTANT_NUMERIC(int32_t, SHT_DYNAMIC, 6)

ENUM_CONSTANT_NUMERIC(int32_t, SHT_NOTE, 7)

ENUM_CONSTANT_NUMERIC(int32_t, SHT_RESDATA, 8)

ENUM_CONSTANT_NUMERIC(int32_t, SHT_NOBITS, 8)

ENUM_CONSTANT_NUMERIC(int32_t, SHT_REL, 9)

ENUM_CONSTANT_NUMERIC(int32_t, SHT_RESTYPE, 10)

ENUM_CONSTANT_NUMERIC(int32_t, SHT_DYNTAB, 11)

ENUM_CONSTANT_NUMERIC(int32_t, SHT_INIT_ARRAY, 14)

ENUM_CONSTANT_NUMERIC(int32_t, SHT_FINI_ARRAY, 15)

ENUM_CONSTANT_NUMERIC(int32_t, SHT_GROUP, 17)

ENUM_CONSTANT_NUMERIC(int32_t, SHT_SYMTAB_SHNDX, 18)

ENUM_CONSTANT_NUMERIC(int32_t, SHF_WRITE, 1)

ENUM_CONSTANT_NUMERIC(int32_t, SHF_ALLOC, 2)

ENUM_CONSTANT_NUMERIC(int32_t, SHF_EXECINSTR, 4)

ENUM_CONSTANT_NUMERIC(int32_t, SHF_MERGE, 16)

ENUM_CONSTANT_NUMERIC(int32_t, SHF_STRINGS, 32)

ENUM_CONSTANT_NUMERIC(int32_t, SHF_INFO_LINK, 64)

ENUM_CONSTANT_NUMERIC(int32_t, SHF_LINK_ORDER, 128)

ENUM_CONSTANT_NUMERIC(int32_t, SHF_OS_NONCONFORMING, 256)

ENUM_CONSTANT_NUMERIC(int32_t, SHF_GROUP, 512)

ENUM_CONSTANT_NUMERIC(int32_t, SHF_TLS, 1024)

ENUM_CONSTANT_NUMERIC(uint32_t, SHF_MASKPROC, 4026531840u)

ENUM_CONSTANT_NUMERIC(int32_t, SHN_UNDEF, 0)

ENUM_CONSTANT_NUMERIC(int32_t, SHN_LORESERVE, 65280)

ENUM_CONSTANT_NUMERIC(int32_t, SHN_LOPROC, 65280)

ENUM_CONSTANT_NUMERIC(int32_t, SHN_HIPROC, 65311)

ENUM_CONSTANT_NUMERIC(int32_t, SHN_LOOS, 65312)

ENUM_CONSTANT_NUMERIC(int32_t, SHN_HIOS, 65343)

ENUM_CONSTANT_NUMERIC(int32_t, SHN_ABS, 65521)

ENUM_CONSTANT_NUMERIC(int32_t, SHN_COMMON, 65522)

ENUM_CONSTANT_NUMERIC(int32_t, SHN_XINDEX, 65535)

ENUM_CONSTANT_NUMERIC(int32_t, SHN_HIRESERVE, 65535)

ENUM_CONSTANT_NUMERIC(int32_t, STB_LOCAL, 0)

ENUM_CONSTANT_NUMERIC(int32_t, STB_GLOBAL, 1)

ENUM_CONSTANT_NUMERIC(int32_t, STB_WEAK, 2)

ENUM_CONSTANT_NUMERIC(int32_t, ST_NUM_BINDINGS, 3)

ENUM_CONSTANT_NUMERIC(int32_t, STB_LOOS, 10)

ENUM_CONSTANT_NUMERIC(int32_t, STB_HIOS, 12)

ENUM_CONSTANT_NUMERIC(int32_t, STB_LOPROC, 13)

ENUM_CONSTANT_NUMERIC(int32_t, STB_HIPROC, 15)

ENUM_CONSTANT_NUMERIC(int32_t, STT_NOTYPE, 0)

ENUM_CONSTANT_NUMERIC(int32_t, STT_OBJECT, 1)

ENUM_CONSTANT_NUMERIC(int32_t, STT_FUNC, 2)

ENUM_CONSTANT_NUMERIC(int32_t, STT_SECTION, 3)

ENUM_CONSTANT_NUMERIC(int32_t, STT_FILE, 4)

ENUM_CONSTANT_NUMERIC(int32_t, STT_COMMON, 5)

ENUM_CONSTANT_NUMERIC(int32_t, STT_TLS, 6)

ENUM_CONSTANT_NUMERIC(int32_t, STT_NUM, 5)

ENUM_CONSTANT_NUMERIC(int32_t, STT_LOOS, 11)

ENUM_CONSTANT_NUMERIC(int32_t, STT_HIOS, 12)

ENUM_CONSTANT_NUMERIC(int32_t, STT_LOPROC, 13)

ENUM_CONSTANT_NUMERIC(int32_t, STT_HIPROC, 15)

ENUM_CONSTANT_NUMERIC(int32_t, STV_DEFAULT, 0)

ENUM_CONSTANT_NUMERIC(int32_t, STV_INTERNAL, 1)

ENUM_CONSTANT_NUMERIC(int32_t, STV_HIDDEN, 2)

ENUM_CONSTANT_NUMERIC(int32_t, STV_PROTECTED, 3)

ENUM_CONSTANT_NUMERIC(int32_t, R_386_NONE, 0)

ENUM_CONSTANT_NUMERIC(int32_t, R_386_32, 1)

ENUM_CONSTANT_NUMERIC(int32_t, R_386_PC32, 2)

ENUM_CONSTANT_NUMERIC(int32_t, R_386_GOT32, 3)

ENUM_CONSTANT_NUMERIC(int32_t, R_386_PLT32, 4)

ENUM_CONSTANT_NUMERIC(int32_t, R_386_COPY, 5)

ENUM_CONSTANT_NUMERIC(int32_t, R_386_GLOB_DAT, 6)

ENUM_CONSTANT_NUMERIC(int32_t, R_386_JMP_SLOT, 7)

ENUM_CONSTANT_NUMERIC(int32_t, R_386_RELATIVE, 8)

ENUM_CONSTANT_NUMERIC(int32_t, R_386_GOTOFF, 9)

ENUM_CONSTANT_NUMERIC(int32_t, R_386_GOTPC, 10)

ENUM_CONSTANT_NUMERIC(int32_t, R_386_TLS_TPOFF, 14)

ENUM_CONSTANT_NUMERIC(int32_t, R_386_TLS_IE, 15)

ENUM_CONSTANT_NUMERIC(int32_t, R_386_TLS_GOTIE, 16)

ENUM_CONSTANT_NUMERIC(int32_t, R_386_TLS_LE, 17)

ENUM_CONSTANT_NUMERIC(int32_t, R_386_TLS_GD, 18)

ENUM_CONSTANT_NUMERIC(int32_t, R_386_TLS_LDM, 19)

ENUM_CONSTANT_NUMERIC(int32_t, R_386_TLS_GD_32, 24)

ENUM_CONSTANT_NUMERIC(int32_t, R_386_TLS_GD_PUSH, 25)

ENUM_CONSTANT_NUMERIC(int32_t, R_386_TLS_GD_CALL, 26)

ENUM_CONSTANT_NUMERIC(int32_t, R_386_TLS_GD_POP, 27)

ENUM_CONSTANT_NUMERIC(int32_t, R_386_TLS_LDM_32, 28)

ENUM_CONSTANT_NUMERIC(int32_t, R_386_TLS_LDM_PUSH, 29)

ENUM_CONSTANT_NUMERIC(int32_t, R_386_TLS_LDM_CALL, 30)

ENUM_CONSTANT_NUMERIC(int32_t, R_386_TLS_LDM_POP, 31)

ENUM_CONSTANT_NUMERIC(int32_t, R_386_TLS_LDO_32, 32)

ENUM_CONSTANT_NUMERIC(int32_t, R_386_TLS_IE_32, 33)

ENUM_CONSTANT_NUMERIC(int32_t, R_386_TLS_LE_32, 34)

ENUM_CONSTANT_NUMERIC(int32_t, R_386_TLS_DTPMOD32, 35)

ENUM_CONSTANT_NUMERIC(int32_t, R_386_TLS_DTPOFF32, 36)

ENUM_CONSTANT_NUMERIC(int32_t, R_386_TLS_TPOFF32, 37)

ENUM_CONSTANT_NUMERIC(int32_t, DBT_UNDEF, 0)

ENUM_CONSTANT_NUMERIC(int32_t, DBT_EXT, 1)

ENUM_CONSTANT_NUMERIC(int32_t, DBT_ABS, 2)

ENUM_CONSTANT_NUMERIC(int32_t, DBT_TEXT, 4)

ENUM_CONSTANT_NUMERIC(int32_t, DBT_DATA, 6)

ENUM_CONSTANT_NUMERIC(int32_t, DBT_BSS, 8)

ENUM_CONSTANT_NUMERIC(int32_t, DBT_INDR, 10)

ENUM_CONSTANT_NUMERIC(int32_t, DBT_COMM, 18)

ENUM_CONSTANT_NUMERIC(int32_t, DBT_SETA, 20)

ENUM_CONSTANT_NUMERIC(int32_t, DBT_SETT, 22)

ENUM_CONSTANT_NUMERIC(int32_t, DBT_SETD, 24)

ENUM_CONSTANT_NUMERIC(int32_t, DBT_SETB, 26)

ENUM_CONSTANT_NUMERIC(int32_t, DBT_SETV, 28)

ENUM_CONSTANT_NUMERIC(int32_t, DBT_WARNING, 30)

ENUM_CONSTANT_NUMERIC(int32_t, DBT_FN, 31)

ENUM_CONSTANT_NUMERIC(int32_t, DBT_GSYM, 32)

ENUM_CONSTANT_NUMERIC(int32_t, DBT_FUN, 36)

ENUM_CONSTANT_NUMERIC(int32_t, DBT_STSYM, 38)

ENUM_CONSTANT_NUMERIC(int32_t, DBT_LCSYM, 40)

ENUM_CONSTANT_NUMERIC(int32_t, DBT_MAIN, 42)

ENUM_CONSTANT_NUMERIC(int32_t, DBT_RO, 44)

ENUM_CONSTANT_NUMERIC(int32_t, DBT_OPT, 60)

ENUM_CONSTANT_NUMERIC(int32_t, DBT_REG, 64)

ENUM_CONSTANT_NUMERIC(int32_t, DBT_TLINE, 68)

ENUM_CONSTANT_NUMERIC(int32_t, DBT_DLINE, 70)

ENUM_CONSTANT_NUMERIC(int32_t, DBT_BLINE, 72)

ENUM_CONSTANT_NUMERIC(int32_t, DBT_STUN, 98)

ENUM_CONSTANT_NUMERIC(int32_t, DBT_SRCF, 100)

ENUM_CONSTANT_NUMERIC(int32_t, DBT_AUTO, 128)

ENUM_CONSTANT_NUMERIC(int32_t, DBT_TYPE, 128)

ENUM_CONSTANT_NUMERIC(int32_t, DBT_INCS, 132)

ENUM_CONSTANT_NUMERIC(int32_t, DBT_PARAM, 160)

ENUM_CONSTANT_NUMERIC(int32_t, DBT_INCE, 162)

ENUM_CONSTANT_NUMERIC(int32_t, PHT_NULL, 0)

typedef uint64_t Elf64_Addr;

typedef uint64_t Elf64_Off;

typedef uint64_t Elf64_Xword;

typedef int64_t Elf64_Sxword;

typedef int32_t Elf64_Sword;

typedef uint32_t Elf64_Word;

typedef uint16_t Elf64_Half;

ENUM_CONSTANT_NUMERIC(int32_t, R_X86_64_NONE, 0)

ENUM_CONSTANT_NUMERIC(int32_t, R_X86_64_64, 1)

ENUM_CONSTANT_NUMERIC(int32_t, R_X86_64_PC32, 2)

ENUM_CONSTANT_NUMERIC(int32_t, R_X86_64_GOT32, 3)

ENUM_CONSTANT_NUMERIC(int32_t, R_X86_64_PLT32, 4)

ENUM_CONSTANT_NUMERIC(int32_t, R_X86_64_COPY, 5)

ENUM_CONSTANT_NUMERIC(int32_t, R_X86_64_GLOB_DAT, 6)

ENUM_CONSTANT_NUMERIC(int32_t, R_X86_64_JUMP_SLOT, 7)

ENUM_CONSTANT_NUMERIC(int32_t, R_X86_64_RELATIVE, 8)

ENUM_CONSTANT_NUMERIC(int32_t, R_X86_64_GOTPCREL, 9)

ENUM_CONSTANT_NUMERIC(int32_t, R_X86_64_32, 10)

ENUM_CONSTANT_NUMERIC(int32_t, R_X86_64_32S, 11)

ENUM_CONSTANT_NUMERIC(int32_t, R_X86_64_16, 12)

ENUM_CONSTANT_NUMERIC(int32_t, R_X86_64_PC16, 13)

ENUM_CONSTANT_NUMERIC(int32_t, R_X86_64_8, 14)

ENUM_CONSTANT_NUMERIC(int32_t, R_X86_64_PC8, 15)

ENUM_CONSTANT_NUMERIC(int32_t, R_X86_64_DTPMOD64, 16)

ENUM_CONSTANT_NUMERIC(int32_t, R_X86_64_DTPOFF64, 17)

ENUM_CONSTANT_NUMERIC(int32_t, R_X86_64_TPOFF64, 18)

ENUM_CONSTANT_NUMERIC(int32_t, R_X86_64_TLSGD, 19)

ENUM_CONSTANT_NUMERIC(int32_t, R_X86_64_TLSLD, 20)

ENUM_CONSTANT_NUMERIC(int32_t, R_X86_64_DTPOFF32, 21)

ENUM_CONSTANT_NUMERIC(int32_t, R_X86_64_GOTTPOFF, 22)

ENUM_CONSTANT_NUMERIC(int32_t, R_X86_64_TPOFF32, 23)

ENUM_CONSTANT_NUMERIC(int32_t, R_X86_64_PC64, 24)

ENUM_CONSTANT_NUMERIC(int32_t, R_X86_64_GOTOFF64, 25)

ENUM_CONSTANT_NUMERIC(int32_t, R_X86_64_GOTPC32, 26)

ENUM_CONSTANT_NUMERIC(int32_t, R_X86_64_GNU_VTINHERIT, 250)

ENUM_CONSTANT_NUMERIC(int32_t, R_X86_64_GNU_VTENTRY, 251)

ENUM_CONSTANT_NUMERIC(int32_t, GRP_COMDAT, 1)

ENUM_CONSTANT_NUMERIC(int32_t, GRP_MASKOS, 267386880)

ENUM_CONSTANT_NUMERIC(uint32_t, GRP_MASKPROC, 4026531840u)

typedef void* Key;

typedef void* Value;

typedef KeyValueTemplate<void*, void*> KeyValue;

typedef _d_real longdouble;

extern void browse(const char* url);

BEGIN_ENUM(Color, COLOR, color)
    ENUM_KEY(int32_t, black, 0, Color, COLOR, color, C)
    ENUM_KEY(int32_t, red, 1, Color, COLOR, color, C)
    ENUM_KEY(int32_t, green, 2, Color, COLOR, color, C)
    ENUM_KEY(int32_t, blue, 4, Color, COLOR, color, C)
    ENUM_KEY(int32_t, yellow, 3, Color, COLOR, color, C)
    ENUM_KEY(int32_t, magenta, 5, Color, COLOR, color, C)
    ENUM_KEY(int32_t, cyan, 6, Color, COLOR, color, C)
    ENUM_KEY(int32_t, lightGray, 7, Color, COLOR, color, C)
    ENUM_KEY(int32_t, bright, 8, Color, COLOR, color, C)
    ENUM_KEY(int32_t, darkGray, 8, Color, COLOR, color, C)
    ENUM_KEY(int32_t, brightRed, 9, Color, COLOR, color, C)
    ENUM_KEY(int32_t, brightGreen, 10, Color, COLOR, color, C)
    ENUM_KEY(int32_t, brightBlue, 12, Color, COLOR, color, C)
    ENUM_KEY(int32_t, brightYellow, 11, Color, COLOR, color, C)
    ENUM_KEY(int32_t, brightMagenta, 13, Color, COLOR, color, C)
    ENUM_KEY(int32_t, brightCyan, 14, Color, COLOR, color, C)
    ENUM_KEY(int32_t, white, 15, Color, COLOR, color, C)
END_ENUM(Color, COLOR, color)

BEGIN_ENUM_TYPE(Color, Classification, CLASSIFICATION, classification)
    ENUM_KEY_TYPE(Color, error, (Classification)(Color)9, Classification, CLASSIFICATION, classification, C)
    ENUM_KEY_TYPE(Color, gagged, (Classification)(Color)12, Classification, CLASSIFICATION, classification, C)
    ENUM_KEY_TYPE(Color, warning, (Classification)(Color)11, Classification, CLASSIFICATION, classification, C)
    ENUM_KEY_TYPE(Color, deprecation, (Classification)(Color)14, Classification, CLASSIFICATION, classification, C)
    ENUM_KEY_TYPE(Color, tip, (Classification)(Color)10, Classification, CLASSIFICATION, classification, C)
END_ENUM_TYPE(Color, Classification, CLASSIFICATION, classification)

extern void error(const Loc& loc, const char* format, ...);

extern void error(const char* filename, uint32_t linnum, uint32_t charnum, const char* format, ...);

extern void errorSupplemental(const Loc& loc, const char* format, ...);

extern void warning(const Loc& loc, const char* format, ...);

extern void warningSupplemental(const Loc& loc, const char* format, ...);

extern void deprecation(const Loc& loc, const char* format, ...);

extern void deprecationSupplemental(const Loc& loc, const char* format, ...);

extern void message(const Loc& loc, const char* format, ...);

extern void message(const char* format, ...);

extern void tip(const char* format, ...);

extern void verror(const Loc& loc, const char* format, va_list ap, const char* p1, const char* p2, const char* header = "Error: ");

extern void verrorSupplemental(const Loc& loc, const char* format, va_list ap);

extern void vwarning(const Loc& loc, const char* format, va_list ap);

extern void vwarningSupplemental(const Loc& loc, const char* format, va_list ap);

extern void vdeprecation(const Loc& loc, const char* format, va_list ap, const char* p1, const char* p2);

extern void vmessage(const Loc& loc, const char* format, va_list ap);

extern void vtip(const char* format, va_list ap);

extern void vdeprecationSupplemental(const Loc& loc, const char* format, va_list ap);

extern void fatal();

extern void halt();

BEGIN_ENUM_NUMERIC(uint8_t, HIGHLIGHT, HIGHLIGHT, highlight)
    ENUM_KEY_NUMERIC(uint8_t, Default, 0u, HIGHLIGHT, HIGHLIGHT, highlight, HIGHLIGHT)
    ENUM_KEY_NUMERIC(uint8_t, Escape, 255u, HIGHLIGHT, HIGHLIGHT, highlight, HIGHLIGHT)
    ENUM_KEY_NUMERIC(uint8_t, Identifier, 15u, HIGHLIGHT, HIGHLIGHT, highlight, HIGHLIGHT)
    ENUM_KEY_NUMERIC(uint8_t, Keyword, 15u, HIGHLIGHT, HIGHLIGHT, highlight, HIGHLIGHT)
    ENUM_KEY_NUMERIC(uint8_t, Literal, 15u, HIGHLIGHT, HIGHLIGHT, highlight, HIGHLIGHT)
    ENUM_KEY_NUMERIC(uint8_t, Comment, 8u, HIGHLIGHT, HIGHLIGHT, highlight, HIGHLIGHT)
    ENUM_KEY_NUMERIC(uint8_t, Other, 6u, HIGHLIGHT, HIGHLIGHT, highlight, HIGHLIGHT)
END_ENUM_NUMERIC(uint8_t, HIGHLIGHT, HIGHLIGHT, highlight)

BEGIN_ENUM_NUMERIC(bool, TARGET, TARGET, target)
    ENUM_KEY_NUMERIC(bool, Linux, true, TARGET, TARGET, target, TARGET)
    ENUM_KEY_NUMERIC(bool, OSX, false, TARGET, TARGET, target, TARGET)
    ENUM_KEY_NUMERIC(bool, FreeBSD, false, TARGET, TARGET, target, TARGET)
    ENUM_KEY_NUMERIC(bool, OpenBSD, false, TARGET, TARGET, target, TARGET)
    ENUM_KEY_NUMERIC(bool, Solaris, false, TARGET, TARGET, target, TARGET)
    ENUM_KEY_NUMERIC(bool, Windows, false, TARGET, TARGET, target, TARGET)
    ENUM_KEY_NUMERIC(bool, DragonFlyBSD, false, TARGET, TARGET, target, TARGET)
END_ENUM_NUMERIC(bool, TARGET, TARGET, target)

BEGIN_ENUM_NUMERIC(uint8_t, DiagnosticReporting, DIAGNOSTICREPORTING, diagnosticreporting)
    ENUM_KEY_NUMERIC(uint8_t, error, 0u, DiagnosticReporting, DIAGNOSTICREPORTING, diagnosticreporting, DR)
    ENUM_KEY_NUMERIC(uint8_t, inform, 1u, DiagnosticReporting, DIAGNOSTICREPORTING, diagnosticreporting, DR)
    ENUM_KEY_NUMERIC(uint8_t, off, 2u, DiagnosticReporting, DIAGNOSTICREPORTING, diagnosticreporting, DR)
END_ENUM_NUMERIC(uint8_t, DiagnosticReporting, DIAGNOSTICREPORTING, diagnosticreporting)

BEGIN_ENUM_NUMERIC(uint8_t, MessageStyle, MESSAGESTYLE, messagestyle)
    ENUM_KEY_NUMERIC(uint8_t, digitalmars, 0u, MessageStyle, MESSAGESTYLE, messagestyle, MS)
    ENUM_KEY_NUMERIC(uint8_t, gnu, 1u, MessageStyle, MESSAGESTYLE, messagestyle, MS)
END_ENUM_NUMERIC(uint8_t, MessageStyle, MESSAGESTYLE, messagestyle)

BEGIN_ENUM_NUMERIC(uint8_t, CHECKENABLE, CHECKENABLE, checkenable)
    ENUM_KEY_NUMERIC(uint8_t, _default, 0u, CHECKENABLE, CHECKENABLE, checkenable, CHECKENABLE)
    ENUM_KEY_NUMERIC(uint8_t, off, 1u, CHECKENABLE, CHECKENABLE, checkenable, CHECKENABLE)
    ENUM_KEY_NUMERIC(uint8_t, on, 2u, CHECKENABLE, CHECKENABLE, checkenable, CHECKENABLE)
    ENUM_KEY_NUMERIC(uint8_t, safeonly, 3u, CHECKENABLE, CHECKENABLE, checkenable, CHECKENABLE)
END_ENUM_NUMERIC(uint8_t, CHECKENABLE, CHECKENABLE, checkenable)

BEGIN_ENUM_NUMERIC(uint8_t, CHECKACTION, CHECKACTION, checkaction)
    ENUM_KEY_NUMERIC(uint8_t, D, 0u, CHECKACTION, CHECKACTION, checkaction, CHECKACTION)
    ENUM_KEY_NUMERIC(uint8_t, C, 1u, CHECKACTION, CHECKACTION, checkaction, CHECKACTION)
    ENUM_KEY_NUMERIC(uint8_t, halt, 2u, CHECKACTION, CHECKACTION, checkaction, CHECKACTION)
    ENUM_KEY_NUMERIC(uint8_t, context, 3u, CHECKACTION, CHECKACTION, checkaction, CHECKACTION)
END_ENUM_NUMERIC(uint8_t, CHECKACTION, CHECKACTION, checkaction)

BEGIN_ENUM(CPU, CPU, cpu)
    ENUM_KEY(int32_t, x87, 0, CPU, CPU, cpu, CPU)
    ENUM_KEY(int32_t, mmx, 1, CPU, CPU, cpu, CPU)
    ENUM_KEY(int32_t, sse, 2, CPU, CPU, cpu, CPU)
    ENUM_KEY(int32_t, sse2, 3, CPU, CPU, cpu, CPU)
    ENUM_KEY(int32_t, sse3, 4, CPU, CPU, cpu, CPU)
    ENUM_KEY(int32_t, ssse3, 5, CPU, CPU, cpu, CPU)
    ENUM_KEY(int32_t, sse4_1, 6, CPU, CPU, cpu, CPU)
    ENUM_KEY(int32_t, sse4_2, 7, CPU, CPU, cpu, CPU)
    ENUM_KEY(int32_t, avx, 8, CPU, CPU, cpu, CPU)
    ENUM_KEY(int32_t, avx2, 9, CPU, CPU, cpu, CPU)
    ENUM_KEY(int32_t, avx512, 10, CPU, CPU, cpu, CPU)
    ENUM_KEY(int32_t, baseline, 11, CPU, CPU, cpu, CPU)
    ENUM_KEY(int32_t, native, 12, CPU, CPU, cpu, CPU)
END_ENUM(CPU, CPU, cpu)

BEGIN_ENUM_NUMERIC(uint8_t, PIC, PIC, pic)
    ENUM_KEY_NUMERIC(uint8_t, fixed, 0u, PIC, PIC, pic, PIC)
    ENUM_KEY_NUMERIC(uint8_t, pic, 1u, PIC, PIC, pic, PIC)
    ENUM_KEY_NUMERIC(uint8_t, pie, 2u, PIC, PIC, pic, PIC)
END_ENUM_NUMERIC(uint8_t, PIC, PIC, pic)

BEGIN_ENUM_NUMERIC(uint32_t, CppStdRevision, CPPSTDREVISION, cppstdrevision)
    ENUM_KEY_NUMERIC(uint32_t, cpp98, 199711u, CppStdRevision, CPPSTDREVISION, cppstdrevision, CSR)
    ENUM_KEY_NUMERIC(uint32_t, cpp11, 201103u, CppStdRevision, CPPSTDREVISION, cppstdrevision, CSR)
    ENUM_KEY_NUMERIC(uint32_t, cpp14, 201402u, CppStdRevision, CPPSTDREVISION, cppstdrevision, CSR)
    ENUM_KEY_NUMERIC(uint32_t, cpp17, 201703u, CppStdRevision, CPPSTDREVISION, cppstdrevision, CSR)
END_ENUM_NUMERIC(uint32_t, CppStdRevision, CPPSTDREVISION, cppstdrevision)

BEGIN_ENUM_NUMERIC(uint32_t, CxxHeaderMode, CXXHEADERMODE, cxxheadermode)
    ENUM_KEY_NUMERIC(uint32_t, none, 0u, CxxHeaderMode, CXXHEADERMODE, cxxheadermode, CHM)
    ENUM_KEY_NUMERIC(uint32_t, silent, 1u, CxxHeaderMode, CXXHEADERMODE, cxxheadermode, CHM)
    ENUM_KEY_NUMERIC(uint32_t, verbose, 2u, CxxHeaderMode, CXXHEADERMODE, cxxheadermode, CHM)
END_ENUM_NUMERIC(uint32_t, CxxHeaderMode, CXXHEADERMODE, cxxheadermode)

struct Param
{
    bool obj;
    bool link;
    bool dll;
    bool lib;
    bool multiobj;
    bool oneobj;
    bool trace;
    bool tracegc;
    bool verbose;
    bool vcg_ast;
    bool showColumns;
    bool vtls;
    bool vtemplates;
    bool vtemplatesListInstances;
    bool vgc;
    bool vfield;
    bool vcomplex;
    uint8_t symdebug;
    bool symdebugref;
    bool alwaysframe;
    bool optimize;
    bool map;
    bool is64bit;
    bool isLP64;
    bool isLinux;
    bool isOSX;
    bool isWindows;
    bool isFreeBSD;
    bool isOpenBSD;
    bool isDragonFlyBSD;
    bool isSolaris;
    bool hasObjectiveC;
    bool mscoff;
    DiagnosticReporting useDeprecated;
    bool stackstomp;
    bool useUnitTests;
    bool useInline;
    bool useDIP25;
    bool noDIP25;
    bool useDIP1021;
    bool release;
    bool preservePaths;
    DiagnosticReporting warnings;
    PIC pic;
    bool color;
    bool cov;
    uint8_t covPercent;
    bool ctfe_cov;
    bool nofloat;
    bool ignoreUnsupportedPragmas;
    bool useModuleInfo;
    bool useTypeInfo;
    bool useExceptions;
    bool noSharedAccess;
    bool previewIn;
    bool betterC;
    bool addMain;
    bool allInst;
    bool fix16997;
    bool fixAliasThis;
    bool vsafe;
    bool ehnogc;
    bool dtorFields;
    bool fieldwise;
    bool rvalueRefParam;
    CppStdRevision cplusplus;
    bool markdown;
    bool vmarkdown;
    bool showGaggedErrors;
    bool printErrorContext;
    bool manual;
    bool usage;
    bool mcpuUsage;
    bool transitionUsage;
    bool checkUsage;
    bool checkActionUsage;
    bool revertUsage;
    bool previewUsage;
    bool externStdUsage;
    bool hcUsage;
    bool logo;
    CPU cpu;
    CHECKENABLE useInvariants;
    CHECKENABLE useIn;
    CHECKENABLE useOut;
    CHECKENABLE useArrayBounds;
    CHECKENABLE useAssert;
    CHECKENABLE useSwitchError;
    CHECKENABLE boundscheck;
    CHECKACTION checkAction;
    uint32_t errorLimit;
    DArray< const char > argv0;
    Array<const char*> modFileAliasStrings;
    Array<const char*>* imppath;
    Array<const char*>* fileImppath;
    DArray< const char > objdir;
    DArray< const char > objname;
    DArray< const char > libname;
    bool doDocComments;
    DArray< const char > docdir;
    DArray< const char > docname;
    Array<const char*> ddocfiles;
    bool doHdrGeneration;
    DArray< const char > hdrdir;
    DArray< const char > hdrname;
    bool hdrStripPlainFunctions;
    CxxHeaderMode doCxxHdrGeneration;
    DArray< const char > cxxhdrdir;
    DArray< const char > cxxhdrname;
    bool doJsonGeneration;
    DArray< const char > jsonfilename;
    JsonFieldFlags jsonFieldFlags;
    OutBuffer* mixinOut;
    const char* mixinFile;
    int32_t mixinLines;
    uint32_t debuglevel;
    Array<const char*>* debugids;
    uint32_t versionlevel;
    Array<const char*>* versionids;
    DArray< const char > defaultlibname;
    DArray< const char > debuglibname;
    DArray< const char > mscrtlib;
    DArray< const char > moduleDepsFile;
    OutBuffer* moduleDeps;
    MessageStyle messageStyle;
    bool debugb;
    bool debugc;
    bool debugf;
    bool debugr;
    bool debugx;
    bool debugy;
    bool run;
    Array<const char*> runargs;
    Array<const char*> objfiles;
    Array<const char*> linkswitches;
    Array<bool> linkswitchIsForCC;
    Array<const char*> libfiles;
    Array<const char*> dllfiles;
    DArray< const char > deffile;
    DArray< const char > resfile;
    DArray< const char > exefile;
    DArray< const char > mapfile;
    ~Param();
    Param() : obj(true), link(true), dll(), lib(), multiobj(), oneobj(), trace(), tracegc(), verbose(), vcg_ast(), showColumns(), vtls(), vtemplates(), vtemplatesListInstances(), vgc(), vfield(), vcomplex(), symdebug(), symdebugref(), alwaysframe(), optimize(), map(), is64bit(true), isLP64(), isLinux(), isOSX(), isWindows(), isFreeBSD(), isOpenBSD(), isDragonFlyBSD(), isSolaris(), hasObjectiveC(), mscoff(false), useDeprecated((DiagnosticReporting)1u), stackstomp(), useUnitTests(), useInline(false), useDIP25(), noDIP25(), useDIP1021(), release(), preservePaths(), warnings((DiagnosticReporting)2u), pic((PIC)0u), color(), cov(), covPercent(), ctfe_cov(false), nofloat(), ignoreUnsupportedPragmas(), useModuleInfo(true), useTypeInfo(true), useExceptions(true), noSharedAccess(), previewIn(), betterC(), addMain(), allInst(), fix16997(), fixAliasThis(), vsafe(), ehnogc(), dtorFields(), fieldwise(), rvalueRefParam(), cplusplus((CppStdRevision)199711u), markdown(true), vmarkdown(), showGaggedErrors(), printErrorContext(), manual(), usage(), mcpuUsage(), transitionUsage(), checkUsage(), checkActionUsage(), revertUsage(), previewUsage(), externStdUsage(), hcUsage(), logo(), cpu((CPU)11), useInvariants((CHECKENABLE)0u), useIn((CHECKENABLE)0u), useOut((CHECKENABLE)0u), useArrayBounds((CHECKENABLE)0u), useAssert((CHECKENABLE)0u), useSwitchError((CHECKENABLE)0u), boundscheck((CHECKENABLE)0u), checkAction((CHECKACTION)0u), errorLimit(20u), argv0(), modFileAliasStrings(), imppath(), fileImppath(), objdir(), objname(), libname(), doDocComments(), docdir(), docname(), ddocfiles(), doHdrGeneration(), hdrdir(), hdrname(), hdrStripPlainFunctions(true), cxxhdrdir(), cxxhdrname(), doJsonGeneration(), jsonfilename(), mixinOut(), mixinFile(), mixinLines(), debuglevel(), debugids(), versionlevel(), versionids(), defaultlibname(), debuglibname(), mscrtlib(), moduleDepsFile(), moduleDeps(), messageStyle((MessageStyle)0u), debugb(), debugc(), debugf(), debugr(), debugx(), debugy(), run(), runargs(), objfiles(), linkswitches(), linkswitchIsForCC(), libfiles(), dllfiles(), deffile(), resfile(), exefile(), mapfile() {}
};

typedef uint32_t structalign_t;

ENUM_CONSTANT_NUMERIC(uint32_t, STRUCTALIGN_DEFAULT, 4294967295u)

struct Global
{
    DArray< const char > inifilename;
    DArray< char > mars_ext;
    DArray< const char > obj_ext;
    DArray< const char > lib_ext;
    DArray< const char > dll_ext;
    DArray< char > doc_ext;
    DArray< char > ddoc_ext;
    DArray< char > hdr_ext;
    DArray< char > cxxhdr_ext;
    DArray< char > json_ext;
    DArray< char > map_ext;
    bool run_noext;
    DArray< char > copyright;
    DArray< char > written;
    Array<const char*>* path;
    Array<const char*>* filePath;
    DArray< const char > vendor;
    Param params;
    uint32_t errors;
    uint32_t warnings;
    uint32_t gag;
    uint32_t gaggedErrors;
    uint32_t gaggedWarnings;
    void* console;
    Array<Identifier*>* versionids;
    Array<Identifier*>* debugids;
    ENUM_CONSTANT_NUMERIC(int32_t, recursionLimit, 500)

    uint32_t startGagging();
    bool endGagging(uint32_t oldGagged);
    void increaseErrorCount();
    void _init();
    uint32_t versionNumber();
    const char* const versionChars();
    ~Global();
    Global() : inifilename(), mars_ext("d"), obj_ext(), lib_ext(), dll_ext(), doc_ext("html"), ddoc_ext("ddoc"), hdr_ext("di"), cxxhdr_ext("h"), json_ext("json"), map_ext("map"), run_noext(), copyright("Copyright (C) 1999-2020 by The D Language Foundation, All Rights Reserved"), written("written by Walter Bright"), path(), filePath(), vendor(), params(), errors(), warnings(), gag(), gaggedErrors(), gaggedWarnings(), console(), versionids(), debugids() {}
};

typedef uint64_t dinteger_t;

typedef int64_t sinteger_t;

typedef uint64_t uinteger_t;

typedef int8_t d_int8;

typedef uint8_t d_uns8;

typedef int16_t d_int16;

typedef uint16_t d_uns16;

typedef int32_t d_int32;

typedef uint32_t d_uns32;

typedef int64_t d_int64;

typedef uint64_t d_uns64;

typedef uint64_t StorageClass;

extern Global global;

struct Id
{
    static Identifier* IUnknown;
    static Identifier* Object;
    static Identifier* object;
    static Identifier* string;
    static Identifier* wstring;
    static Identifier* dstring;
    static Identifier* max;
    static Identifier* min;
    static Identifier* This;
    static Identifier* _super;
    static Identifier* ctor;
    static Identifier* dtor;
    static Identifier* __xdtor;
    static Identifier* __fieldDtor;
    static Identifier* __aggrDtor;
    static Identifier* cppdtor;
    static Identifier* ticppdtor;
    static Identifier* postblit;
    static Identifier* __xpostblit;
    static Identifier* __fieldPostblit;
    static Identifier* __aggrPostblit;
    static Identifier* classInvariant;
    static Identifier* unitTest;
    static Identifier* require;
    static Identifier* ensure;
    static Identifier* capture;
    static Identifier* this2;
    static Identifier* _init;
    static Identifier* __sizeof;
    static Identifier* __xalignof;
    static Identifier* _mangleof;
    static Identifier* stringof;
    static Identifier* _tupleof;
    static Identifier* length;
    static Identifier* remove;
    static Identifier* ptr;
    static Identifier* array;
    static Identifier* funcptr;
    static Identifier* dollar;
    static Identifier* ctfe;
    static Identifier* offset;
    static Identifier* offsetof;
    static Identifier* ModuleInfo;
    static Identifier* ClassInfo;
    static Identifier* classinfo;
    static Identifier* typeinfo;
    static Identifier* outer;
    static Identifier* Exception;
    static Identifier* RTInfo;
    static Identifier* Throwable;
    static Identifier* Error;
    static Identifier* withSym;
    static Identifier* result;
    static Identifier* returnLabel;
    static Identifier* line;
    static Identifier* empty;
    static Identifier* p;
    static Identifier* q;
    static Identifier* __vptr;
    static Identifier* __monitor;
    static Identifier* gate;
    static Identifier* __c_long;
    static Identifier* __c_ulong;
    static Identifier* __c_longlong;
    static Identifier* __c_ulonglong;
    static Identifier* __c_long_double;
    static Identifier* __c_wchar_t;
    static Identifier* cpp_type_info_ptr;
    static Identifier* _assert;
    static Identifier* _unittest;
    static Identifier* _body;
    static Identifier* printf;
    static Identifier* scanf;
    static Identifier* TypeInfo;
    static Identifier* TypeInfo_Class;
    static Identifier* TypeInfo_Interface;
    static Identifier* TypeInfo_Struct;
    static Identifier* TypeInfo_Enum;
    static Identifier* TypeInfo_Pointer;
    static Identifier* TypeInfo_Vector;
    static Identifier* TypeInfo_Array;
    static Identifier* TypeInfo_StaticArray;
    static Identifier* TypeInfo_AssociativeArray;
    static Identifier* TypeInfo_Function;
    static Identifier* TypeInfo_Delegate;
    static Identifier* TypeInfo_Tuple;
    static Identifier* TypeInfo_Const;
    static Identifier* TypeInfo_Invariant;
    static Identifier* TypeInfo_Shared;
    static Identifier* TypeInfo_Wild;
    static Identifier* elements;
    static Identifier* _arguments_typeinfo;
    static Identifier* _arguments;
    static Identifier* _argptr;
    static Identifier* destroy;
    static Identifier* xopEquals;
    static Identifier* xopCmp;
    static Identifier* xtoHash;
    static Identifier* LINE;
    static Identifier* FILE;
    static Identifier* MODULE;
    static Identifier* FUNCTION;
    static Identifier* PRETTY_FUNCTION;
    static Identifier* DATE;
    static Identifier* TIME;
    static Identifier* TIMESTAMP;
    static Identifier* VENDOR;
    static Identifier* VERSIONX;
    static Identifier* EOFX;
    static Identifier* nan;
    static Identifier* infinity;
    static Identifier* dig;
    static Identifier* epsilon;
    static Identifier* mant_dig;
    static Identifier* max_10_exp;
    static Identifier* max_exp;
    static Identifier* min_10_exp;
    static Identifier* min_exp;
    static Identifier* min_normal;
    static Identifier* re;
    static Identifier* im;
    static Identifier* C;
    static Identifier* D;
    static Identifier* Windows;
    static Identifier* Pascal;
    static Identifier* System;
    static Identifier* Objective;
    static Identifier* exit;
    static Identifier* success;
    static Identifier* failure;
    static Identifier* keys;
    static Identifier* values;
    static Identifier* rehash;
    static Identifier* future;
    static Identifier* property;
    static Identifier* nogc;
    static Identifier* live;
    static Identifier* safe;
    static Identifier* trusted;
    static Identifier* system;
    static Identifier* disable;
    static Identifier* ___out;
    static Identifier* ___in;
    static Identifier* __int;
    static Identifier* _dollar;
    static Identifier* __LOCAL_SIZE;
    static Identifier* uadd;
    static Identifier* neg;
    static Identifier* com;
    static Identifier* add;
    static Identifier* add_r;
    static Identifier* sub;
    static Identifier* sub_r;
    static Identifier* mul;
    static Identifier* mul_r;
    static Identifier* div;
    static Identifier* div_r;
    static Identifier* mod;
    static Identifier* mod_r;
    static Identifier* eq;
    static Identifier* cmp;
    static Identifier* iand;
    static Identifier* iand_r;
    static Identifier* ior;
    static Identifier* ior_r;
    static Identifier* ixor;
    static Identifier* ixor_r;
    static Identifier* shl;
    static Identifier* shl_r;
    static Identifier* shr;
    static Identifier* shr_r;
    static Identifier* ushr;
    static Identifier* ushr_r;
    static Identifier* cat;
    static Identifier* cat_r;
    static Identifier* assign;
    static Identifier* addass;
    static Identifier* subass;
    static Identifier* mulass;
    static Identifier* divass;
    static Identifier* modass;
    static Identifier* andass;
    static Identifier* orass;
    static Identifier* xorass;
    static Identifier* shlass;
    static Identifier* shrass;
    static Identifier* ushrass;
    static Identifier* catass;
    static Identifier* postinc;
    static Identifier* postdec;
    static Identifier* index;
    static Identifier* indexass;
    static Identifier* slice;
    static Identifier* sliceass;
    static Identifier* call;
    static Identifier* _cast;
    static Identifier* opIn;
    static Identifier* opIn_r;
    static Identifier* opStar;
    static Identifier* opDot;
    static Identifier* opDispatch;
    static Identifier* opDollar;
    static Identifier* opUnary;
    static Identifier* opIndexUnary;
    static Identifier* opSliceUnary;
    static Identifier* opBinary;
    static Identifier* opBinaryRight;
    static Identifier* opOpAssign;
    static Identifier* opIndexOpAssign;
    static Identifier* opSliceOpAssign;
    static Identifier* pow;
    static Identifier* pow_r;
    static Identifier* powass;
    static Identifier* classNew;
    static Identifier* classDelete;
    static Identifier* apply;
    static Identifier* applyReverse;
    static Identifier* Fempty;
    static Identifier* Ffront;
    static Identifier* Fback;
    static Identifier* FpopFront;
    static Identifier* FpopBack;
    static Identifier* aaLen;
    static Identifier* aaKeys;
    static Identifier* aaValues;
    static Identifier* aaRehash;
    static Identifier* monitorenter;
    static Identifier* monitorexit;
    static Identifier* criticalenter;
    static Identifier* criticalexit;
    static Identifier* __ArrayPostblit;
    static Identifier* __ArrayDtor;
    static Identifier* _d_delThrowable;
    static Identifier* _d_assert_fail;
    static Identifier* dup;
    static Identifier* _aaApply;
    static Identifier* _aaApply2;
    static Identifier* Pinline;
    static Identifier* lib;
    static Identifier* linkerDirective;
    static Identifier* mangle;
    static Identifier* msg;
    static Identifier* startaddress;
    static Identifier* crt_constructor;
    static Identifier* crt_destructor;
    static Identifier* tohash;
    static Identifier* tostring;
    static Identifier* getmembers;
    static Identifier* __alloca;
    static Identifier* main;
    static Identifier* WinMain;
    static Identifier* DllMain;
    static Identifier* CMain;
    static Identifier* rt_init;
    static Identifier* __cmp;
    static Identifier* __equals;
    static Identifier* __switch;
    static Identifier* __switch_error;
    static Identifier* __ArrayCast;
    static Identifier* _d_HookTraceImpl;
    static Identifier* _d_arraysetlengthTImpl;
    static Identifier* _d_arraysetlengthT;
    static Identifier* _d_arraysetlengthTTrace;
    static Identifier* stdc;
    static Identifier* stdarg;
    static Identifier* va_start;
    static Identifier* std;
    static Identifier* core;
    static Identifier* etc;
    static Identifier* attribute;
    static Identifier* math;
    static Identifier* trig;
    static Identifier* sin;
    static Identifier* cos;
    static Identifier* tan;
    static Identifier* _sqrt;
    static Identifier* _pow;
    static Identifier* atan2;
    static Identifier* rint;
    static Identifier* ldexp;
    static Identifier* rndtol;
    static Identifier* exp;
    static Identifier* expm1;
    static Identifier* exp2;
    static Identifier* yl2x;
    static Identifier* yl2xp1;
    static Identifier* log;
    static Identifier* log2;
    static Identifier* log10;
    static Identifier* round;
    static Identifier* floor;
    static Identifier* trunc;
    static Identifier* fmax;
    static Identifier* fmin;
    static Identifier* fma;
    static Identifier* isnan;
    static Identifier* isInfinity;
    static Identifier* isfinite;
    static Identifier* ceil;
    static Identifier* copysign;
    static Identifier* fabs;
    static Identifier* toPrec;
    static Identifier* simd;
    static Identifier* __prefetch;
    static Identifier* __simd_sto;
    static Identifier* __simd;
    static Identifier* __simd_ib;
    static Identifier* bitop;
    static Identifier* bsf;
    static Identifier* bsr;
    static Identifier* btc;
    static Identifier* btr;
    static Identifier* bts;
    static Identifier* bswap;
    static Identifier* volatile;
    static Identifier* volatileLoad;
    static Identifier* volatileStore;
    static Identifier* _popcnt;
    static Identifier* inp;
    static Identifier* inpl;
    static Identifier* inpw;
    static Identifier* outp;
    static Identifier* outpl;
    static Identifier* outpw;
    static Identifier* isAbstractClass;
    static Identifier* isArithmetic;
    static Identifier* isAssociativeArray;
    static Identifier* isFinalClass;
    static Identifier* isTemplate;
    static Identifier* isPOD;
    static Identifier* isDeprecated;
    static Identifier* isDisabled;
    static Identifier* isFuture;
    static Identifier* isNested;
    static Identifier* isFloating;
    static Identifier* isIntegral;
    static Identifier* isScalar;
    static Identifier* isStaticArray;
    static Identifier* isUnsigned;
    static Identifier* isVirtualFunction;
    static Identifier* isVirtualMethod;
    static Identifier* isAbstractFunction;
    static Identifier* isFinalFunction;
    static Identifier* isOverrideFunction;
    static Identifier* isStaticFunction;
    static Identifier* isModule;
    static Identifier* isPackage;
    static Identifier* isRef;
    static Identifier* isOut;
    static Identifier* isLazy;
    static Identifier* hasMember;
    static Identifier* identifier;
    static Identifier* getProtection;
    static Identifier* parent;
    static Identifier* child;
    static Identifier* getMember;
    static Identifier* getOverloads;
    static Identifier* getVirtualFunctions;
    static Identifier* getVirtualMethods;
    static Identifier* classInstanceSize;
    static Identifier* allMembers;
    static Identifier* derivedMembers;
    static Identifier* isSame;
    static Identifier* compiles;
    static Identifier* parameters;
    static Identifier* getAliasThis;
    static Identifier* getAttributes;
    static Identifier* getFunctionAttributes;
    static Identifier* getFunctionVariadicStyle;
    static Identifier* getParameterStorageClasses;
    static Identifier* getLinkage;
    static Identifier* getUnitTests;
    static Identifier* getVirtualIndex;
    static Identifier* getPointerBitmap;
    static Identifier* isReturnOnStack;
    static Identifier* isZeroInit;
    static Identifier* getTargetInfo;
    static Identifier* getLocation;
    static Identifier* hasPostblit;
    static Identifier* hasCopyConstructor;
    static Identifier* isCopyable;
    static Identifier* allocator;
    static Identifier* basic_string;
    static Identifier* basic_istream;
    static Identifier* basic_ostream;
    static Identifier* basic_iostream;
    static Identifier* char_traits;
    static Identifier* udaGNUAbiTag;
    static Identifier* udaSelector;
    static Identifier* NULL;
    static Identifier* TRUE;
    static Identifier* FALSE;
    static Identifier* unsigned;
    static Identifier* wchar_t;
    static void initialize();
    Id() {}
};

class Identifier : public RootObject
{
public:
    int32_t value;
    bool isAnonymous_;
    DArray< char > name;
    static Identifier* create(const char* name);
    const char* toChars() const;
    int32_t getValue() const;
    bool isAnonymous() const;
    const char* toHChars2() const;
    DYNCAST dyncast() const;
    static Identifier* generateId(const char* prefix, size_t length, size_t suffix);
    static Identifier* idPool(const char* s, uint32_t len);
    static bool isValidIdentifier(const char* str);
};

struct Token
{
    Token* next;
    Loc loc;
    const char* ptr;
    TOK value;
    DArray< const char > blockComment;
    DArray< const char > lineComment;
    union
    {
        int64_t intvalue;
        uinteger_t unsvalue;
        _d_real floatvalue;
        struct
        {
            const char* ustring;
            uint32_t len;
            uint8_t postfix;
        };
        Identifier* ident;
    };
    int32_t isKeyword() const;
    void setString(const char* ptr, size_t length);
    void setString(const OutBuffer& buf);
    void setString();
    const char* toChars() const;
    static const char* toChars(uint8_t value);
    Token() : next(), loc(), ptr(), blockComment(), lineComment() {}
};

template <typename T>
struct Array
{
    // Ignoring var length alignment 0
    size_t length;
    // Ignoring var data alignment 0
    DArray< T > data;
    // Ignoring var SMALLARRAYCAP alignment 0
    // Ignoring var smallarray alignment 0
    void* smallarray;
    typedef length opDollar;
    typedef length dim;
};

struct CTFloat
{
    ENUM_CONSTANT_NUMERIC(bool, yl2x_supported, true)

    ENUM_CONSTANT_NUMERIC(bool, yl2xp1_supported, true)

    static void yl2x(const _d_real* const x, const _d_real* const y, _d_real* res);
    static void yl2xp1(const _d_real* const x, const _d_real* const y, _d_real* res);
    static _d_real sin(_d_real x);
    static _d_real cos(_d_real x);
    static _d_real tan(_d_real x);
    static _d_real sqrt(_d_real x);
    static _d_real fabs(_d_real x);
    static _d_real ldexp(_d_real n, int32_t exp);
    static _d_real round(_d_real x);
    static _d_real floor(_d_real x);
    static _d_real ceil(_d_real x);
    static _d_real trunc(_d_real x);
    static _d_real log(_d_real x);
    static _d_real log2(_d_real x);
    static _d_real log10(_d_real x);
    static _d_real pow(_d_real x, _d_real y);
    static _d_real exp(_d_real x);
    static _d_real expm1(_d_real x);
    static _d_real exp2(_d_real x);
    static _d_real copysign(_d_real x, _d_real s);
    static _d_real fmin(_d_real x, _d_real y);
    static _d_real fmax(_d_real x, _d_real y);
    static _d_real fma(_d_real x, _d_real y, _d_real z);
    static bool isIdentical(_d_real a, _d_real b);
    static size_t hash(_d_real a);
    static bool isNaN(_d_real r);
    static bool isSNaN(_d_real r);
    static bool isInfinity(_d_real r);
    static _d_real parse(const char* literal, bool* isOutOfRange);
    static int32_t sprint(char* str, char fmt, _d_real x);
    static _d_real zero;
    static _d_real one;
    static _d_real minusone;
    static _d_real half;
    static void initialize();
    CTFloat() {}
};

typedef Array<const char*> Strings;

struct Port
{
    static int32_t memicmp(const char* const s1, const char* const s2, size_t n);
    static char* strupr(char* s);
    static bool isFloat32LiteralOutOfRange(const char* s);
    static bool isFloat64LiteralOutOfRange(const char* s);
    static void writelongLE(uint32_t value, void* buffer);
    static uint32_t readlongLE(const void* const buffer);
    static void writelongBE(uint32_t value, void* buffer);
    static uint32_t readlongBE(const void* const buffer);
    static uint32_t readwordLE(const void* const buffer);
    static uint32_t readwordBE(const void* const buffer);
    static void valcpy(void* dst, uint64_t val, size_t size);
    Port() {}
};

ENUM_CONSTANT_NUMERIC(bool, isGCAvailable, true)

struct Mem
{
    static char* xstrdup(const char* s);
    static void xfree(void* p);
    static void* xmalloc(size_t size);
    static void* xmalloc_noscan(size_t size);
    static void* xcalloc(size_t size, size_t n);
    static void* xcalloc_noscan(size_t size, size_t n);
    static void* xrealloc(void* p, size_t size);
    static void* xrealloc_noscan(void* p, size_t size);
    static void* error();
    static void* check(void* p);
    static bool _isGCEnabled;
    static bool isGCEnabled();
    static void disableGC();
    static void addRange(const void* p, size_t size);
    static void removeRange(const void* p);
    Mem() {}
};

extern const Mem mem;

ENUM_CONSTANT_NUMERIC(int32_t, CHUNK_SIZE, 1048512)

ENUM_CONSTANT_NUMERIC(bool, OVERRIDE_MEMALLOC, true)

extern "C" void* _d_allocmemory(size_t m_size);

extern "C" Object* _d_newclass(const TypeInfo_Class* const ci);

extern "C" void* _d_newitemT(TypeInfo* ti);

extern "C" void* _d_newitemiT(TypeInfo* ti);

